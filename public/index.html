<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Discord Soundboard</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üîä</text></svg>">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=DM+Sans:ital,opsz,wght@0,9..40,400;0,9..40,500;0,9..40,600;0,9..40,700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg: #0f0f12;
            --surface: #18181c;
            --surface-hover: #1f1f24;
            --border: #2a2a32;
            --text: #e4e4e7;
            --text-muted: #a1a1aa;
            --accent: #7c3aed;
            --accent-hover: #6d28d9;
            --danger: #dc2626;
            --danger-hover: #b91c1c;
            --success: #22c55e;
            --radius: 12px;
            --radius-sm: 8px;
            --shadow: 0 4px 24px rgba(0,0,0,0.4);
        }
        [data-theme="light"] {
            --bg: #f4f4f5;
            --surface: #ffffff;
            --surface-hover: #e4e4e7;
            --border: #d4d4d8;
            --text: #18181b;
            --text-muted: #71717a;
            --accent: #7c3aed;
            --accent-hover: #6d28d9;
            --danger: #dc2626;
            --danger-hover: #b91c1c;
            --success: #22c55e;
            --shadow: 0 4px 24px rgba(0,0,0,0.08);
        }
        [data-theme="light"] .waveform-placeholder { color: var(--text-muted); }
        [data-theme="light"] .sound-btn:hover:not(:disabled) { background: var(--border); }
        [data-theme="light"] canvas { background: transparent; }
        [data-theme="light"] .player { background: linear-gradient(135deg, var(--surface) 0%, #f0f0f2 100%); }
        [data-theme="light"] .waveform-wrap { background: rgba(0,0,0,0.06); }
        .theme-toggle-login { width: 32px; height: 32px; padding: 0; border: 1px solid var(--border); border-radius: var(--radius-sm); background: var(--surface-hover); color: var(--text-muted); cursor: pointer; font-size: 1rem; display: flex; align-items: center; justify-content: center; }
        .theme-toggle-login:hover { color: var(--accent); border-color: var(--accent); }
        * { box-sizing: border-box; }
        body {
            font-family: 'DM Sans', system-ui, sans-serif;
            margin: 0;
            min-height: 100vh;
            background: var(--bg);
            color: var(--text);
            line-height: 1.5;
        }
        .app { max-width: 720px; margin: 0 auto; padding: 1.5rem; }
        .app.hidden { display: none; }
        .hidden { display: none !important; }
        .login-screen {
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 1.5rem;
        }
        .login-screen.hidden { display: none; }
        .login-card {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            padding: 2rem;
            width: 100%;
            max-width: 360px;
            box-shadow: var(--shadow);
        }
        .login-card h1 { font-size: 1.5rem; margin: 0 0 1.5rem; }
        .login-card label { display: block; font-size: 0.85rem; color: var(--text-muted); margin-bottom: 0.35rem; }
        .login-card input {
            width: 100%;
            padding: 0.65rem 0.75rem;
            background: var(--surface-hover);
            border: 1px solid var(--border);
            border-radius: var(--radius-sm);
            color: var(--text);
            font: inherit;
            margin-bottom: 1rem;
        }
        .login-card input:focus { outline: none; border-color: var(--accent); }
        .login-card .btn { width: 100%; padding: 0.75rem; margin-top: 0.5rem; }
        .login-error { color: var(--danger); font-size: 0.85rem; margin-top: 0.5rem; }
        .login-card .signup-link { font-size: 0.9rem; margin-top: 0.75rem; text-align: center; }
        .login-card .signup-link a { color: var(--accent); cursor: pointer; }
        .login-card .signup-link a:hover { text-decoration: underline; }
        .login-card .register-form { display: none; margin-top: 0.5rem; }
        .login-card .register-form.visible { display: block; }
        .header-row { display: flex; align-items: center; justify-content: space-between; flex-wrap: wrap; gap: 0.75rem; margin-bottom: 1rem; }
        .header-row { flex-wrap: wrap; }
        .header-row h1 { font-size: 1.5rem; font-weight: 700; margin: 0; letter-spacing: -0.02em; }
        .header-right { display: flex; align-items: center; gap: 1rem; flex-wrap: wrap; }
        .header-hamburger-wrap { position: relative; }
        .header-hamburger-btn { position: relative; width: 36px; height: 36px; padding: 0; display: flex; align-items: center; justify-content: center; font-size: 1.25rem; background: var(--surface-hover); border: 1px solid var(--border); border-radius: var(--radius-sm); color: var(--text-muted); cursor: pointer; }
        .header-hamburger-btn:hover { border-color: var(--accent); color: var(--accent); }
        .header-hamburger-btn .header-pending-badge { position: absolute; top: -2px; right: -2px; min-width: 16px; padding: 0.1rem 0.3rem; font-size: 0.65rem; line-height: 1; background: var(--danger); color: white; border-radius: 10px; white-space: nowrap; }
        .header-menu { position: absolute; top: 100%; right: 0; margin-top: 4px; min-width: 200px; background: var(--surface); border: 1px solid var(--border); border-radius: var(--radius-sm); box-shadow: var(--shadow); z-index: 100; padding: 0.5rem; }
        .header-menu.hidden { display: none !important; }
        .header-menu-user { font-size: 0.85rem; color: var(--text-muted); padding: 0.35rem 0.5rem; border-bottom: 1px solid var(--border); margin-bottom: 0.35rem; }
        .header-menu-user span { color: var(--accent); font-weight: 500; }
        .header-menu-item { display: block; width: 100%; padding: 0.5rem 0.6rem; text-align: left; font-size: 0.85rem; background: none; border: none; border-radius: var(--radius-sm); color: var(--text); cursor: pointer; }
        .header-menu-item:hover { background: var(--surface-hover); }
        .header-menu-item .pending-badge { margin-left: 0.35rem; padding: 0.1rem 0.35rem; font-size: 0.7rem; background: var(--danger); color: white; border-radius: 10px; }
        .superadmin-close-btn { position: absolute; top: 0.5rem; right: 0.5rem; width: 32px; height: 32px; padding: 0; display: flex; align-items: center; justify-content: center; font-size: 1.1rem; background: var(--surface-hover); border: 1px solid var(--border); border-radius: var(--radius-sm); color: var(--text-muted); cursor: pointer; }
        .superadmin-close-btn:hover { border-color: var(--accent); color: var(--accent); }
        .superadmin-tabs { display: flex; gap: 0.25rem; margin-bottom: 1rem; flex-wrap: wrap; }
        .superadmin-tab { padding: 0.4rem 0.75rem; border-radius: var(--radius-sm); font-size: 0.85rem; background: var(--surface-hover); border: 1px solid var(--border); color: var(--text-muted); cursor: pointer; display: inline-flex; align-items: center; gap: 0.35rem; }
        .superadmin-tab .tab-badge { padding: 0.1rem 0.35rem; font-size: 0.7rem; background: var(--danger); color: white; border-radius: 10px; }
        .superadmin-tab:hover { border-color: var(--accent); color: var(--accent); }
        .superadmin-tab.active { background: var(--accent); border-color: var(--accent); color: white; }
        .superadmin-panel { display: none; }
        .superadmin-panel.active { display: block; }
        .superadmin-section { margin-bottom: 1.5rem; }
        .superadmin-section-title { font-size: 0.75rem; font-weight: 600; text-transform: uppercase; letter-spacing: 0.06em; color: var(--text-muted); margin-bottom: 0.5rem; }
        .change-password-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.7); z-index: 200; display: flex; align-items: center; justify-content: center; }
        .change-password-overlay.hidden { display: none !important; }
        .change-password-modal { background: var(--surface); border: 1px solid var(--border); border-radius: var(--radius); padding: 1.5rem; min-width: 280px; max-width: 90vw; }
        .change-password-modal h3 { margin: 0 0 1rem; font-size: 1rem; }
        .change-password-modal label { display: block; font-size: 0.85rem; color: var(--text-muted); margin-bottom: 0.35rem; }
        .change-password-modal input { width: 100%; padding: 0.5rem; margin-bottom: 0.75rem; background: var(--surface-hover); border: 1px solid var(--border); border-radius: var(--radius-sm); color: var(--text); }
        .change-password-modal .btn { margin-right: 0.5rem; }
        .card {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            padding: 1.25rem 1.5rem;
            margin-bottom: 1rem;
            box-shadow: var(--shadow);
        }
        .card.admin-only { }
        .card-title { font-size: 0.75rem; font-weight: 600; text-transform: uppercase; letter-spacing: 0.06em; color: var(--text-muted); margin-bottom: 0.75rem; }
        .row { display: flex; align-items: center; gap: 0.75rem; flex-wrap: wrap; }
        select {
            flex: 1; min-width: 180px;
            padding: 0.6rem 0.75rem;
            background: var(--surface-hover);
            border: 1px solid var(--border);
            border-radius: var(--radius-sm);
            color: var(--text);
            font: inherit;
            cursor: pointer;
        }
        select:focus { outline: none; border-color: var(--accent); }
        .btn {
            padding: 0.6rem 1rem;
            border: none;
            border-radius: var(--radius-sm);
            font: inherit;
            font-weight: 500;
            cursor: pointer;
            transition: background 0.15s, transform 0.05s;
        }
        .btn:active { transform: scale(0.98); }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .btn-sm { padding: 0.25rem 0.5rem; font-size: 0.8rem; }
        .btn-primary { background: var(--accent); color: white; }
        .btn-primary:hover:not(:disabled) { background: var(--accent-hover); }
        .btn-danger { background: var(--danger); color: white; }
        .btn-danger:hover:not(:disabled) { background: var(--danger-hover); }
        .btn-ghost { background: var(--surface-hover); color: var(--text); }
        .btn-ghost:hover:not(:disabled) { background: var(--border); }
        .btn-icon { width: 40px; height: 40px; padding: 0; display: inline-flex; align-items: center; justify-content: center; border-radius: var(--radius-sm); }
        .btn-icon svg { width: 20px; height: 20px; }
        .player {
            background: linear-gradient(135deg, var(--surface) 0%, #1a1a20 100%);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            padding: 1rem 1.25rem;
            margin-bottom: 1rem;
        }
        .player-idle .player-controls { opacity: 0.6; }
        .player-now-playing { font-size: 0.9rem; font-weight: 500; margin-bottom: 0.5rem; color: var(--text-muted); }
        .player-now-playing strong { color: var(--text); }
        .waveform-wrap {
            height: 48px;
            background: rgba(0,0,0,0.2);
            border-radius: var(--radius-sm);
            margin-bottom: 0.5rem;
            overflow: hidden;
            position: relative;
        }
        .waveform-wrap canvas { display: block; width: 100%; height: 100%; cursor: pointer; }
        .waveform-placeholder {
            height: 48px;
            background: var(--border);
            border-radius: var(--radius-sm);
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-muted);
            font-size: 0.8rem;
        }
        .progress-time { font-size: 0.7rem; color: var(--text-muted); margin-bottom: 0.5rem; }
        .player-buttons { display: flex; align-items: center; gap: 0.5rem; }
        .player-recent-toggle { margin-left: auto; }
        .player-recent-toggle.expanded { transform: rotate(180deg); }
        .player-recent { margin-top: 0.75rem; padding-top: 0.75rem; border-top: 1px solid var(--border); }
        .player-recent.hidden { display: none !important; }
        .player-recent-title { font-size: 0.7rem; font-weight: 600; text-transform: uppercase; letter-spacing: 0.06em; color: var(--text-muted); margin-bottom: 0.5rem; }
        .player-recent-list { display: flex; flex-direction: column; gap: 0.35rem; }
        .player-recent-item { position: relative; padding: 0.4rem 0.5rem; font-size: 0.85rem; background: var(--surface-hover); border: 1px solid var(--border); border-radius: var(--radius-sm); color: var(--text); cursor: pointer; text-align: left; transition: border-color 0.15s, background 0.15s; overflow: hidden; min-height: 48px; }
        .player-recent-item:hover { border-color: var(--accent); background: var(--surface); }
        .player-recent-item .recent-waveform { position: absolute; inset: 0; width: 100%; height: 100%; opacity: 0.2; pointer-events: none; display: block; }
        .player-recent-item .recent-content { position: relative; z-index: 1; padding: 0.15rem 0; }
        .player-recent-item .recent-content > div:first-child { font-weight: 500; }
        .player-recent-item .recent-meta { font-size: 0.8rem; color: var(--text-muted); margin-top: 0.15rem; line-height: 1.3; }
        .volume-btn-wrap { display: flex; align-items: center; }
        .volume-btn { display: flex; align-items: center; gap: 0.35rem; padding: 0.4rem 0.6rem; font-size: 0.85rem; background: var(--surface-hover); border: 1px solid var(--border); border-radius: var(--radius-sm); color: var(--text); cursor: pointer; }
        .volume-btn:hover { border-color: var(--accent); color: var(--accent); }
        .volume-btn-icon { font-size: 1rem; }
        .volume-btn-pct { font-weight: 500; color: var(--text-muted); }
        .volume-menu { position: absolute; top: 100%; right: 0; margin-top: 4px; min-width: 200px; padding: 0.75rem; background: var(--surface); border: 1px solid var(--border); border-radius: var(--radius-sm); box-shadow: var(--shadow); z-index: 100; }
        .volume-menu.hidden { display: none !important; }
        .volume-menu-header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 0.5rem; font-size: 0.75rem; font-weight: 600; text-transform: uppercase; letter-spacing: 0.06em; color: var(--text-muted); }
        .volume-menu-close { background: none; border: none; color: var(--text-muted); cursor: pointer; padding: 0.2rem; font-size: 1rem; line-height: 1; }
        .volume-menu-close:hover { color: var(--text); }
        .volume-menu-row { display: flex; align-items: center; gap: 0.75rem; }
        .volume-menu-row input[type="range"] { flex: 1; min-width: 120px; accent-color: var(--accent); height: 6px; }
        .volume-label { font-size: 0.8rem; color: var(--text-muted); min-width: 2.5rem; }
        .volume-menu-check { display: flex; align-items: center; gap: 0.5rem; margin-top: 0.5rem; font-size: 0.85rem; color: var(--text-muted); cursor: pointer; }
        .volume-menu-check input { accent-color: var(--accent); }
        .volume-card-expanded .volume-card-header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 0.75rem; }
        .volume-card-expanded .volume-card-header .card-title { margin-bottom: 0; }
        .volume-expanded-check { display: flex; align-items: center; gap: 0.5rem; font-size: 0.85rem; color: var(--text-muted); cursor: pointer; }
        .volume-expanded-check input { accent-color: var(--accent); }
        .volume-card-row { display: flex; align-items: center; gap: 1rem; }
        .volume-card-row input[type="range"] { flex: 1; min-width: 120px; accent-color: var(--accent); height: 6px; }
        .sounds-header-actions { display: flex; align-items: center; gap: 0.5rem; }
        .upload-toggle-btn { height: 32px; padding: 0 0.75rem; font-size: 0.85rem; display: inline-flex; align-items: center; gap: 0.35rem; background: var(--accent); color: white; border: 1px solid var(--accent); border-radius: var(--radius-sm); font-weight: 500; box-sizing: border-box; }
        .upload-toggle-btn:hover { background: var(--accent-hover); border-color: var(--accent-hover); color: white; }
        .upload-btn-icon { display: inline-flex; align-items: center; }
        .upload-btn-icon svg { width: 1rem; height: 1rem; }
        .upload-card-header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 0.75rem; }
        .upload-card-header .card-title { margin-bottom: 0; }
        .upload-close-btn { padding: 0.25rem 0.4rem; font-size: 1rem; line-height: 1; color: var(--text-muted); }
        .upload-close-btn:hover { color: var(--text); }
        .sound-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)); gap: 0.75rem; margin-top: 0.25rem; }
        .sound-item { position: relative; display: flex; flex-direction: column; align-items: stretch; min-height: 100px; }
        .sound-btn {
            background: var(--surface-hover);
            border: 1px solid var(--border);
            border-radius: var(--radius-sm);
            padding: 0.6rem 0.5rem 0.4rem;
            color: var(--text);
            font: inherit;
            font-size: 0.85rem;
            font-weight: 500;
            cursor: pointer;
            transition: background 0.15s, border-color 0.15s;
            text-align: center;
            word-break: break-word;
            min-height: 100px;
            height: 100px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between;
        }
        .sound-btn-label { flex: 1; display: flex; align-items: center; justify-content: center; line-height: 1.2; }
        .sound-btn-duration { font-size: 0.7rem; color: var(--text-muted); flex-shrink: 0; }
        .sound-btn:hover:not(:disabled) { background: var(--border); border-color: var(--accent); }
        .sound-btn:active:not(:disabled) { transform: scale(0.98); }
        .sound-btn.disabled { opacity: 0.5; cursor: not-allowed; }
        .sound-item-actions { position: absolute; top: 4px; right: 4px; display: flex; gap: 4px; opacity: 0; pointer-events: none; transition: opacity 0.15s; }
        .sound-item:hover .sound-item-actions { opacity: 1; pointer-events: auto; }
        .sound-item.favorited .sound-item-actions { opacity: 1; pointer-events: auto; }
        .sound-preview, .sound-edit, .sound-fav {
            width: 24px; height: 24px; padding: 0;
            border: none; background: var(--surface);
            border-radius: 4px; color: var(--text-muted);
            cursor: pointer; display: flex; align-items: center; justify-content: center;
            transition: color 0.15s;
        }
        .sound-preview:hover, .sound-edit:hover, .sound-fav:hover { color: var(--accent); }
        .sound-preview.playing { color: var(--accent); }
        .sound-fav.active { color: var(--accent); }
        .sound-edit.hidden { display: none; }
        .sound-preview svg, .sound-edit svg, .sound-fav svg { width: 12px; height: 12px; }
        .sound-grid.reorder-mode .sound-preview, .sound-grid.reorder-mode .sound-fav { pointer-events: none; }
        .favorites-section { display: flex; flex-direction: column; align-items: center; gap: 0.4rem; margin-bottom: 0.6rem; }
        .favorites-label { font-size: 0.7rem; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.08em; }
        .favorites-bar { display: flex; flex-wrap: wrap; gap: 0.3rem; align-items: center; justify-content: center; max-width: 100%; }
        .favorites-bar .fav-slot {
            padding: 0.35rem 0.5rem; font-size: 0.78rem; min-width: 2rem;
            background: var(--surface-hover); border: 1px solid var(--border);
            border-radius: var(--radius-sm); color: var(--text); cursor: pointer;
            transition: border-color 0.15s, background 0.15s; display: inline-flex; align-items: center;
        }
        .favorites-bar .fav-slot:hover:not(.empty) { border-color: var(--accent); background: var(--surface); }
        .favorites-bar .fav-slot.empty { color: var(--text-muted); cursor: default; opacity: 0.7; }
        .favorites-bar .fav-slot .fav-num { font-weight: 600; margin-right: 0.25rem; color: var(--text-muted); }
        .favorites-bar .fav-slot:not(.empty) .fav-num { color: var(--accent); }
        .favorites-bar .fav-slot .fav-label { max-width: 7em; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .upload-zone { border: 2px dashed var(--border); border-radius: var(--radius-sm); padding: 1rem; text-align: center; color: var(--text-muted); font-size: 0.9rem; transition: border-color 0.15s, background 0.15s; }
        .upload-zone.drag-over { border-color: var(--accent); background: rgba(124, 58, 237, 0.1); }
        .upload-zone input[type="file"] { display: none; }
        .upload-zone label { cursor: pointer; display: block; }
        .upload-zone .browse { color: var(--accent); font-weight: 500; }
        .top-actions { display: flex; gap: 0.5rem; margin-bottom: 1rem; flex-wrap: wrap; align-items: center; }
        .top-actions.hidden { display: none; }
        .top-actions-right { margin-left: auto; }
        .sounds-card-header { display: flex; align-items: center; justify-content: space-between; flex-wrap: wrap; gap: 0.5rem; margin-bottom: 0.5rem; }
        .sounds-card-header .card-title { margin-bottom: 0; }
        .sounds-options-wrap { position: relative; }
        .hamburger-btn { width: 32px; height: 32px; padding: 0; display: flex; align-items: center; justify-content: center; font-size: 1.1rem; background: var(--surface-hover); border: 1px solid var(--border); border-radius: var(--radius-sm); color: var(--text-muted); cursor: pointer; }
        .hamburger-btn:hover { border-color: var(--accent); color: var(--accent); }
        .sounds-options-menu { position: absolute; top: 100%; right: 0; margin-top: 4px; min-width: 140px; background: var(--surface); border: 1px solid var(--border); border-radius: var(--radius-sm); box-shadow: var(--shadow); z-index: 50; padding: 0.25rem; }
        .sounds-options-menu.hidden { display: none !important; }
        .sounds-option-item { display: block; width: 100%; padding: 0.4rem 0.6rem; text-align: left; font-size: 0.85rem; background: none; border: none; border-radius: var(--radius-sm); color: var(--text); cursor: pointer; }
        .sounds-option-item:hover { background: var(--surface-hover); }
        .sounds-option-item.active { background: rgba(124, 58, 237, 0.2); color: var(--accent); }
        .sounds-option-item.active::before { content: '‚úì '; }
        .sound-grid.reorder-mode .sound-item { user-select: none; }
        .sound-item-wrap { display: contents; }
        .sound-grid.reorder-mode .sound-item-wrap { display: flex; flex-direction: column; cursor: grab; }
        .sound-grid.reorder-mode .sound-item-wrap:active { cursor: grabbing; }
        .sound-grid.reorder-mode .sound-item-wrap.dragging { opacity: 0.5; }
        .sound-grid.reorder-mode .sound-item-wrap.drag-over { outline: 2px solid var(--accent); outline-offset: 2px; border-radius: var(--radius-sm); }
        .sound-grid.reorder-mode .sound-btn { pointer-events: none; }
        .sound-grid.reorder-mode .sound-edit { pointer-events: none; }
        .sound-grid.reorder-mode .sound-item-actions { pointer-events: none; }
        .sound-grid.compact-mode { grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); gap: 0.5rem; }
        .sound-grid.compact-mode .sound-item { min-height: 72px; }
        .sound-grid.compact-mode .sound-btn { min-height: 72px; height: 72px; padding: 0.4rem 0.35rem 0.3rem; font-size: 0.78rem; }
        .sound-grid.compact-mode .sound-btn-duration { font-size: 0.65rem; }
        .sound-grid.compact-mode .sound-item-actions { top: 2px; right: 2px; }
        .sound-grid.compact-mode .sound-preview, .sound-grid.compact-mode .sound-edit, .sound-grid.compact-mode .sound-fav { width: 20px; height: 20px; }
        .sound-grid.compact-mode .sound-preview svg, .sound-grid.compact-mode .sound-edit svg, .sound-grid.compact-mode .sound-fav svg { width: 10px; height: 10px; }
        .sounds-card.mobile-active .sound-filter-wrap { display: none !important; }
        .sounds-card.mobile-active .sound-grid,
        .sounds-card.mobile-active .tags-admin,
        .sounds-card.mobile-active .favorites-section { display: none !important; }
        .sounds-card.mobile-active .mobile-grid-wrap { display: flex; }
        .sounds-card.mobile-active .sounds-options-wrap { display: block; }
        /* Mobile view: fullscreen soundboard section */
        .sounds-card.mobile-active {
            position: fixed; inset: 0; z-index: 50; margin: 0; border-radius: 0;
            display: flex; flex-direction: column; max-width: none;
            background: var(--bg); overflow: hidden;
        }
        .sounds-card.mobile-active .sounds-card-header { flex-shrink: 0; padding: 0.75rem 1rem; }
        .sounds-card.mobile-active .sounds-toolbar { margin: 0 1rem 0.5rem; flex-shrink: 0; justify-content: center; }
        .sounds-card.mobile-active .sounds-toolbar .tag-tabs { flex: 1; justify-content: center; min-width: 100%; }
        .mobile-grid-wrap { display: none; flex: 1; flex-direction: column; min-height: 0; overflow: hidden; }
        .mobile-grid-area {
            flex: 1; min-height: 0; padding: 0 1rem 1rem;
            display: grid; gap: 0.5rem;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
        }
        @media (min-width: 380px) {
            .mobile-grid-area { grid-template-columns: repeat(4, 1fr); }
        }
        @media (min-height: 480px) {
            .mobile-grid-area { grid-template-rows: repeat(4, 1fr); }
        }
        .mobile-grid-area.paged { overflow: hidden; }
        .mobile-grid-btn {
            aspect-ratio: 1; min-width: 0; min-height: 0; max-width: 160px; max-height: 160px;
            padding: 0.5rem; width: 100%; height: 100%;
            background: var(--surface-hover); border: 2px solid var(--border);
            border-radius: var(--radius-sm); font-size: 0.85rem; font-weight: 600;
            color: var(--text); cursor: pointer; display: flex; flex-direction: column;
            align-items: center; justify-content: center; gap: 0.15rem;
            transition: background 0.15s, border-color 0.15s, transform 0.2s;
            word-break: break-word; text-align: center; overflow: hidden;
        }
        .mobile-grid-area.paged .mobile-grid-btn { max-width: none; max-height: none; }
        .mobile-grid-btn:hover:not(:disabled) { background: var(--border); border-color: var(--accent); }
        .mobile-grid-btn:active:not(:disabled) { transform: scale(0.98); }
        .mobile-grid-btn.disabled { opacity: 0.5; cursor: not-allowed; }
        .mobile-grid-btn .duration { font-size: 0.7rem; font-weight: 400; color: var(--text-muted); }
        .mobile-grid-btn { position: relative; }
        .mobile-grid-color { position: absolute; top: 0; left: 0; right: 0; height: 4px; border-radius: var(--radius-sm) var(--radius-sm) 0 0; }
        .mobile-grid-nav { display: none; flex-shrink: 0; align-items: center; justify-content: center; gap: 1rem; padding: 0.5rem 1rem; }
        .mobile-grid-wrap.paged .mobile-grid-nav { display: flex !important; }
        .mobile-grid-nav button { width: 44px; height: 44px; border-radius: 50%; border: 1px solid var(--border); background: var(--surface-hover); color: var(--text); font-size: 1.2rem; cursor: pointer; }
        .mobile-grid-nav button:hover:not(:disabled) { border-color: var(--accent); color: var(--accent); }
        .mobile-grid-nav button:disabled { opacity: 0.4; cursor: not-allowed; }
        .mobile-grid-page { font-size: 0.8rem; color: var(--text-muted); min-width: 4rem; text-align: center; }
        .settings-row { align-items: center; gap: 0.5rem; }
        .settings-row label { display: flex; align-items: center; gap: 0.5rem; cursor: pointer; font-size: 0.9rem; }
        .settings-row input[type="checkbox"] { width: 1.1rem; height: 1.1rem; accent-color: var(--accent); }
        .user-locked-msg { color: var(--text-muted); font-size: 0.9rem; margin-top: 0.5rem; }
        .tag-tabs, .folder-tabs { display: flex; flex-wrap: wrap; gap: 0.3rem; align-items: center; }
        .tag-tab, .folder-tab { padding: 0.3rem 0.55rem; border-radius: var(--radius-sm); font-size: 0.8rem; background: var(--surface-hover); border: 1px solid var(--border); color: var(--text); cursor: pointer; }
        .tag-tab:hover, .folder-tab:hover { border-color: var(--accent); }
        .tag-tab.active, .folder-tab.active { background: var(--accent); border-color: var(--accent); color: white; }
        .tag-tab.delete, .folder-tab.delete { padding: 0.2rem 0.4rem; font-size: 0.75rem; color: var(--text-muted); }
        .tag-tab.delete:hover, .folder-tab.delete:hover { color: var(--danger); }
        .tag-tab.hidden-tag { opacity: 0.6; }
        .tag-tab-wrap, .folder-tab-wrap { display: inline-flex; align-items: center; gap: 0.15rem; }
        .tag-tabs.manage-mode .tag-tab-wrap, .folder-tabs.manage-mode .folder-tab-wrap { cursor: grab; }
        .tag-tabs.manage-mode .tag-tab-wrap:active, .folder-tabs.manage-mode .folder-tab-wrap:active { cursor: grabbing; }
        .tag-tabs.manage-mode .tag-tab-wrap.dragging, .folder-tabs.manage-mode .folder-tab-wrap.dragging { opacity: 0.5; }
        .tag-tabs.manage-mode .tag-tab-wrap.drag-over, .folder-tabs.manage-mode .folder-tab-wrap.drag-over { outline: 2px solid var(--accent); outline-offset: 2px; border-radius: var(--radius-sm); }
        .tag-tab-rename, .folder-tab-rename { width: 6rem; padding: 0.2rem 0.4rem; font-size: 0.85rem; background: var(--surface); border: 1px solid var(--accent); border-radius: var(--radius-sm); color: var(--text); }
        .tags-admin, .folders-admin { margin-bottom: 0.75rem; }
        .tags-admin .row, .folders-admin .row { gap: 0.35rem; }
        .tags-input-wrap { flex: 1; min-width: 0; position: relative; }
        .tags-input { width: 100%; min-width: 0; padding: 0.4rem 0.5rem; background: var(--surface-hover); border: 1px solid var(--border); border-radius: var(--radius-sm); color: var(--text); font-size: 0.9rem; }
        .tags-input:focus { outline: none; border-color: var(--accent); }
        .tags-suggestions { position: absolute; top: 100%; left: 0; right: 0; margin-top: 2px; max-height: 160px; overflow-y: auto; background: var(--surface); border: 1px solid var(--border); border-radius: var(--radius-sm); box-shadow: var(--shadow); z-index: 100; }
        .tags-suggestions .tag-suggestion { padding: 0.4rem 0.6rem; cursor: pointer; font-size: 0.9rem; }
        .tags-suggestions .tag-suggestion:hover, .tags-suggestions .tag-suggestion.selected { background: var(--surface-hover); }
        .sounds-toolbar { display: flex; flex-wrap: wrap; align-items: center; gap: 0.5rem 0.75rem; margin-bottom: 0.5rem; }
        .sounds-toolbar .sound-filter-wrap { position: relative; flex: 0 1 200px; min-width: 120px; max-width: 240px; }
        .sounds-toolbar .sound-filter-input { width: 100%; box-sizing: border-box; padding: 0.4rem 1.75rem 0.4rem 0.55rem; background: var(--surface-hover); border: 1px solid var(--border); border-radius: var(--radius-sm); color: var(--text); font-size: 0.85rem; }
        .sounds-toolbar .sound-filter-input::placeholder { color: var(--text-muted); }
        .sounds-toolbar .sound-filter-input:focus { outline: none; border-color: var(--accent); }
        .sounds-toolbar .sound-filter-clear { position: absolute; right: 0.35rem; top: 50%; transform: translateY(-50%); width: 1.25rem; height: 1.25rem; padding: 0; border: none; background: transparent; color: var(--text-muted); cursor: pointer; font-size: 1rem; line-height: 1; display: none; align-items: center; justify-content: center; border-radius: var(--radius-sm); }
        .sounds-toolbar .sound-filter-clear:hover { color: var(--text); background: var(--surface-hover); }
        .sounds-toolbar .sound-filter-clear.visible { display: flex; }
        .sounds-toolbar .tag-tabs { flex: 1; min-width: 0; margin: 0; }
        .top-bar-toggles-stack { display: flex; flex-direction: column; gap: 0.2rem; align-items: stretch; margin-left: 0.5rem; }
        .top-bar-toggles-stack .top-bar-toggle { margin-left: 0; display: grid; grid-template-columns: 1fr auto; gap: 0.5rem; align-items: center; }
        .top-bar-toggle { display: inline-flex; align-items: center; gap: 0.5rem; margin-left: 0.5rem; font-size: 0.85rem; color: var(--text-muted); cursor: pointer; }
        .toggle-switch { position: relative; display: inline-block; width: 36px; height: 20px; }
        .toggle-switch input { position: absolute; opacity: 0; width: 100%; height: 100%; margin: 0; cursor: pointer; z-index: 1; }
        .toggle-slider { position: absolute; pointer-events: none; inset: 0; background: var(--surface-hover); border: 1px solid var(--border); border-radius: 20px; transition: 0.2s; }
        .toggle-slider::before { content: ''; position: absolute; height: 14px; width: 14px; left: 2px; bottom: 2px; background: var(--text-muted); border-radius: 50%; transition: 0.2s; }
        .toggle-switch input:checked + .toggle-slider { background: var(--accent); border-color: var(--accent); }
        .toggle-switch input:checked + .toggle-slider::before { transform: translateX(16px); background: white; }
        .top-bar-voice { display: inline-flex; align-items: center; gap: 0.5rem; margin-left: 0.5rem; }
        .top-bar-voice .voice-channel-info { font-size: 0.85rem; color: var(--text-muted); max-width: 180px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .top-bar-voice .btn-sm { padding: 0.25rem 0.5rem; font-size: 0.8rem; }
        .sound-panel { margin-top: 1rem; padding: 1rem; background: var(--surface-hover); border-radius: var(--radius-sm); border: 1px solid var(--border); }
        .sound-panel .row { margin-bottom: 0.5rem; }
        .sound-panel label { font-size: 0.85rem; color: var(--text-muted); min-width: 5rem; }
        .sound-panel input, .sound-panel select { flex: 1; padding: 0.4rem 0.5rem; background: var(--surface); border: 1px solid var(--border); border-radius: var(--radius-sm); color: var(--text); font-size: 0.9rem; }
        .sound-color-picker { display: flex; flex-wrap: wrap; align-items: center; gap: 0.5rem; flex: 1; }
        .sound-color-presets { display: flex; flex-wrap: wrap; gap: 0.35rem; }
        .sound-color-preset { width: 24px; height: 24px; padding: 0; border: 2px solid transparent; border-radius: 50%; cursor: pointer; transition: border-color 0.15s, transform 0.1s; }
        .sound-color-preset:hover { transform: scale(1.1); }
        .sound-color-preset.selected { border-color: var(--text); box-shadow: 0 0 0 1px var(--surface); }
        .sound-color-custom { display: flex; align-items: center; gap: 0.35rem; font-size: 0.85rem; color: var(--text-muted); cursor: pointer; }
        .sound-color-input-wrap { width: 24px; height: 24px; border-radius: 50%; overflow: hidden; display: inline-block; border: 1px solid var(--border); flex-shrink: 0; position: relative; }
        .sound-color-input-wrap input[type="color"] { width: 24px; height: 24px; padding: 0; border: none; cursor: pointer; background: transparent; display: block; transform: scale(2.5); transform-origin: center center; }
        .sound-color-dot { position: absolute; top: 6px; left: 6px; width: 10px; height: 10px; border-radius: 50%; border: 1px solid rgba(0,0,0,0.2); box-shadow: 0 0 0 1px rgba(255,255,255,0.3); pointer-events: none; }
        .sound-panel-waveform-wrap { position: relative; width: 100%; height: 80px; background: var(--surface); border: 1px solid var(--border); border-radius: var(--radius-sm); margin: 0.5rem 0; overflow: hidden; }
        .sound-panel-waveform-wrap canvas { display: block; width: 100%; height: 100%; cursor: default; }
        .sound-panel-waveform-handle { position: absolute; top: 0; bottom: 0; width: 10px; background: var(--accent); opacity: 0.8; cursor: ew-resize; z-index: 2; }
        .sound-panel-waveform-handle:hover { opacity: 1; }
        .sound-panel-waveform-handle.start { left: 0; }
        .sound-panel-waveform-handle.end { right: 0; }
        .sound-panel-preview-row { display: flex; align-items: center; gap: 0.5rem; flex-wrap: wrap; margin-top: 0.5rem; }
        .sound-panel-volume-row { display: flex; align-items: center; gap: 0.5rem; }
        .sound-panel-volume-row input[type="range"] { flex: 1; min-width: 100px; }
        .sound-drag-handle { display: none; position: absolute; left: 4px; top: 50%; transform: translateY(-50%); width: 20px; color: var(--text-muted); font-size: 0.9rem; user-select: none; }
        .sound-grid.reorder-mode .sound-drag-handle { display: block; }
        .sound-item-selected { outline: 2px solid var(--accent); outline-offset: 2px; }
        .superadmin-only { }
        .guest-history-table td { padding: 0.35rem 0.5rem; border-bottom: 1px solid var(--border); }
        .guest-history-table .block-btn { padding: 0.2rem 0.5rem; font-size: 0.75rem; }
        .blocked-ips-list .ip-row { display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.35rem; }
    </style>
</head>
<body>
    <script>
        (function(){try{var p=localStorage.getItem('soundboard-prefs');var t=p?JSON.parse(p).theme:null;document.documentElement.setAttribute('data-theme',t==='light'?'light':'dark');}catch(e){}})();
    </script>
    <div class="login-screen" id="loginScreen">
        <div class="login-card">
            <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:1.5rem">
                <h1 style="margin:0">üîä Soundboard</h1>
                <button type="button" class="theme-toggle-login" id="themeToggleLogin" title="Toggle light/dark theme" aria-label="Toggle theme" onclick="toggleTheme()">üåô</button>
            </div>
            <form id="loginForm" onsubmit="return doLogin(event)">
                <label for="loginUser">Username</label>
                <input type="text" id="loginUser" name="username" placeholder="Username" autocomplete="username" required>
                <label for="loginPass">Password</label>
                <input type="password" id="loginPass" name="password" placeholder="Password" autocomplete="current-password" required>
                <button type="submit" class="btn btn-primary">Log in</button>
                <div class="login-error" id="loginError"></div>
                <div class="guest-divider" id="guestDivider" style="display:none; margin: 1rem 0; text-align: center; color: var(--text-muted); font-size: 0.85rem;">‚Äî or ‚Äî</div>
                <button type="button" class="btn btn-ghost" id="guestBtn" style="display:none; width:100%;" onclick="doGuestLogin()">Continue as guest</button>
                <div class="signup-link"><a id="showSignupLink" onclick="showRegisterForm()">Sign up</a></div>
            </form>
            <div class="register-form" id="registerForm">
                <h2 style="font-size: 1.1rem; margin: 0 0 1rem;">Create account</h2>
                <form id="registerFormEl" onsubmit="return doRegister(event)">
                    <label for="regUser">Username</label>
                    <input type="text" id="regUser" placeholder="2‚Äì32 chars, letters, numbers, _ -" autocomplete="username" required>
                    <label for="regPass">Password</label>
                    <input type="password" id="regPass" placeholder="At least 6 characters" autocomplete="new-password" required>
                    <label for="regPassConfirm">Confirm password</label>
                    <input type="password" id="regPassConfirm" placeholder="Repeat password" autocomplete="new-password" required>
                    <button type="submit" class="btn btn-primary">Sign up</button>
                    <div class="login-error" id="registerError"></div>
                </form>
                <div class="signup-link" style="margin-top: 0.5rem;"><a onclick="showLoginForm()">Back to login</a></div>
            </div>
        </div>
    </div>

    <div class="app hidden" id="app">
        <div class="header-row">
            <h1>üîä Soundboard</h1>
            <div class="header-right header-hamburger-wrap">
                <button type="button" class="header-hamburger-btn" id="headerHamburgerBtn" onclick="toggleHeaderMenu()" title="Menu" aria-label="Menu">
                    <span style="line-height:1">‚ò∞</span>
                    <span class="header-pending-badge hidden" id="headerPendingBadge"></span>
                </button>
                <div class="header-menu hidden" id="headerMenu">
                    <div class="header-menu-user">Logged in as <span id="currentUsername">‚Äî</span> <span id="currentRole">(admin)</span></div>
                    <button type="button" class="header-menu-item" id="headerMenuTheme" onclick="toggleTheme(); updateHeaderMenuThemeLabel();">Theme: <span id="headerMenuThemeLabel">Dark</span></button>
                    <button type="button" class="header-menu-item user-only hidden" id="headerMenuChangePassword" onclick="openChangePasswordModal(); closeHeaderMenu();">Change password</button>
                    <button type="button" class="header-menu-item" onclick="logout(); closeHeaderMenu();">Log out</button>
                    <button type="button" class="header-menu-item superadmin-only hidden" id="headerMenuSuperadmin" onclick="switchMainTab('superadmin'); closeHeaderMenu();">Superadmin<span class="pending-badge hidden" id="pendingBadge">0</span></button>
                </div>
            </div>
        </div>

        <div id="soundsView" class="main-view">
        <div class="top-actions" id="topActions">
            <button type="button" class="btn btn-danger" id="stopAllBtn" onclick="stopPlayback()" title="Stop playback">‚èπ Stop</button>
            <div class="top-bar-toggles-stack">
                <label class="top-bar-toggle admin-only" title="When on, only admins can play sounds; users and guests are blocked">
                    <span class="top-bar-toggle-label">Only admins can play</span>
                    <span class="toggle-switch"><input type="checkbox" id="playbackLockedTop" onchange="setPlaybackLocked(this.checked)"><span class="toggle-slider"></span></span>
                </label>
                <label class="top-bar-toggle superadmin-only hidden" title="When on, only superadmin can play; admins, users and guests are blocked">
                    <span class="top-bar-toggle-label">Only superadmin can play</span>
                    <span class="toggle-switch"><input type="checkbox" id="playbackSuperadminOnlyTop" onchange="setPlaybackSuperadminOnly(this.checked)"><span class="toggle-slider"></span></span>
                </label>
            </div>
            <div class="top-bar-voice admin-only hidden" id="voiceConnectedBar">
                <span class="voice-channel-info" id="voiceChannelInfo" title="">üì¢ <span id="voiceChannelName">‚Äî</span></span>
                <button type="button" class="btn btn-danger btn-sm" onclick="leaveChannel()">Leave</button>
            </div>
            <div class="volume-btn-wrap admin-only top-actions-right" style="position:relative">
                <button type="button" class="volume-btn" id="volumeBtn" onclick="toggleVolumeMenu()" title="Volume">
                    <span class="volume-btn-icon">üîä</span>
                    <span class="volume-btn-pct" id="volumeBtnPct">50%</span>
                </button>
                <div class="volume-menu hidden" id="volumeMenu">
                    <div class="volume-menu-header">
                        <span>Volume</span>
                        <button type="button" class="volume-menu-close" onclick="closeVolumeMenu()" title="Close">‚úï</button>
                    </div>
                    <div class="volume-menu-row">
                        <span class="volume-label" id="volumeLabel">50%</span>
                        <input type="range" id="volumeSlider" min="0" max="1" step="0.02" value="0.5" title="Volume">
                    </div>
                    <label class="volume-menu-check">
                        <input type="checkbox" id="volumeExpandedCheck" onchange="setVolumeExpanded(this.checked)">
                        <span>Always show volume</span>
                    </label>
                </div>
            </div>
        </div>

        <div class="card admin-only" id="connectionCard">
            <div class="card-title">Connection</div>
            <div class="row connection-row">
                <select id="channelSelect"><option>Loading channels...</option></select>
                <button type="button" class="btn btn-primary" onclick="joinChannel()">Join Channel</button>
            </div>
        </div>

        <div class="player" id="playerCard">
            <div class="card-title">Now Playing</div>
            <div class="player-now-playing" id="nowPlayingText">Nothing playing</div>
            <div class="waveform-placeholder" id="waveformPlaceholder">Waveform will appear when a sound is playing</div>
            <div class="waveform-wrap" id="waveformWrap" style="display: none;">
                <canvas id="waveformCanvas" width="600" height="48"></canvas>
            </div>
            <div class="progress-time" id="progressTime">0:00 / 0:00</div>
            <div class="player-buttons">
                <button type="button" class="btn btn-ghost btn-icon" id="playPauseBtn" onclick="togglePlayPause()" title="Play / Pause" disabled>‚ñ∂</button>
                <button type="button" class="btn btn-ghost btn-icon" id="stopBtn" onclick="stopPlayback()" title="Stop">‚èπ</button>
                <button type="button" class="btn btn-ghost btn-icon player-recent-toggle" id="recentToggleBtn" onclick="toggleRecentPlayed()" title="Recently played">‚ñº</button>
            </div>
            <div class="player-recent hidden" id="playerRecent">
                <div class="player-recent-title">Recently played</div>
                <div class="player-recent-list" id="playerRecentList"></div>
            </div>
        </div>

        <div class="card admin-only volume-card-expanded hidden" id="volumeCard">
            <div class="volume-card-header">
                <span class="card-title">Volume</span>
                <label class="volume-expanded-check">
                    <input type="checkbox" id="volumeExpandedCheckCard" onchange="setVolumeExpanded(this.checked)">
                    <span>Always show volume</span>
                </label>
            </div>
            <div class="volume-card-row">
                <span class="volume-label" id="volumeLabelCard">50%</span>
                <input type="range" id="volumeSliderCard" min="0" max="1" step="0.02" value="0.5" title="Volume">
            </div>
        </div>

        <div class="card upload-card-collapsible hidden" id="uploadCard">
            <div class="upload-card-header">
                <span class="card-title">Upload Sound</span>
                <button type="button" class="btn btn-ghost upload-close-btn" onclick="hideUploadSection()" title="Close">‚úï</button>
            </div>
            <div class="upload-zone" id="uploadZone">
                <label for="fileInput"><span class="browse">Browse</span> or drag a file ‚Äî MP3, WAV, OGG</label>
                <input type="file" id="fileInput" accept="audio/*">
            </div>
            <div class="upload-hint" id="uploadHint" style="font-size: 0.8rem; color: var(--text-muted); margin-top: 0.5rem;"></div>
        </div>

        <div class="card sounds-card">
            <div class="sounds-card-header">
                <span class="card-title">Sounds</span>
                <div class="sounds-header-actions">
                    <button type="button" class="btn upload-toggle-btn hidden" id="uploadToggleBtn" onclick="toggleUploadSection()" title="Upload sound"><span class="upload-btn-icon"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></svg></span> Upload</button>
                    <div class="sounds-options-wrap">
                    <button type="button" class="hamburger-btn" id="soundsOptionsBtn" onclick="toggleSoundsOptionsMenu()" title="View options">‚ò∞</button>
                    <div class="sounds-options-menu hidden" id="soundsOptionsMenu">
                        <button type="button" class="sounds-option-item" id="mobileBtn" onclick="toggleMobileView(); closeSoundsOptionsMenu();" title="Mobile view: fullscreen soundboard">Mobile</button>
                        <button type="button" class="sounds-option-item" id="compactBtn" onclick="toggleCompact(); closeSoundsOptionsMenu();" title="Compact view: smaller buttons">Compact</button>
                        <button type="button" class="sounds-option-item admin-only" id="reorderBtn" onclick="toggleReorder(); closeSoundsOptionsMenu();" title="Drag to reorder sounds">Reorder</button>
                        <button type="button" class="sounds-option-item admin-only" id="manageTagsBtn" onclick="toggleManageTags(); closeSoundsOptionsMenu();" title="Manage tags: reorder, delete, hide">Manage tags</button>
                    </div>
                </div>
                </div>
            </div>
            <div class="tags-admin admin-only hidden" id="tagsAdmin">
                <p style="font-size: 0.85rem; color: var(--text-muted); margin-bottom: 0.5rem;">Drag to reorder. Click ‚úï to delete, üëÅ to hide (hidden tags don't show as buttons but remain searchable).</p>
            </div>
            <div class="sounds-toolbar">
                <div class="sound-filter-wrap">
                    <input type="text" id="soundFilterInput" placeholder="Filter by name or tag..." class="sound-filter-input" autocomplete="off">
                    <button type="button" class="sound-filter-clear" id="soundFilterClear" title="Clear filter" onclick="clearSoundFilter()">√ó</button>
                </div>
                <div class="tag-tabs" id="tagTabs"></div>
            </div>
            <div class="favorites-section">
                <span class="favorites-label">Quick play</span>
                <div class="favorites-bar" id="favoritesBar"></div>
            </div>
            <div class="mobile-grid-wrap" id="mobileGridWrap">
                <div class="mobile-grid-area" id="mobileGridArea"></div>
                <div class="mobile-grid-nav" id="mobileGridNav">
                    <button type="button" id="mobilePrevBtn" onclick="mobilePagePrev()" title="Previous page">‚Äπ</button>
                    <span class="mobile-grid-page" id="mobileGridPage">‚Äî</span>
                    <button type="button" id="mobileNextBtn" onclick="mobilePageNext()" title="Next page">‚Ä∫</button>
                </div>
            </div>
            <div id="soundsList" class="sound-grid"></div>
            <div class="sound-panel hidden" id="soundPanel">
                <div class="card-title">Edit sound</div>
                <div class="row"><label>Name</label><input type="text" id="soundPanelName" placeholder="Display name"></div>
                <div class="row"><label>Tags</label><div class="tags-input-wrap"><input type="text" id="soundPanelTags" placeholder="Add tags (comma or space separated)" class="tags-input" autocomplete="off"><div id="soundPanelTagsSuggestions" class="tags-suggestions hidden"></div></div></div>
                <div class="row"><label>Duration</label><span id="soundPanelDuration" class="text-muted">‚Äî</span></div>
                <div class="row">
                    <label>Volume</label>
                    <div class="sound-panel-volume-row" style="flex:1;">
                        <input type="range" id="soundPanelVolume" min="0" max="2" step="0.05" value="1" title="Per-sound volume (100% = normal, up to 200% to boost)">
                        <span id="soundPanelVolumeLabel" style="min-width:3rem;font-size:0.85rem;">100%</span>
                    </div>
                </div>
                <div class="row">
                    <label>Trim</label>
                    <div style="flex:1;">
                        <div class="sound-panel-waveform-wrap" id="soundPanelWaveformWrap">
                            <canvas id="soundPanelWaveform" width="400" height="80"></canvas>
                            <div class="sound-panel-waveform-handle start" id="soundPanelHandleStart" title="Drag to set start"></div>
                            <div class="sound-panel-waveform-handle end" id="soundPanelHandleEnd" title="Drag to set end"></div>
                        </div>
                        <div class="sound-panel-preview-row">
                            <span id="soundPanelTrimLabel" class="text-muted" style="font-size:0.85rem;">Start: 0:00 ‚Äî End: full</span>
                            <button type="button" class="btn btn-ghost btn-sm" id="soundPanelPreviewBtn" onclick="soundPanelPreview()">‚ñ∂ Preview</button>
                            <button type="button" class="btn btn-ghost btn-sm" onclick="soundPanelResetTrim()">Reset trim</button>
                        </div>
                    </div>
                </div>
                <div class="row">
                    <label>Color</label>
                    <div class="sound-color-picker">
                        <div class="sound-color-presets" id="soundPanelColorPresets"></div>
                        <label class="sound-color-custom">
                            <span>Custom</span>
                            <span class="sound-color-input-wrap">
                                <input type="color" id="soundPanelColorCustom" value="#7c3aed" title="Custom color" onchange="selectSoundPanelColor(this.value)">
                            </span>
                        </label>
                        <button type="button" class="btn btn-ghost btn-sm" id="soundPanelColorClear" onclick="clearSoundPanelColor()">Clear</button>
                    </div>
                </div>
                <div class="row" style="margin-top: 0.5rem;">
                    <button type="button" class="btn btn-primary" onclick="saveSoundPanel()">Save</button>
                    <button type="button" class="btn btn-ghost" onclick="closeSoundPanel()">Close</button>
                </div>
            </div>
            <div class="user-locked-msg hidden" id="userLockedMsg">Playback is locked by an admin.</div>
        </div>
        </div>

        <div id="superadminView" class="main-view hidden">
        <div class="card" id="superadminCard" style="position:relative">
            <div class="card-title" style="display:flex;align-items:center;justify-content:space-between;margin-bottom:1rem">
                <span>Superadmin</span>
                <button type="button" class="superadmin-close-btn" onclick="switchMainTab('sounds')" title="Back to soundboard">‚úï</button>
            </div>
            <div class="superadmin-tabs">
                <button type="button" class="superadmin-tab active" data-panel="access" onclick="switchSuperadminTab('access')">Access & Limits</button>
                <button type="button" class="superadmin-tab" data-panel="guests" onclick="switchSuperadminTab('guests')">Guests</button>
                <button type="button" class="superadmin-tab" data-panel="users" onclick="switchSuperadminTab('users')">Users<span class="tab-badge hidden" id="superadminTabUsersBadge">0</span></button>
                <button type="button" class="superadmin-tab" data-panel="moderation" onclick="switchSuperadminTab('moderation')">Moderation<span class="tab-badge hidden" id="superadminTabModerationBadge">0</span></button>
            </div>

            <div id="superadminPanelAccess" class="superadmin-panel active">
                <div class="superadmin-section">
                    <div class="superadmin-section-title">Guest Access</div>
                    <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer;">
                        <input type="checkbox" id="guestEnabledToggle" onchange="setGuestEnabled(this.checked)">
                        <span>Allow guest access (no login)</span>
                    </label>
                </div>
                <div class="superadmin-section">
                    <div class="superadmin-section-title">Guest Playback</div>
                    <div class="row" style="gap: 1rem;">
                        <label style="display: flex; align-items: center; gap: 0.5rem; font-size: 0.9rem;">
                            <span>Max duration (s):</span>
                            <input type="number" id="guestMaxDurationInput" min="1" max="60" value="7" style="width: 4rem; padding: 0.35rem; background: var(--surface-hover); border: 1px solid var(--border); border-radius: var(--radius-sm); color: var(--text);" onchange="setGuestMaxDuration(this.value)">
                        </label>
                        <label style="display: flex; align-items: center; gap: 0.5rem; font-size: 0.9rem;">
                            <span>Cooldown (s):</span>
                            <input type="number" id="guestCooldownInput" min="0" max="300" value="10" style="width: 4rem; padding: 0.35rem; background: var(--surface-hover); border: 1px solid var(--border); border-radius: var(--radius-sm); color: var(--text);" onchange="setGuestCooldown(this.value)">
                        </label>
                    </div>
                </div>
                <div class="superadmin-section">
                    <div class="superadmin-section-title">Guest Uploads</div>
                    <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; margin-bottom: 0.5rem;">
                        <input type="checkbox" id="guestUploadEnabledToggle" onchange="setGuestUploadEnabled(this.checked)">
                        <span>Allow guests to upload</span>
                    </label>
                    <div class="row" style="gap: 1rem;">
                        <label style="display: flex; align-items: center; gap: 0.5rem; font-size: 0.9rem;">
                            <span>Max duration (s):</span>
                            <input type="number" id="guestMaxUploadDurationInput" min="1" max="60" value="7" style="width: 4rem; padding: 0.35rem; background: var(--surface-hover); border: 1px solid var(--border); border-radius: var(--radius-sm); color: var(--text);" onchange="setGuestMaxUploadDuration(this.value)">
                        </label>
                        <label style="display: flex; align-items: center; gap: 0.5rem; font-size: 0.9rem;">
                            <span>Max size (KB):</span>
                            <input type="number" id="guestMaxUploadBytesInput" min="100" max="10240" value="2048" style="width: 5rem; padding: 0.35rem; background: var(--surface-hover); border: 1px solid var(--border); border-radius: var(--radius-sm); color: var(--text);" onchange="setGuestMaxUploadBytes(this.value)">
                        </label>
                    </div>
                </div>
                <div class="superadmin-section">
                    <div class="superadmin-section-title">User Playback</div>
                    <div class="row" style="gap: 1rem;">
                        <label style="display: flex; align-items: center; gap: 0.5rem; font-size: 0.9rem;">
                            <span>Max duration (s):</span>
                            <input type="number" id="userMaxDurationInput" min="1" max="60" value="7" style="width: 4rem; padding: 0.35rem; background: var(--surface-hover); border: 1px solid var(--border); border-radius: var(--radius-sm); color: var(--text);" onchange="setUserMaxDuration(this.value)">
                        </label>
                        <label style="display: flex; align-items: center; gap: 0.5rem; font-size: 0.9rem;">
                            <span>Cooldown (s):</span>
                            <input type="number" id="userCooldownInput" min="0" max="300" value="0" style="width: 4rem; padding: 0.35rem; background: var(--surface-hover); border: 1px solid var(--border); border-radius: var(--radius-sm); color: var(--text);" onchange="setUserCooldown(this.value)">
                        </label>
                    </div>
                </div>
                <div class="superadmin-section">
                    <div class="superadmin-section-title">User Uploads</div>
                    <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; margin-bottom: 0.5rem;">
                        <input type="checkbox" id="userUploadEnabledToggle" onchange="setUserUploadEnabled(this.checked)">
                        <span>Allow users to upload</span>
                    </label>
                    <div class="row" style="gap: 1rem;">
                        <label style="display: flex; align-items: center; gap: 0.5rem; font-size: 0.9rem;">
                            <span>Max duration (s):</span>
                            <input type="number" id="userMaxUploadDurationInput" min="1" max="60" value="7" style="width: 4rem; padding: 0.35rem; background: var(--surface-hover); border: 1px solid var(--border); border-radius: var(--radius-sm); color: var(--text);" onchange="setUserMaxUploadDuration(this.value)">
                        </label>
                        <label style="display: flex; align-items: center; gap: 0.5rem; font-size: 0.9rem;">
                            <span>Max size (KB):</span>
                            <input type="number" id="userMaxUploadBytesInput" min="100" max="10240" value="2048" style="width: 5rem; padding: 0.35rem; background: var(--surface-hover); border: 1px solid var(--border); border-radius: var(--radius-sm); color: var(--text);" onchange="setUserMaxUploadBytes(this.value)">
                        </label>
                    </div>
                </div>
            </div>

            <div id="superadminPanelGuests" class="superadmin-panel">
                <div class="superadmin-section">
                    <div class="superadmin-section-title">Guest History</div>
                    <div class="guest-history-table-wrap" style="max-height: 220px; overflow-y: auto;">
                        <table class="guest-history-table" style="width:100%; font-size: 0.85rem; border-collapse: collapse;">
                            <thead><tr><th style="text-align:left; padding: 0.35rem 0.5rem;">IP</th><th style="text-align:left; padding: 0.35rem 0.5rem;">Time</th><th style="text-align:left; padding: 0.35rem 0.5rem;">Sound</th><th></th></tr></thead>
                            <tbody id="guestHistoryBody"></tbody>
                        </table>
                    </div>
                </div>
                <div class="superadmin-section">
                    <div class="superadmin-section-title">Blocked IPs</div>
                    <div id="blockedIPsList" class="blocked-ips-list" style="font-size: 0.85rem;"></div>
                </div>
            </div>

            <div id="superadminPanelUsers" class="superadmin-panel">
                <div class="superadmin-section">
                    <div class="superadmin-section-title">User Management</div>
                    <p style="font-size: 0.85rem; color: var(--text-muted); margin-bottom: 0.5rem;">Managed users (from signups) can have role changed, password reset, or be removed.</p>
                    <div class="pending-uploads-wrap" style="max-height: 200px; overflow-y: auto;">
                        <table class="guest-history-table" style="width:100%; font-size: 0.85rem; border-collapse: collapse;">
                            <thead><tr><th style="text-align:left; padding: 0.35rem 0.5rem;">Username</th><th style="text-align:left; padding: 0.35rem 0.5rem;">Role</th><th></th></tr></thead>
                            <tbody id="usersListBody"></tbody>
                        </table>
                    </div>
                    <div id="usersListEmpty" class="pending-empty" style="font-size: 0.85rem; color: var(--text-muted); padding: 0.5rem;">No users</div>
                </div>
                <div class="superadmin-section">
                    <div class="superadmin-section-title">Pending Signups</div>
                    <p style="font-size: 0.85rem; color: var(--text-muted); margin-bottom: 0.5rem;">Choose role when approving.</p>
                    <div class="pending-uploads-wrap" style="max-height: 140px; overflow-y: auto;">
                        <table class="guest-history-table" style="width:100%; font-size: 0.85rem; border-collapse: collapse;">
                            <thead><tr><th style="text-align:left; padding: 0.35rem 0.5rem;">Username</th><th style="text-align:left; padding: 0.35rem 0.5rem;">Requested</th><th style="text-align:left; padding: 0.35rem 0.5rem;">Role</th><th></th></tr></thead>
                            <tbody id="pendingSignupsBody"></tbody>
                        </table>
                    </div>
                    <div id="pendingSignupsEmpty" class="pending-empty" style="font-size: 0.85rem; color: var(--text-muted); padding: 0.5rem;">No pending signups</div>
                </div>
            </div>

            <div id="superadminPanelModeration" class="superadmin-panel">
                <div class="superadmin-section">
                    <div class="superadmin-section-title">Moderation Queue</div>
                    <p style="font-size: 0.85rem; color: var(--text-muted); margin-bottom: 0.5rem;">User and guest uploads await approval.</p>
                    <div class="pending-uploads-wrap" style="max-height: 280px; overflow-y: auto;">
                        <table class="guest-history-table" style="width:100%; font-size: 0.85rem; border-collapse: collapse;">
                            <thead><tr><th style="text-align:left; padding: 0.35rem 0.5rem;">File</th><th style="text-align:left; padding: 0.35rem 0.5rem;">By</th><th style="text-align:left; padding: 0.35rem 0.5rem;">Time</th><th></th></tr></thead>
                            <tbody id="pendingUploadsBody"></tbody>
                        </table>
                    </div>
                    <div id="pendingUploadsEmpty" class="pending-empty" style="font-size: 0.85rem; color: var(--text-muted); padding: 0.5rem;">No pending uploads</div>
                </div>
            </div>
        </div>
        </div>

        <div id="changePasswordOverlay" class="change-password-overlay hidden">
            <div class="change-password-modal">
                <h3 id="changePasswordTitle">Change password</h3>
                <label for="changePasswordCurrent">Current password</label>
                <input type="password" id="changePasswordCurrent" placeholder="Current password" autocomplete="current-password">
                <label for="changePasswordNew">New password</label>
                <input type="password" id="changePasswordNew" placeholder="New password (min 6 chars)" autocomplete="new-password">
                <label for="changePasswordConfirm">Confirm new password</label>
                <input type="password" id="changePasswordConfirm" placeholder="Confirm" autocomplete="new-password">
                <div id="changePasswordError" style="font-size:0.85rem;color:var(--danger);margin-bottom:0.5rem;display:none"></div>
                <div>
                    <button type="button" class="btn btn-primary" onclick="submitChangePassword()">Change password</button>
                    <button type="button" class="btn btn-ghost" id="changePasswordCancelBtn" onclick="closeChangePasswordModal()">Cancel</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        const CREDENTIALS = 'include';
        const SOUND_COLOR_PRESETS = ['#ef4444', '#f97316', '#eab308', '#22c55e', '#14b8a6', '#3b82f6', '#8b5cf6', '#ec4899', '#6b7280'];
        let user = null;
        let guestMaxDuration = 7;
        let guestCooldownSec = 10;
        let guestUploadEnabled = false;
        let guestMaxUploadDuration = 7;
        let guestMaxUploadBytes = 2097152;
        let userMaxDuration = 7;
        let userCooldownSec = 0;
        let userLastPlayTime = 0;
        let playback = { status: 'idle', filename: null, displayName: null, startTime: null, duration: null, startTimeOffset: 0, startedBy: null };
        let playbackLockedBy = null;
        let playbackSuperadminOnly = false;
        let guestLastPlayTime = 0;
        let guestEnabled = false;
        let userUploadEnabled = false;
        let userMaxUploadDuration = 7;
        let userMaxUploadBytes = 2097152;
        let pausedAt = 0;
        let waveformData = null;
        let waveformDuration = 0;
        let waveformFilename = null;
        let reorderMode = false;
        let playbackLocked = false;
        let soundsList = [];
        let tagsList = [];
        let hiddenTags = [];
        let selectedTag = null;
        let selectedSound = null;
        let manageTagsMode = false;
        let soundFilter = '';
        let lastGuestCooldownShown = -1;
        let lastUserCooldownShown = -1;
        let compactMode = false;
        let mobileView = false;
        let mobilePageIndex = 0;
        let mobileTouchStartX = 0;

        const PREFS_KEY = 'soundboard-prefs';
        function loadPrefs() {
            try {
                const raw = localStorage.getItem(PREFS_KEY);
                return raw ? JSON.parse(raw) : {};
            } catch { return {}; }
        }
        function savePrefs(prefs) {
            try {
                const merged = { ...loadPrefs(), ...prefs };
                localStorage.setItem(PREFS_KEY, JSON.stringify(merged));
            } catch (e) {}
        }
        function applyPrefs() {
            const prefs = loadPrefs();
            soundFilter = prefs.soundFilter || '';
            const filterInput = document.getElementById('soundFilterInput');
            if (filterInput) filterInput.value = soundFilter;
            if (typeof updateFilterClearVisibility === 'function') updateFilterClearVisibility();
            compactMode = prefs.compact === true;
            mobileView = prefs.mobileView === true;
            const grid = document.getElementById('soundsList');
            const compactBtn = document.getElementById('compactBtn');
            const soundsCard = document.querySelector('.sounds-card');
            const mobileBtn = document.getElementById('mobileBtn');
            if (grid) grid.classList.toggle('compact-mode', compactMode);
            if (compactBtn) compactBtn.classList.toggle('active', compactMode);
            if (soundsCard) soundsCard.classList.toggle('mobile-active', mobileView);
            if (mobileBtn) mobileBtn.classList.toggle('active', mobileView);
            if (mobileView) renderMobileGrid();
            applyVolumeExpanded();
            applyRecentPlayerExpanded();
        }
        function toggleCompact() {
            compactMode = !compactMode;
            const grid = document.getElementById('soundsList');
            const compactBtn = document.getElementById('compactBtn');
            if (grid) grid.classList.toggle('compact-mode', compactMode);
            if (compactBtn) compactBtn.classList.toggle('active', compactMode);
            savePrefs({ compact: compactMode });
        }

        function toggleMobileView() {
            mobileView = !mobileView;
            const soundsCard = document.querySelector('.sounds-card');
            const mobileBtn = document.getElementById('mobileBtn');
            if (soundsCard) soundsCard.classList.toggle('mobile-active', mobileView);
            if (mobileBtn) mobileBtn.classList.toggle('active', mobileView);
            savePrefs({ mobileView });
            if (mobileView) renderMobileGrid();
        }

        const waveformCache = {};
        let serverRecentlyPlayed = [];
        function getRecentlyPlayed() {
            if (serverRecentlyPlayed.length > 0) return serverRecentlyPlayed.slice(0, 5);
            const arr = loadPrefs().recentPlayed;
            return Array.isArray(arr) ? arr.slice(0, 5) : [];
        }
        function setRecentlyPlayedFromServer(list) {
            serverRecentlyPlayed = Array.isArray(list) ? list : [];
            renderRecentlyPlayed();
        }
        function formatRecentTime(ts) {
            if (!ts || !Number.isFinite(ts)) return 'unknown';
            var sec = Math.floor((Date.now() - ts) / 1000);
            if (sec < 60) return 'just now';
            if (sec < 3600) return Math.floor(sec / 60) + ' min ago';
            if (sec < 86400) return Math.floor(sec / 3600) + ' hr ago';
            return Math.floor(sec / 86400) + ' day' + (sec >= 172800 ? 's' : '') + ' ago';
        }
        async function loadWaveformForRecent(filename) {
            if (waveformCache[filename]) return;
            try {
                var res = await fetch('/api/sounds/audio/' + encodeURIComponent(filename), { credentials: CREDENTIALS });
                if (!res.ok) return;
                var buf = await res.arrayBuffer();
                var ctx = new (window.AudioContext || window.webkitAudioContext)();
                var decoded = await ctx.decodeAudioData(buf);
                var ch = decoded.getChannelData(0);
                var duration = decoded.duration;
                var bars = 60;
                var step = Math.floor(ch.length / bars);
                var peaks = [];
                for (var i = 0; i < bars; i++) {
                    var min = 0, max = 0;
                    for (var j = 0; j < step; j++) {
                        var v = ch[i * step + j];
                        if (v < min) min = v;
                        if (v > max) max = v;
                    }
                    peaks.push({ min: min, max: max });
                }
                waveformCache[filename] = { peaks: peaks, duration: duration };
                renderRecentlyPlayed();
            } catch (e) {}
        }
        function drawRecentWaveform(canvas, peaks, duration) {
            if (!canvas || !peaks || !peaks.length) return;
            var rect = canvas.getBoundingClientRect();
            var w = canvas.width = rect.width || 200;
            var h = canvas.height = rect.height || 48;
            var ctx = canvas.getContext('2d');
            var barCount = peaks.length;
            var barW = Math.max(1, (w / barCount) - 0.5);
            ctx.clearRect(0, 0, w, h);
            peaks.forEach(function(peak, i) {
                var x = (i / barCount) * w;
                var center = h / 2;
                var halfH = Math.max(1, (Math.abs(peak.max - peak.min) / 2) * (h * 0.45));
                ctx.fillStyle = 'rgba(124, 58, 237, 0.5)';
                ctx.fillRect(x, center - halfH, barW, halfH * 2);
            });
        }
        function toggleRecentPlayed() {
            const expanded = loadPrefs().recentPlayerExpanded !== true;
            savePrefs({ recentPlayerExpanded: expanded });
            applyRecentPlayerExpanded();
        }
        function applyRecentPlayerExpanded() {
            const expanded = loadPrefs().recentPlayerExpanded === true;
            const section = document.getElementById('playerRecent');
            const btn = document.getElementById('recentToggleBtn');
            if (section) section.classList.toggle('hidden', !expanded);
            if (btn) btn.classList.toggle('expanded', expanded);
            if (expanded) setTimeout(renderRecentlyPlayed, 50);
        }
        function renderRecentlyPlayed() {
            const list = getRecentlyPlayed();
            const el = document.getElementById('playerRecentList');
            if (!el) return;
            if (list.length === 0) {
                el.innerHTML = '<div class="player-recent-empty" style="font-size:0.85rem;color:var(--text-muted);padding:0.5rem 0">No sounds played yet</div>';
            } else {
                el.innerHTML = list.map(function(item) {
                    var name = (item.displayName || item.filename || '').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
                    var fn = (item.filename || '').replace(/"/g, '&quot;');
                    var by = (item.playedBy || 'Unknown').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
                    var when = formatRecentTime(item.playedAt);
                    return '<button type="button" class="player-recent-item" data-filename="' + fn + '" onclick="playSound(this.dataset.filename)"><canvas class="recent-waveform"></canvas><div class="recent-content"><div>' + name + '</div><div class="recent-meta">' + by + ' ¬∑ ' + when + '</div></div></button>';
                }).join('');
                el.querySelectorAll('.recent-waveform').forEach(function(canvas, i) {
                    var item = list[i];
                    if (item && waveformCache[item.filename]) {
                        drawRecentWaveform(canvas, waveformCache[item.filename].peaks, waveformCache[item.filename].duration);
                    }
                });
                list.forEach(function(item) {
                    if (!waveformCache[item.filename]) loadWaveformForRecent(item.filename);
                });
            }
        }

        function toggleSoundsOptionsMenu() {
            const menu = document.getElementById('soundsOptionsMenu');
            if (!menu) return;
            const isHidden = menu.classList.contains('hidden');
            menu.classList.toggle('hidden', !isHidden);
            if (isHidden) {
                setTimeout(function() {
                    document.addEventListener('click', closeSoundsOptionsMenuOnce);
                }, 0);
            } else {
                document.removeEventListener('click', closeSoundsOptionsMenuOnce);
            }
        }
        function closeSoundsOptionsMenu() {
            const menu = document.getElementById('soundsOptionsMenu');
            if (menu) menu.classList.add('hidden');
            document.removeEventListener('click', closeSoundsOptionsMenuOnce);
        }
        function closeSoundsOptionsMenuOnce(e) {
            const wrap = document.querySelector('.sounds-options-wrap');
            if (wrap && !wrap.contains(e.target)) {
                closeSoundsOptionsMenu();
                document.removeEventListener('click', closeSoundsOptionsMenuOnce);
            }
        }

        function getFavorites() {
            const arr = loadPrefs().favorites;
            return Array.isArray(arr) ? arr.slice(0, 9) : [];
        }
        function setFavorites(arr) {
            const safe = (Array.isArray(arr) ? arr : []).slice(0, 9);
            savePrefs({ favorites: safe });
        }
        function toggleFavorite(filename) {
            if (!filename) return;
            let fav = getFavorites();
            const idx = fav.indexOf(filename);
            if (idx >= 0) {
                fav = fav.filter(f => f !== filename);
            } else if (fav.length < 9) {
                fav = [...fav, filename];
            }
            setFavorites(fav);
            renderFavoritesBar();
            renderSoundsGrid();
        }
        function renderFavoritesBar() {
            const bar = document.getElementById('favoritesBar');
            const section = bar && bar.closest('.favorites-section');
            if (!bar) return;
            const fav = getFavorites();
            const sounds = soundsList || [];
            const used = fav.map(function(fn, i) { return fn ? { n: i + 1, fn: fn } : null; }).filter(Boolean);
            if (section) section.style.display = used.length ? '' : 'none';
            bar.innerHTML = used.map(function(item) {
                const n = item.n, fn = item.fn;
                const s = sounds.find(function(x) { return x.filename === fn; });
                const name = s ? (s.displayName || s.filename || '') : '';
                const label = name ? (name.length > 8 ? name.slice(0, 8) + '‚Ä¶' : name) : '‚Äî';
                const title = (s && s.displayName) || (s && s.filename) || fn;
                return '<button type="button" class="fav-slot" data-slot="' + n + '" data-filename="' + (fn || '').replace(/"/g, '&quot;') + '" title="' + (title || '').replace(/"/g, '&quot;') + ' (click to play)">' +
                    '<span class="fav-num">' + n + '</span><span class="fav-label">' + (label || '‚Äî').replace(/&/g, '&amp;').replace(/</g, '&lt;') + '</span></button>';
            }).join('');
            bar.querySelectorAll('.fav-slot').forEach(function(btn) {
                btn.onclick = function() { playSound(btn.dataset.filename); };
            });
        }

        const UNTAGGED_FILTER = '__untagged__';
        function getFilteredSounds() {
            const list = soundsList || [];
            let filtered;
            if (selectedTag === UNTAGGED_FILTER) {
                filtered = list.filter(s => !(s.tags || []).length);
            } else if (selectedTag != null) {
                filtered = list.filter(s => (s.tags || []).includes(selectedTag));
            } else {
                filtered = list;
            }
            const q = (soundFilter || '').trim().toLowerCase();
            if (q) {
                const terms = q.split(/\s+/).filter(t => t);
                filtered = filtered.filter(s => {
                    const name = ((s.displayName || s.filename) || '').toLowerCase();
                    const tags = (s.tags || []).map(t => t.toLowerCase());
                    return terms.every(term => name.includes(term) || tags.some(t => t.includes(term)));
                });
            }
            return filtered;
        }

        function getMobileGridLayout() {
            const w = window.innerWidth;
            const h = window.innerHeight;
            const cols = w < 380 ? 3 : 4;
            const rows = h < 480 ? 3 : 4;
            return { cols, rows, perPage: cols * rows };
        }

        function renderMobileGrid() {
            const area = document.getElementById('mobileGridArea');
            const wrap = document.getElementById('mobileGridWrap');
            const nav = document.getElementById('mobileGridNav');
            const pageEl = document.getElementById('mobileGridPage');
            const prevBtn = document.getElementById('mobilePrevBtn');
            const nextBtn = document.getElementById('mobileNextBtn');
            if (!area || !mobileView) return;
            const filtered = getFilteredSounds();
            const { perPage } = getMobileGridLayout();
            const totalPages = Math.max(1, Math.ceil(filtered.length / perPage));
            const isPaged = filtered.length > perPage;
            if (isPaged) {
                mobilePageIndex = Math.max(0, Math.min(mobilePageIndex, totalPages - 1));
            } else {
                mobilePageIndex = 0;
            }
            if (wrap) wrap.classList.toggle('paged', isPaged);
            area.classList.toggle('paged', isPaged);
            const isUser = (user && user.role) === 'user';
            const isGuest = (user && user.role) === 'guest';
            const guestCooldown = getGuestCooldownRemaining();
            const userCooldown = getUserCooldownRemaining();
            const adminPlaying = (playback.status === 'playing' || playback.status === 'paused') && ((playback.startedBy && playback.startedBy.role) === 'admin' || (playback.startedBy && playback.startedBy.role) === 'superadmin');
            const superadminPlaying = (playback.status === 'playing' || playback.status === 'paused') && (playback.startedBy && playback.startedBy.role) === 'superadmin';
            const cannotOverride = ((isUser || isGuest) && adminPlaying) || ((user && user.role) === 'admin' && superadminPlaying);
            const canPlay = ((!isUser && !isGuest) && !((user && user.role) === 'admin' && superadminPlaying)) || ((!playbackLocked && !playbackSuperadminOnly) && (isGuest ? guestCooldown === 0 : userCooldown === 0) && !cannotOverride);
            const maxDur = isGuest ? (guestMaxDuration || 7) : (userMaxDuration || 7);
            const tooLong = (dur) => (isUser || isGuest) && dur != null && dur > maxDur;
            if (filtered.length === 0) {
                area.innerHTML = '<div style="grid-column:1/-1; padding:2rem; text-align:center; color:var(--text-muted)">No sounds</div>';
                if (pageEl) pageEl.textContent = '‚Äî';
                return;
            }
            const start = isPaged ? mobilePageIndex * perPage : 0;
            const end = isPaged ? Math.min(start + perPage, filtered.length) : filtered.length;
            const pageSounds = filtered.slice(start, end);
            area.innerHTML = pageSounds.map(s => {
                const disabled = !canPlay || tooLong(s.duration);
                const name = (s.displayName || s.filename || '').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
                const dur = s.duration != null ? formatTime(s.duration) : '‚Äî';
                const fn = (s.filename || '').replace(/"/g, '&quot;');
                const color = (s.color && /^#[0-9a-fA-F]{6}$/.test(s.color)) ? s.color : '';
                const colorBar = color ? '<span class="mobile-grid-color" style="background:' + color + '"></span>' : '';
                return '<button type="button" class="mobile-grid-btn ' + (disabled ? 'disabled' : '') + '" data-filename="' + fn + '" ' + (disabled ? 'disabled' : '') + ' onclick="playSound(this.dataset.filename)">' + colorBar + '<span>' + name + '</span><span class="duration">' + dur + '</span></button>';
            }).join('');
            if (pageEl) pageEl.textContent = isPaged ? `${mobilePageIndex + 1} / ${totalPages}` : '‚Äî';
            if (prevBtn) prevBtn.disabled = !isPaged || mobilePageIndex <= 0;
            if (nextBtn) nextBtn.disabled = !isPaged || mobilePageIndex >= totalPages - 1;
            if (isPaged) setupMobileSwipeHandlers();
        }

        function mobilePagePrev() {
            const filtered = getFilteredSounds();
            const { perPage } = getMobileGridLayout();
            if (filtered.length <= perPage) return;
            if (mobilePageIndex > 0) { mobilePageIndex--; renderMobileGrid(); }
        }

        function mobilePageNext() {
            const filtered = getFilteredSounds();
            const { perPage } = getMobileGridLayout();
            const totalPages = Math.ceil(filtered.length / perPage);
            if (mobilePageIndex < totalPages - 1) { mobilePageIndex++; renderMobileGrid(); }
        }

        function setupMobileSwipeHandlers() {
            const area = document.getElementById('mobileGridArea');
            if (!area) return;
            area.ontouchstart = (e) => { mobileTouchStartX = e.touches[0].clientX; };
            area.ontouchend = (e) => {
                if (!(e.changedTouches && e.changedTouches[0])) return;
                const dx = e.changedTouches[0].clientX - mobileTouchStartX;
                if (dx > 60) mobilePagePrev();
                else if (dx < -60) mobilePageNext();
            };
        }

        function applyTheme(theme) {
            const t = theme || 'dark';
            document.documentElement.setAttribute('data-theme', t);
            const loginBtn = document.getElementById('themeToggleLogin');
            if (loginBtn) loginBtn.textContent = (t === 'light') ? 'üåô' : '‚òÄÔ∏è';
            updateHeaderMenuThemeLabel();
        }
        function updateHeaderMenuThemeLabel() {
            const label = document.getElementById('headerMenuThemeLabel');
            if (label) {
                const t = document.documentElement.getAttribute('data-theme') || 'dark';
                label.textContent = t === 'light' ? 'Light' : 'Dark';
            }
        }
        function toggleTheme() {
            const current = document.documentElement.getAttribute('data-theme') || 'dark';
            const next = current === 'dark' ? 'light' : 'dark';
            applyTheme(next);
            savePrefs({ theme: next });
        }

        async function api(path, opts = {}) {
            const res = await fetch(path, { credentials: CREDENTIALS, ...opts });
            if (res.status === 401) { showLogin(); return null; }
            return res;
        }

        function isAdminOrSuperadmin() { return (user && user.role) === 'admin' || (user && user.role) === 'superadmin'; }

        function switchMainTab(tab) {
            document.getElementById('soundsView').classList.toggle('hidden', tab !== 'sounds');
            document.getElementById('superadminView').classList.toggle('hidden', tab !== 'superadmin');
            if (tab === 'superadmin') { fetchGuestHistory(); fetchBlockedIPs(); fetchPendingUploads(); fetchPendingSignups(); fetchUsers(); }
        }
        function switchSuperadminTab(panelId) {
            document.querySelectorAll('.superadmin-tab').forEach(t => t.classList.toggle('active', t.dataset.panel === panelId));
            document.querySelectorAll('.superadmin-panel').forEach(p => p.classList.toggle('active', p.id === 'superadminPanel' + panelId.charAt(0).toUpperCase() + panelId.slice(1)));
        }

        function openChangePasswordModal(forced) {
            const overlay = document.getElementById('changePasswordOverlay');
            const title = document.getElementById('changePasswordTitle');
            const cancelBtn = document.getElementById('changePasswordCancelBtn');
            const curLabel = document.querySelector('label[for="changePasswordCurrent"]');
            const curInput = document.getElementById('changePasswordCurrent');
            const err = document.getElementById('changePasswordError');
            if (overlay) overlay.classList.remove('hidden');
            if (title) title.textContent = forced ? 'You must change your password' : 'Change password';
            if (cancelBtn) cancelBtn.style.display = forced ? 'none' : '';
            if (curLabel) curLabel.textContent = forced ? 'Temporary password' : 'Current password';
            if (curInput) curInput.value = '';
            document.getElementById('changePasswordNew').value = '';
            document.getElementById('changePasswordConfirm').value = '';
            if (err) { err.style.display = 'none'; err.textContent = ''; }
        }
        function closeChangePasswordModal() {
            document.getElementById('changePasswordOverlay').classList.add('hidden');
        }
        async function submitChangePassword() {
            const cur = document.getElementById('changePasswordCurrent').value;
            const newPw = document.getElementById('changePasswordNew').value;
            const confirm = document.getElementById('changePasswordConfirm').value;
            const err = document.getElementById('changePasswordError');
            const forced = user && user.mustChangePassword === true;
            err.style.display = 'none';
            err.textContent = '';
            if (!forced && !cur) { err.textContent = 'Enter current password'; err.style.display = 'block'; return; }
            if (newPw.length < 6) { err.textContent = 'New password must be at least 6 characters'; err.style.display = 'block'; return; }
            if (newPw !== confirm) { err.textContent = 'New passwords do not match'; err.style.display = 'block'; return; }
            const res = await api('/api/me/password', { method: 'PATCH', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ currentPassword: cur, newPassword: newPw }) });
            const data = await res.json().catch(() => ({}));
            if (!res || !res.ok) { err.textContent = data.error || 'Failed'; err.style.display = 'block'; return; }
            if (user) user.mustChangePassword = false;
            closeChangePasswordModal();
            await checkAuth();
        }

        async function checkAuth() {
            const res = await api('/api/me');
            if (!res) return false;
            if (res.ok) {
                user = await res.json();
                document.getElementById('loginScreen').classList.add('hidden');
                document.getElementById('app').classList.remove('hidden');
                document.getElementById('currentUsername').textContent = user.username;
                document.getElementById('currentRole').textContent = '(' + (user.role || 'user') + ')';
                if (user.role === 'user' || user.role === 'guest') {
                    document.querySelectorAll('.admin-only').forEach(el => el.classList.add('hidden'));
                    document.querySelectorAll('.superadmin-only').forEach(el => el.classList.add('hidden'));
                    document.getElementById('topActions').classList.add('hidden');
                    document.getElementById('playPauseBtn').classList.add('hidden');
                    document.getElementById('stopBtn').classList.add('hidden');
                    document.querySelectorAll('.user-only').forEach(el => el.classList.toggle('hidden', user.role !== 'user'));
                } else {
                    document.getElementById('topActions').classList.remove('hidden');
                    document.getElementById('playPauseBtn').classList.remove('hidden');
                    document.getElementById('stopBtn').classList.remove('hidden');
                    document.querySelectorAll('.admin-only').forEach(el => el.classList.remove('hidden'));
                    document.querySelectorAll('.user-only').forEach(el => el.classList.add('hidden'));
                    if (user.role === 'superadmin') {
                        document.querySelectorAll('.superadmin-only').forEach(el => el.classList.remove('hidden'));
                        startPendingCountPolling();
                    } else {
                        document.querySelectorAll('.superadmin-only').forEach(el => el.classList.add('hidden'));
                    }
                }
                fetchSettings();
                if ((user && user.role) === 'superadmin') { fetchGuestHistory(); fetchBlockedIPs(); fetchPendingUploads(); fetchPendingSignups(); fetchUsers(); }
                updateUploadCardVisibility();
                if (user && user.mustChangePassword === true && user.role === 'user') openChangePasswordModal(true);
                return true;
            }
            showLogin();
            return false;
        }

        function showLogin() {
            user = null;
            document.getElementById('loginScreen').classList.remove('hidden');
            document.getElementById('app').classList.add('hidden');
            showLoginForm();
            fetchGuestStatus();
        }

        function showRegisterForm() {
            document.getElementById('loginForm').style.display = 'none';
            document.getElementById('registerForm').classList.add('visible');
            document.getElementById('registerError').textContent = '';
        }
        function showLoginForm() {
            document.getElementById('loginForm').style.display = 'block';
            document.getElementById('registerForm').classList.remove('visible');
            document.getElementById('loginError').textContent = '';
        }

        async function fetchGuestStatus() {
            try {
                const res = await fetch('/api/guest-status', { credentials: CREDENTIALS });
                if (res.ok) {
                    const d = await res.json();
                    guestEnabled = d.guestEnabled === true;
                    const div = document.getElementById('guestDivider');
                    const btn = document.getElementById('guestBtn');
                    if (div && btn) { div.style.display = guestEnabled ? 'block' : 'none'; btn.style.display = guestEnabled ? 'block' : 'none'; }
                }
            } catch (e) {}
        }

        async function doGuestLogin() {
            document.getElementById('loginError').textContent = '';
            const res = await fetch('/api/guest/start', { method: 'POST', credentials: CREDENTIALS });
            const data = await res.json().catch(() => ({}));
            if (!res.ok) {
                document.getElementById('loginError').textContent = data.error || 'Guest access unavailable';
                return;
            }
            await checkAuth();
            applyPrefs();
            startPlaybackPolling();
            startSoundsPolling();
            fetchSounds();
            return false;
        }

        async function doRegister(e) {
            e.preventDefault();
            const username = document.getElementById('regUser').value.trim();
            const password = document.getElementById('regPass').value;
            const confirm = document.getElementById('regPassConfirm').value;
            document.getElementById('registerError').textContent = '';
            if (password !== confirm) {
                document.getElementById('registerError').textContent = 'Passwords do not match';
                return false;
            }
            const res = await fetch('/api/register', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                credentials: CREDENTIALS,
                body: JSON.stringify({ username, password }),
            });
            const data = await res.json().catch(() => ({}));
            if (!res.ok) {
                document.getElementById('registerError').textContent = data.error || 'Registration failed';
                return false;
            }
            document.getElementById('registerForm').querySelector('form').reset();
            showLoginForm();
            document.getElementById('loginError').textContent = '';
            document.getElementById('loginError').style.color = 'var(--success, #22c55e)';
            document.getElementById('loginError').textContent = data.message || 'Registration submitted. Awaiting admin approval.';
            return false;
        }

        async function doLogin(e) {
            e.preventDefault();
            const username = document.getElementById('loginUser').value.trim();
            const password = document.getElementById('loginPass').value;
            document.getElementById('loginError').textContent = '';
            const res = await fetch('/api/login', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                credentials: CREDENTIALS,
                body: JSON.stringify({ username, password }),
            });
            const data = await res.json().catch(() => ({}));
            if (!res.ok) {
                document.getElementById('loginError').style.color = '';
                document.getElementById('loginError').textContent = data.error || 'Login failed';
                return false;
            }
            await checkAuth();
            applyPrefs();
            startPlaybackPolling();
            startSoundsPolling();
            fetchChannels();
            fetchSounds();
            fetch('/api/volume', { credentials: CREDENTIALS }).then(function(r) { return r.json(); }).then(function(d) {
                const v = (d.volume != null ? d.volume : 0.5);
                setVolume(String(v));
                applyVolumeExpanded();
            }).catch(function() {});
            return false;
        }

        async function logout() {
            await fetch('/api/logout', { method: 'POST', credentials: CREDENTIALS });
            showLogin();
        }

        async function fetchChannels() {
            if (!isAdminOrSuperadmin()) return;
            const res = await api('/api/channels');
            if (!res || !res.ok) return;
            const data = await res.json();
            const channels = Array.isArray(data) ? data : (data.channels || []);
            const serverLastChannel = data.lastChannelId || null;
            const lastChannel = loadPrefs().lastChannelId || serverLastChannel;
            const select = document.getElementById('channelSelect');
            select.innerHTML = channels.map(c => `<option value="${c.id}">${c.name}</option>`).join('');
            if (lastChannel && channels.some(c => c.id === lastChannel)) {
                select.value = lastChannel;
                if (!loadPrefs().lastChannelId) savePrefs({ lastChannelId: lastChannel });
            }
            const voiceConnected = data.voiceConnected === true;
            const voiceChannelName = data.voiceChannelName || '';
            const connectionCard = document.getElementById('connectionCard');
            const voiceBar = document.getElementById('voiceConnectedBar');
            const channelNameEl = document.getElementById('voiceChannelInfo');
            if (connectionCard) connectionCard.classList.toggle('hidden', voiceConnected);
            if (voiceBar) voiceBar.classList.toggle('hidden', !voiceConnected);
            if (channelNameEl) {
                channelNameEl.title = voiceChannelName ? 'Connected to: ' + voiceChannelName : '';
                const nameSpan = document.getElementById('voiceChannelName');
                if (nameSpan) nameSpan.textContent = voiceChannelName || '‚Äî';
            }
        }

        async function fetchSettings() {
            const res = await api('/api/settings');
            if (!res || !res.ok) return;
            const d = await res.json();
            playbackLocked = d.playbackLocked === true;
            playbackLockedBy = d.playbackLockedBy || null;
            playbackSuperadminOnly = d.playbackSuperadminOnly === true;
            if (d.userUploadEnabled !== undefined) userUploadEnabled = d.userUploadEnabled;
            if (d.guestUploadEnabled !== undefined) guestUploadEnabled = d.guestUploadEnabled;
            if (d.userMaxUploadDuration !== undefined) userMaxUploadDuration = d.userMaxUploadDuration;
            if (d.userMaxUploadBytes !== undefined) userMaxUploadBytes = d.userMaxUploadBytes;
            if (d.guestMaxUploadDuration !== undefined) guestMaxUploadDuration = d.guestMaxUploadDuration;
            if (d.guestMaxUploadBytes !== undefined) guestMaxUploadBytes = d.guestMaxUploadBytes;
            if (d.userMaxDuration !== undefined) userMaxDuration = d.userMaxDuration;
            if (d.userCooldownSec !== undefined) userCooldownSec = d.userCooldownSec;
            const cb = document.getElementById('playbackLockedTop');
            if (cb) cb.checked = playbackLocked;
            const cbSuper = document.getElementById('playbackSuperadminOnlyTop');
            if (cbSuper) cbSuper.checked = playbackSuperadminOnly;
            const msg = document.getElementById('userLockedMsg');
            if (msg) {
                const showLocked = playbackSuperadminOnly ? (user && (user.role === 'user' || user.role === 'guest' || user.role === 'admin')) : ((user && user.role) === 'user' || (user && user.role) === 'guest') && playbackLocked;
                if (showLocked) {
                    msg.textContent = playbackSuperadminOnly ? 'Only superadmin can play.' : (playbackLockedBy === 'superadmin' ? 'Playback is locked by a superadmin.' : 'Playback is locked by an admin.');
                    msg.classList.remove('hidden');
                } else {
                    msg.classList.add('hidden');
                }
            }
            if (d.guestMaxDuration !== undefined) guestMaxDuration = d.guestMaxDuration;
            if (d.guestCooldownSec !== undefined) guestCooldownSec = d.guestCooldownSec;
            if ((user && user.role) === 'superadmin') {
                if (d.guestEnabled !== undefined) { guestEnabled = d.guestEnabled; const g = document.getElementById('guestEnabledToggle'); if (g) g.checked = guestEnabled; }
                if (d.guestMaxDuration !== undefined) { const g = document.getElementById('guestMaxDurationInput'); if (g) g.value = d.guestMaxDuration; }
                if (d.guestCooldownSec !== undefined) { const g = document.getElementById('guestCooldownInput'); if (g) g.value = d.guestCooldownSec; }
                if (d.guestUploadEnabled !== undefined) { const g = document.getElementById('guestUploadEnabledToggle'); if (g) g.checked = d.guestUploadEnabled; }
                if (d.guestMaxUploadDuration !== undefined) { const g = document.getElementById('guestMaxUploadDurationInput'); if (g) g.value = d.guestMaxUploadDuration; }
                if (d.guestMaxUploadBytes !== undefined) { const g = document.getElementById('guestMaxUploadBytesInput'); if (g) g.value = Math.round(d.guestMaxUploadBytes / 1024); }
                if (d.userMaxDuration !== undefined) { const g = document.getElementById('userMaxDurationInput'); if (g) g.value = d.userMaxDuration; }
                if (d.userCooldownSec !== undefined) { const g = document.getElementById('userCooldownInput'); if (g) g.value = d.userCooldownSec; }
                if (d.userUploadEnabled !== undefined) { const g = document.getElementById('userUploadEnabledToggle'); if (g) g.checked = d.userUploadEnabled; }
                if (d.userMaxUploadDuration !== undefined) { const g = document.getElementById('userMaxUploadDurationInput'); if (g) g.value = d.userMaxUploadDuration; }
                if (d.userMaxUploadBytes !== undefined) { const g = document.getElementById('userMaxUploadBytesInput'); if (g) g.value = Math.round(d.userMaxUploadBytes / 1024); }
            }
            if (d.volume !== undefined && Number.isFinite(d.volume)) {
                setVolume(String(Math.max(0, Math.min(1, d.volume))));
            }
            applyVolumeExpanded();
            if ((user && user.role) === 'superadmin' && d.pendingCount !== undefined) {
                updatePendingBadge(d.pendingCount, 0);
            }
            updateUploadCardVisibility();
        }

        function updateUploadCardVisibility() {
            const card = document.getElementById('uploadCard');
            const hint = document.getElementById('uploadHint');
            const btn = document.getElementById('uploadToggleBtn');
            if (!card || !hint) return;
            const canDirect = isAdminOrSuperadmin();
            const isGuest = (user && user.role) === 'guest';
            const isUser = (user && user.role) === 'user';
            const canGuestUpload = isGuest && guestUploadEnabled;
            const canUserUpload = isUser && userUploadEnabled;
            const canPending = canGuestUpload || canUserUpload;
            const canUpload = canDirect || canPending;
            if (btn) btn.classList.toggle('hidden', !canUpload);
            if (canDirect) {
                hint.textContent = '';
            } else if (canPending) {
                const maxSec = isGuest ? (guestMaxUploadDuration || 7) : (userMaxUploadDuration || 7);
                const maxKB = Math.round((isGuest ? (guestMaxUploadBytes || 2097152) : (userMaxUploadBytes || 2097152)) / 1024);
                hint.textContent = 'Uploads go to a moderation queue. Max ' + maxSec + 's, ' + maxKB + 'KB. A superadmin must approve before they appear.';
            } else {
                hint.textContent = '';
            }
            if (!canUpload) card.classList.add('hidden');
        }
        function toggleUploadSection() {
            const card = document.getElementById('uploadCard');
            const btn = document.getElementById('uploadToggleBtn');
            if (!card || !btn) return;
            const isHidden = card.classList.contains('hidden');
            card.classList.toggle('hidden', !isHidden);
            btn.classList.toggle('hidden', isHidden);
        }
        function hideUploadSection() {
            const card = document.getElementById('uploadCard');
            const btn = document.getElementById('uploadToggleBtn');
            if (card) card.classList.add('hidden');
            if (btn) btn.classList.remove('hidden');
        }

        async function setGuestEnabled(enabled) {
            const res = await api('/api/settings', { method: 'PATCH', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ guestEnabled: enabled }) });
            if (!res || !res.ok) return;
            guestEnabled = enabled;
            await fetchSettings();
        }

        async function setGuestMaxDuration(sec) {
            const n = parseInt(sec, 10);
            if (!Number.isFinite(n) || n < 1) return;
            await api('/api/settings', { method: 'PATCH', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ guestMaxDuration: n }) });
            guestMaxDuration = n;
            await fetchSettings();
        }

        async function setGuestCooldown(sec) {
            const n = parseInt(sec, 10);
            if (!Number.isFinite(n) || n < 0) return;
            await api('/api/settings', { method: 'PATCH', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ guestCooldownSec: n }) });
            guestCooldownSec = n;
            await fetchSettings();
        }

        async function setUserUploadEnabled(enabled) {
            const res = await api('/api/settings', { method: 'PATCH', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ userUploadEnabled: enabled }) });
            if (!res || !res.ok) return;
            userUploadEnabled = enabled;
            await fetchSettings();
            updateUploadCardVisibility();
        }

        async function setGuestUploadEnabled(enabled) {
            const res = await api('/api/settings', { method: 'PATCH', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ guestUploadEnabled: enabled }) });
            if (res && res.ok) { guestUploadEnabled = enabled; await fetchSettings(); updateUploadCardVisibility(); }
        }

        async function setGuestMaxUploadDuration(sec) {
            const n = parseInt(sec, 10);
            if (!Number.isFinite(n) || n < 1) return;
            await api('/api/settings', { method: 'PATCH', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ guestMaxUploadDuration: n }) });
            guestMaxUploadDuration = n;
            await fetchSettings();
        }

        async function setGuestMaxUploadBytes(kb) {
            const n = parseInt(kb, 10);
            if (!Number.isFinite(n) || n < 100) return;
            await api('/api/settings', { method: 'PATCH', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ guestMaxUploadBytes: n * 1024 }) });
            guestMaxUploadBytes = n * 1024;
            await fetchSettings();
        }

        async function setUserMaxDuration(sec) {
            const n = parseInt(sec, 10);
            if (!Number.isFinite(n) || n < 1) return;
            await api('/api/settings', { method: 'PATCH', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ userMaxDuration: n }) });
            userMaxDuration = n;
            await fetchSettings();
        }

        async function setUserCooldown(sec) {
            const n = parseInt(sec, 10);
            if (!Number.isFinite(n) || n < 0) return;
            await api('/api/settings', { method: 'PATCH', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ userCooldownSec: n }) });
            userCooldownSec = n;
            await fetchSettings();
        }

        async function setUserMaxUploadDuration(sec) {
            const n = parseInt(sec, 10);
            if (!Number.isFinite(n) || n < 1) return;
            await api('/api/settings', { method: 'PATCH', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ userMaxUploadDuration: n }) });
            userMaxUploadDuration = n;
            await fetchSettings();
        }

        async function setUserMaxUploadBytes(kb) {
            const n = parseInt(kb, 10);
            if (!Number.isFinite(n) || n < 100) return;
            await api('/api/settings', { method: 'PATCH', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ userMaxUploadBytes: n * 1024 }) });
            userMaxUploadBytes = n * 1024;
            await fetchSettings();
        }

        async function fetchGuestHistory() {
            const res = await api('/api/guest/history');
            if (!res || !res.ok) return;
            const history = await res.json();
            const tbody = document.getElementById('guestHistoryBody');
            if (!tbody) return;
            const esc = (x) => (x != null ? x : '').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
            tbody.innerHTML = history.slice(0, 100).map(h => {
                const dt = new Date(h.timestamp);
                const timeStr = dt.toLocaleString();
                const ip = esc(h.ip);
                return '<tr><td>' + ip + '</td><td>' + esc(timeStr) + '</td><td>' + esc(h.displayName || h.filename) + '</td><td><button type="button" class="btn btn-ghost block-btn" data-ip="' + ip + '" onclick="blockGuestIP(this.dataset.ip)">Block</button></td></tr>';
            }).join('');
        }

        async function fetchBlockedIPs() {
            const res = await api('/api/guest/blocked');
            if (!res || !res.ok) return;
            const ips = await res.json();
            const el = document.getElementById('blockedIPsList');
            if (!el) return;
            const esc = (x) => (x != null ? x : '').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
            if (ips.length === 0) { el.innerHTML = '<span style="color:var(--text-muted)">None</span>'; return; }
            el.innerHTML = ips.map(ip => '<div class="ip-row"><span>' + esc(ip) + '</span><button type="button" class="btn btn-ghost block-btn" data-ip="' + esc(ip) + '" onclick="unblockGuestIP(this.dataset.ip)">Unblock</button></div>').join('');
        }

        async function blockGuestIP(ip) {
            const res = await api('/api/guest/block-ip', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ ip }) });
            if (res && res.ok) fetchBlockedIPs();
        }

        async function unblockGuestIP(ip) {
            const res = await api('/api/guest/block-ip/' + encodeURIComponent(ip), { method: 'DELETE' });
            if (res && res.ok) fetchBlockedIPs();
        }

        function updatePendingBadge(uploads, signups) {
            const total = (uploads || 0) + (signups || 0);
            const badge = document.getElementById('pendingBadge');
            const headerBadge = document.getElementById('headerPendingBadge');
            const hamburgerBtn = document.getElementById('headerHamburgerBtn');
            const usersTabBadge = document.getElementById('superadminTabUsersBadge');
            const moderationTabBadge = document.getElementById('superadminTabModerationBadge');
            if (badge) {
                if (total > 0) {
                    badge.textContent = total > 99 ? '99+' : String(total);
                    badge.classList.remove('hidden');
                } else {
                    badge.classList.add('hidden');
                }
            }
            if (headerBadge) {
                if (total > 0) {
                    const parts = [];
                    if ((uploads || 0) > 0) parts.push((uploads > 99 ? '99+' : uploads) + ' upload' + (uploads === 1 ? '' : 's'));
                    if ((signups || 0) > 0) parts.push((signups > 99 ? '99+' : signups) + ' signup' + (signups === 1 ? '' : 's'));
                    headerBadge.textContent = (uploads || 0) > 0 && (signups || 0) > 0 ? (uploads > 99 ? '99+' : uploads) + '‚Üë ' + (signups > 99 ? '99+' : signups) + 'üë§' : (uploads || 0) > 0 ? (uploads > 99 ? '99+' : uploads) + '‚Üë' : (signups > 99 ? '99+' : signups) + 'üë§';
                    headerBadge.classList.remove('hidden');
                } else {
                    headerBadge.classList.add('hidden');
                }
            }
            if (hamburgerBtn) {
                const parts = [];
                if ((uploads || 0) > 0) parts.push((uploads > 99 ? '99+' : uploads) + ' pending upload' + (uploads === 1 ? '' : 's'));
                if ((signups || 0) > 0) parts.push((signups > 99 ? '99+' : signups) + ' pending signup' + (signups === 1 ? '' : 's'));
                hamburgerBtn.title = total > 0 ? (parts.length ? parts.join(', ') : 'Menu') : 'Menu';
            }
            if (usersTabBadge) {
                if ((signups || 0) > 0) {
                    usersTabBadge.textContent = signups > 99 ? '99+' : String(signups);
                    usersTabBadge.classList.remove('hidden');
                } else {
                    usersTabBadge.classList.add('hidden');
                }
            }
            if (moderationTabBadge) {
                if ((uploads || 0) > 0) {
                    moderationTabBadge.textContent = uploads > 99 ? '99+' : String(uploads);
                    moderationTabBadge.classList.remove('hidden');
                } else {
                    moderationTabBadge.classList.add('hidden');
                }
            }
        }
        function toggleHeaderMenu() {
            const menu = document.getElementById('headerMenu');
            if (!menu) return;
            menu.classList.toggle('hidden');
            if (!menu.classList.contains('hidden')) {
                if ((user && user.role) === 'superadmin') fetchPendingCount();
                setTimeout(function() { document.addEventListener('click', closeHeaderMenuOnClick); }, 0);
            } else {
                document.removeEventListener('click', closeHeaderMenuOnClick);
            }
        }
        function closeHeaderMenuOnClick(e) {
            const menu = document.getElementById('headerMenu');
            const btn = document.getElementById('headerHamburgerBtn');
            if (menu && btn && !menu.contains(e.target) && !btn.contains(e.target)) closeHeaderMenu();
        }
        function closeHeaderMenu() {
            const menu = document.getElementById('headerMenu');
            if (menu) menu.classList.add('hidden');
            document.removeEventListener('click', closeHeaderMenuOnClick);
        }

        async function fetchPendingCount() {
            if ((user && user.role) !== 'superadmin') return;
            const res = await api('/api/superadmin/pending-count');
            if (!res || !res.ok) return;
            const d = await res.json().catch(() => ({}));
            const uploads = d.count != null ? d.count : 0;
            const signups = d.pendingSignupsCount != null ? d.pendingSignupsCount : 0;
            updatePendingBadge(uploads, signups);
        }

        async function fetchPendingUploads() {
            const res = await api('/api/superadmin/pending-uploads');
            if (!res || !res.ok) return;
            const uploads = await res.json();
            fetchPendingCount();
            const tbody = document.getElementById('pendingUploadsBody');
            const empty = document.getElementById('pendingUploadsEmpty');
            if (!tbody || !empty) return;
            const esc = (x) => (x != null ? x : '').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
            if (uploads.length === 0) {
                tbody.innerHTML = '';
                empty.classList.remove('hidden');
                return;
            }
            empty.classList.add('hidden');
            tbody.innerHTML = uploads.map(u => {
                const dt = new Date(u.uploadedAt);
                const by = u.uploadedBy || (u.uploadedByIP ? 'guest' : '?');
                const dur = u.duration != null ? u.duration.toFixed(1) + 's' : '‚Äî';
                const sz = u.size != null ? Math.round(u.size / 1024) + 'KB' : '‚Äî';
                return '<tr><td><a href="/api/superadmin/pending-uploads/audio/' + encodeURIComponent(u.filename) + '" target="_blank" rel="noopener" style="color:var(--accent)">' + esc(u.filename) + '</a> <span style="color:var(--text-muted);font-size:0.8em">' + dur + ' ' + sz + '</span></td><td>' + esc(by) + '</td><td>' + esc(dt.toLocaleString()) + '</td><td><button type="button" class="btn btn-primary block-btn" data-filename="' + esc(u.filename) + '" onclick="approvePendingUpload(this.dataset.filename)">Approve</button> <button type="button" class="btn btn-danger block-btn" data-filename="' + esc(u.filename) + '" onclick="rejectPendingUpload(this.dataset.filename)">Reject</button></td></tr>';
            }).join('');
        }

        async function approvePendingUpload(filename) {
            const res = await api('/api/superadmin/pending-uploads/approve/' + encodeURIComponent(filename), { method: 'POST' });
            if (res && res.ok) { fetchPendingUploads(); fetchSounds(); }
            else if (res) { const d = await res.json().catch(() => ({})); alert(d.error || 'Failed'); }
        }

        async function rejectPendingUpload(filename) {
            const res = await api('/api/superadmin/pending-uploads/reject/' + encodeURIComponent(filename), { method: 'DELETE' });
            if (res && res.ok) fetchPendingUploads();
        }

        async function fetchPendingSignups() {
            const res = await api('/api/superadmin/pending-signups');
            if (!res || !res.ok) return;
            const signups = await res.json();
            fetchPendingCount();
            const tbody = document.getElementById('pendingSignupsBody');
            const empty = document.getElementById('pendingSignupsEmpty');
            if (!tbody || !empty) return;
            const esc = (x) => (x != null ? x : '').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
            if (signups.length === 0) {
                tbody.innerHTML = '';
                empty.classList.remove('hidden');
                return;
            }
            empty.classList.add('hidden');
            tbody.innerHTML = signups.map(u => {
                const dt = u.createdAt ? new Date(u.createdAt) : null;
                const timeStr = dt ? dt.toLocaleString() : '‚Äî';
                return '<tr data-username="' + esc(u.username) + '"><td>' + esc(u.username) + '</td><td>' + esc(timeStr) + '</td><td><select class="approve-role-select" style="padding:0.25rem;font-size:0.85rem;background:var(--surface-hover);border:1px solid var(--border);border-radius:var(--radius-sm);color:var(--text)"><option value="user">User</option><option value="admin">Admin</option></select></td><td><button type="button" class="btn btn-primary block-btn" onclick="approvePendingSignup(this.closest(\'tr\').dataset.username, this.closest(\'tr\').querySelector(\'.approve-role-select\').value)">Approve</button> <button type="button" class="btn btn-danger block-btn" onclick="rejectPendingSignup(this.closest(\'tr\').dataset.username)">Reject</button></td></tr>';
            }).join('');
        }

        async function approvePendingSignup(username, role) {
            const res = await api('/api/superadmin/pending-signups/approve/' + encodeURIComponent(username), { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ role: role || 'user' }) });
            if (res && res.ok) { fetchPendingSignups(); fetchUsers(); }
            else if (res) { const d = await res.json().catch(() => ({})); alert(d.error || 'Failed'); }
        }

        async function rejectPendingSignup(username) {
            const res = await api('/api/superadmin/pending-signups/reject/' + encodeURIComponent(username), { method: 'POST' });
            if (res && res.ok) fetchPendingSignups();
        }

        async function fetchUsers() {
            const res = await api('/api/superadmin/users');
            if (!res || !res.ok) return;
            const users = await res.json();
            const tbody = document.getElementById('usersListBody');
            const empty = document.getElementById('usersListEmpty');
            if (!tbody || !empty) return;
            const esc = (x) => (x != null ? x : '').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
            if (users.length === 0) {
                tbody.innerHTML = '';
                empty.classList.remove('hidden');
                return;
            }
            empty.classList.add('hidden');
            tbody.innerHTML = users.map(u => {
                const roleLabel = u.role === 'superadmin' ? 'Superadmin' : (u.role === 'admin' ? 'Admin' : 'User');
                const managed = u.managed === true;
                let actions = '';
                if (managed) {
                    const roleOpts = '<option value="user"' + (u.role === 'user' ? ' selected' : '') + '>User</option><option value="admin"' + (u.role === 'admin' ? ' selected' : '') + '>Admin</option>';
                    actions = '<select class="user-role-select" data-username="' + esc(u.username) + '" style="padding:0.25rem;font-size:0.85rem;background:var(--surface-hover);border:1px solid var(--border);border-radius:var(--radius-sm);color:var(--text);margin-right:0.35rem" onchange="updateUserRole(this.dataset.username, this.value)">' + roleOpts + '</select><button type="button" class="btn btn-ghost block-btn" data-username="' + esc(u.username) + '" onclick="resetUserPassword(this.dataset.username)" title="Reset password">Reset PW</button> <button type="button" class="btn btn-danger block-btn" data-username="' + esc(u.username) + '" onclick="deleteUser(this.dataset.username)">Delete</button>';
                } else {
                    actions = '<span style="color:var(--text-muted);font-size:0.8em">(env)</span>';
                }
                return '<tr><td>' + esc(u.username) + '</td><td>' + esc(roleLabel) + '</td><td>' + actions + '</td></tr>';
            }).join('');
        }

        async function updateUserRole(username, role) {
            const res = await api('/api/superadmin/users/' + encodeURIComponent(username), { method: 'PATCH', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ role }) });
            if (res && res.ok) fetchUsers();
            else if (res) { const d = await res.json().catch(() => ({})); alert(d.error || 'Failed'); }
        }

        async function resetUserPassword(username) {
            const newPw = prompt('New password for ' + username + ' (min 6 characters):');
            if (newPw == null) return;
            if (newPw.length < 6) { alert('Password must be at least 6 characters'); return; }
            const forceChange = confirm('Force user to change password on next login?');
            const res = await api('/api/superadmin/users/' + encodeURIComponent(username), { method: 'PATCH', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ password: newPw, forceChange }) });
            if (res && res.ok) { fetchUsers(); alert('Password updated.'); }
            else if (res) { const d = await res.json().catch(() => ({})); alert(d.error || 'Failed'); }
        }

        async function deleteUser(username) {
            if (!confirm('Remove user "' + username + '"? They will no longer be able to log in.')) return;
            const res = await api('/api/superadmin/users/' + encodeURIComponent(username), { method: 'DELETE' });
            if (res && res.ok) fetchUsers();
            else if (res) { const d = await res.json().catch(() => ({})); alert(d.error || 'Failed'); }
        }

        async function setPlaybackLocked(locked) {
            const res = await api('/api/settings', { method: 'PATCH', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ playbackLocked: locked }) });
            if (!res || !res.ok) return;
            playbackLocked = locked;
            await fetchSettings();
            if ((user && user.role) === 'user' || (user && user.role) === 'guest') fetchSounds();
        }

        async function setPlaybackSuperadminOnly(locked) {
            const res = await api('/api/settings', { method: 'PATCH', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ playbackSuperadminOnly: locked }) });
            if (!res || !res.ok) return;
            playbackSuperadminOnly = locked;
            await fetchSettings();
            fetchSounds();
        }

        function getGuestCooldownRemaining() {
            if ((user && user.role) !== 'guest') return 0;
            const elapsed = (Date.now() - guestLastPlayTime) / 1000;
            return Math.max(0, Math.ceil((guestCooldownSec || 10) - elapsed));
        }
        function getUserCooldownRemaining() {
            if ((user && user.role) !== 'user') return 0;
            const elapsed = (Date.now() - userLastPlayTime) / 1000;
            return Math.max(0, Math.ceil((userCooldownSec || 0) - elapsed));
        }

        function toggleReorder() {
            if (selectedTag != null) { alert('Switch to "All" to reorder sounds.'); return; }
            reorderMode = !reorderMode;
            const btn = document.getElementById('reorderBtn');
            const grid = document.getElementById('soundsList');
            if (btn) btn.classList.toggle('active', reorderMode);
            if (grid) grid.classList.toggle('reorder-mode', reorderMode);
            renderSoundsGrid();
        }

        function setupSoundGridDragDrop(grid) {
            if (!grid || grid.dataset.dragSetup) return;
            grid.dataset.dragSetup = '1';
            grid.addEventListener('dragstart', (e) => {
                if (!reorderMode) return;
                const wrap = e.target.closest('.sound-item-wrap');
                if (!wrap) return;
                e.dataTransfer.setData('text/plain', wrap.dataset.filename || '');
                e.dataTransfer.effectAllowed = 'move';
                e.stopPropagation();
                wrap.classList.add('dragging');
            });
            grid.addEventListener('dragend', (e) => {
                const siw = e.target.closest('.sound-item-wrap'); if (siw) siw.classList.remove('dragging');
                grid.querySelectorAll('.sound-item-wrap').forEach(el => el.classList.remove('drag-over'));
            });
            grid.addEventListener('dragover', (e) => {
                if (!reorderMode) return;
                e.preventDefault();
                e.stopPropagation();
                e.dataTransfer.dropEffect = 'move';
                const wrap = e.target.closest('.sound-item-wrap');
                grid.querySelectorAll('.sound-item-wrap').forEach(el => el.classList.remove('drag-over'));
                if (wrap) wrap.classList.add('drag-over');
            });
            grid.addEventListener('drop', async (e) => {
                if (!reorderMode) return;
                e.preventDefault();
                e.stopPropagation();
                const fromFilename = e.dataTransfer.getData('text/plain');
                const toWrap = e.target.closest('.sound-item-wrap');
                grid.querySelectorAll('.sound-item-wrap').forEach(el => el.classList.remove('drag-over'));
                if (!fromFilename || !toWrap) return;
                const wraps = [...grid.querySelectorAll('.sound-item-wrap')];
                const fromIdx = wraps.findIndex(w => w.dataset.filename === fromFilename);
                const toIdx = wraps.findIndex(w => w === toWrap);
                if (fromIdx === -1 || toIdx === -1 || fromIdx === toIdx) return;
                const order = wraps.map(w => w.dataset.filename);
                const [removed] = order.splice(fromIdx, 1);
                order.splice(toIdx, 0, removed);
                const res = await api('/api/sounds/order', { method: 'PATCH', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ order }) });
                if (res && res.ok) fetchSounds();
            });
        }

        async function fetchTags() {
            const res = await api('/api/tags');
            if (!res || !res.ok) return;
            const d = await res.json();
            tagsList = d.tags || [];
            hiddenTags = d.hidden || [];
            const prefs = loadPrefs();
            if (prefs.lastTag != null && (prefs.lastTag === UNTAGGED_FILTER || tagsList.includes(prefs.lastTag))) selectedTag = prefs.lastTag;
            renderTagTabs();
        }

        function renderTagTabs() {
            const container = document.getElementById('tagTabs');
            const isAdmin = isAdminOrSuperadmin();
            const showManage = isAdmin && manageTagsMode;
            const esc = (x) => (x != null ? x : '').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
            const visibleTags = showManage ? (tagsList || []) : (tagsList || []).filter(t => !hiddenTags.includes(t));
            let html = '<button type="button" class="tag-tab' + (selectedTag === null ? ' active' : '') + '" data-tag="" onclick="selectTag(null)">All</button>';
            html += '<button type="button" class="tag-tab' + (selectedTag === UNTAGGED_FILTER ? ' active' : '') + '" data-tag="' + UNTAGGED_FILTER + '" onclick="selectTag(\'' + UNTAGGED_FILTER + '\')" title="Sounds with no tag">No tag</button>';
            visibleTags.forEach(t => {
                const active = selectedTag === t;
                const isHidden = hiddenTags.includes(t);
                if (showManage) {
                    html += '<div class="tag-tab-wrap" data-tag="' + esc(t) + '" draggable="true">';
                    html += '<button type="button" class="tag-tab' + (active ? ' active' : '') + (isHidden ? ' hidden-tag' : '') + '" data-tag="' + esc(t) + '" onclick="selectTag(this.dataset.tag)" ondblclick="event.preventDefault(); startRenameTag(this.dataset.tag)" title="Double-click to rename">' + esc(t) + '</button>';
                    html += '<button type="button" class="tag-tab" data-tag="' + esc(t) + '" onclick="event.stopPropagation(); toggleTagHidden(this.dataset.tag)" title="' + (isHidden ? 'Show' : 'Hide') + '">' + (isHidden ? 'üëÅ‚Äçüó®' : 'üëÅ') + '</button>';
                    html += '<button type="button" class="tag-tab delete" data-tag="' + esc(t) + '" onclick="event.stopPropagation(); deleteTag(this.dataset.tag)" title="Delete tag">‚úï</button>';
                    html += '</div>';
                } else {
                    html += '<button type="button" class="tag-tab' + (active ? ' active' : '') + '" data-tag="' + esc(t) + '" onclick="selectTag(this.dataset.tag)">' + esc(t) + '</button>';
                }
            });
            container.innerHTML = html;
            container.classList.toggle('manage-mode', showManage);
            const mtb = document.getElementById('manageTagsBtn'); if (mtb) mtb.classList.toggle('active', manageTagsMode);
            const ta = document.getElementById('tagsAdmin'); if (ta) ta.classList.toggle('hidden', !showManage);
            if (showManage) setupTagTabDragDrop(container);
        }

        function setupTagTabDragDrop(container) {
            container.addEventListener('dragstart', (e) => {
                const wrap = e.target.closest('.tag-tab-wrap');
                if (!wrap) return;
                e.dataTransfer.setData('text/plain', wrap.dataset.tag || '');
                e.dataTransfer.effectAllowed = 'move';
                e.stopPropagation();
                wrap.classList.add('dragging');
            });
            container.addEventListener('dragend', (e) => {
                const ttw = e.target.closest('.tag-tab-wrap'); if (ttw) ttw.classList.remove('dragging');
                container.querySelectorAll('.tag-tab-wrap').forEach(el => el.classList.remove('drag-over'));
            });
            container.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.stopPropagation();
                e.dataTransfer.dropEffect = 'move';
                const wrap = e.target.closest('.tag-tab-wrap');
                container.querySelectorAll('.tag-tab-wrap').forEach(el => el.classList.remove('drag-over'));
                if (wrap) wrap.classList.add('drag-over');
            });
            container.addEventListener('drop', async (e) => {
                e.preventDefault();
                e.stopPropagation();
                const fromName = e.dataTransfer.getData('text/plain');
                const toWrap = e.target.closest('.tag-tab-wrap');
                container.querySelectorAll('.tag-tab-wrap').forEach(el => el.classList.remove('drag-over'));
                if (!fromName || !toWrap) return;
                const wraps = [...container.querySelectorAll('.tag-tab-wrap')];
                const fromIdx = wraps.findIndex(w => w.dataset.tag === fromName);
                const toIdx = wraps.findIndex(w => w === toWrap);
                if (fromIdx === -1 || toIdx === -1 || fromIdx === toIdx) return;
                const order = wraps.map(w => w.dataset.tag);
                const [removed] = order.splice(fromIdx, 1);
                order.splice(toIdx, 0, removed);
                const res = await api('/api/tags', { method: 'PATCH', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ tags: order }) });
                if (res && res.ok) { const d = await res.json(); tagsList = d.tags || tagsList; renderTagTabs(); fetchSounds(); }
            });
        }

        function toggleManageTags() {
            manageTagsMode = !manageTagsMode;
            renderTagTabs();
        }

        function startRenameTag(currentName) {
            const container = document.getElementById('tagTabs');
            const wrap = container ? [...container.querySelectorAll('.tag-tab-wrap')].find(w => w.dataset.tag === currentName) : null;
            if (!wrap) return;
            const tabBtn = wrap.querySelector('.tag-tab:not(.delete)');
            if (!tabBtn) return;
            const input = document.createElement('input');
            input.type = 'text';
            input.className = 'tag-tab-rename';
            input.value = currentName;
            tabBtn.style.display = 'none';
            wrap.insertBefore(input, tabBtn);
            input.focus();
            input.select();
            function finish() {
                const newName = input.value.trim();
                input.remove();
                tabBtn.style.display = '';
                if (newName && newName !== currentName) {
                    api('/api/tags/rename', { method: 'PATCH', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ oldName: currentName, newName }) }).then(async (res) => {
                        if (res && res.ok) {
                            await fetchTags();
                            if (selectedTag === currentName) selectedTag = newName;
                            renderTagTabs();
                            fetchSounds();
                        }
                    });
                }
            }
            input.addEventListener('blur', finish);
            input.addEventListener('keydown', (e) => { if (e.key === 'Enter') finish(); if (e.key === 'Escape') { input.value = currentName; finish(); } });
        }

        async function toggleTagHidden(tag) {
            const isHidden = hiddenTags.includes(tag);
            const res = await api('/api/tags/' + encodeURIComponent(tag) + '/hidden', { method: 'PATCH', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ hidden: !isHidden }) });
            if (res && res.ok) { await fetchTags(); renderTagTabs(); }
        }

        function selectTag(tag) {
            selectedTag = tag || null;
            savePrefs({ lastTag: selectedTag });
            if (mobileView) mobilePageIndex = 0;
            renderTagTabs();
            renderSoundsGrid();
        }

        async function deleteTag(name) {
            if (!confirm('Delete tag "' + name + '"? It will be removed from all sounds.')) return;
            const res = await api('/api/tags/' + encodeURIComponent(name), { method: 'DELETE' });
            if (!res || !res.ok) return;
            tagsList = (tagsList || []).filter(t => t !== name);
            if (selectedTag === name) selectedTag = null;
            renderTagTabs();
            fetchSounds();
        }

        async function fetchSounds() {
            const res = await api('/api/sounds');
            if (!res || !res.ok) return;
            const data = await res.json();
            soundsList = Array.isArray(data) ? data : (data.list || []);
            if (data && !Array.isArray(data)) {
                if (Array.isArray(data.tags)) tagsList = data.tags;
                if (Array.isArray(data.hidden)) hiddenTags = data.hidden;
                const prefs = loadPrefs();
                if (prefs.lastTag != null && (prefs.lastTag === UNTAGGED_FILTER || tagsList.includes(prefs.lastTag))) selectedTag = prefs.lastTag;
                renderTagTabs();
            }
            renderSoundsGrid();
        }

        function renderSoundsGrid() {
            const grid = document.getElementById('soundsList');
            const filtered = getFilteredSounds();
            const isUser = (user && user.role) === 'user';
            const isGuest = (user && user.role) === 'guest';
            const guestCooldown = getGuestCooldownRemaining();
            const userCooldown = getUserCooldownRemaining();
            const adminPlaying = (playback.status === 'playing' || playback.status === 'paused') && ((playback.startedBy && playback.startedBy.role) === 'admin' || (playback.startedBy && playback.startedBy.role) === 'superadmin');
            const superadminPlaying = (playback.status === 'playing' || playback.status === 'paused') && (playback.startedBy && playback.startedBy.role) === 'superadmin';
            const cannotOverride = ((isUser || isGuest) && adminPlaying) || ((user && user.role) === 'admin' && superadminPlaying);
            const canPlay = ((!isUser && !isGuest) && !((user && user.role) === 'admin' && superadminPlaying)) || ((!playbackLocked && !playbackSuperadminOnly) && (isGuest ? guestCooldown === 0 : userCooldown === 0) && !cannotOverride);
            const maxDur = isGuest ? (guestMaxDuration || 7) : (userMaxDuration || 7);
            const tooLong = (dur) => (isUser || isGuest) && dur != null && dur > maxDur;
            const isAdmin = isAdminOrSuperadmin();
            grid.innerHTML = filtered.map((s, idx) => {
                const esc = (x) => (x != null ? x : '').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#39;');
                const name = esc(s.displayName || s.filename);
                const filename = esc(s.filename);
                const dur = s.duration;
                const disabled = !canPlay || tooLong(dur);
                const selected = selectedSound === s.filename ? ' sound-item-selected' : '';
                let title = '';
                if (!canPlay) title = cannotOverride ? (superadminPlaying && (user && user.role) === 'admin' ? 'A superadmin is playing. You cannot override.' : 'An admin or superadmin is playing. You cannot override.') : (playbackSuperadminOnly ? 'Only superadmin can play.' : (playbackLocked ? 'Playback is locked' : ((isGuest && guestCooldown > 0) || (isUser && userCooldown > 0) ? 'Wait ' + (isGuest ? guestCooldown : userCooldown) + 's before playing again' : 'Cannot play')));
                else if (tooLong(dur)) title = 'Only sounds ' + maxDur + 's or shorter allowed';
                const editBtn = isAdmin && !reorderMode ? `<button type="button" class="sound-edit" data-filename="${filename}" title="Edit sound" onclick="event.stopPropagation(); openSoundPanelFromSound(this.dataset.filename)"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/></svg></button>` : '';
                const favIdx = getFavorites().indexOf(s.filename);
                const favActive = favIdx >= 0 ? ' active' : '';
                const favTitle = favIdx >= 0 ? `Favorite slot ${favIdx + 1} (click to remove)` : 'Add to favorites (1‚Äì9)';
                const favBtn = `<button type="button" class="sound-fav${favActive}" data-filename="${filename}" title="${favTitle}" onclick="event.stopPropagation(); toggleFavorite(this.dataset.filename)"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linejoin="round"><polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"/></svg></button>`;
                const favorited = favIdx >= 0 ? ' favorited' : '';
                const color = (s.color && /^#[0-9a-fA-F]{6}$/.test(s.color)) ? s.color : '';
                const colorDot = color ? '<span class="sound-color-dot" style="background:' + color + '"></span>' : '';
                const inner = `
                    <div class="sound-item${selected}${favorited}" data-filename="${filename}" data-index="${idx}">
                        ${colorDot}
                        <span class="sound-drag-handle" data-filename="${filename}" title="Drag to reorder">‚ãÆ‚ãÆ</span>
                        <button type="button" class="sound-btn ${disabled ? 'disabled' : ''}" data-filename="${filename}" data-displayname="${name}" data-duration="${dur != null ? dur : ''}" data-tags="${esc((s.tags || []).join(', '))}" ${disabled ? 'disabled' : ''} title="${title}" onclick="playSound(this.dataset.filename)">
                            <span class="sound-btn-label">${name}</span>
                            <span class="sound-btn-duration">${dur != null ? formatTime(dur) : '‚Äî'}</span>
                        </button>
                        <div class="sound-item-actions">
                            ${favBtn}
                            <button type="button" class="sound-preview" data-filename="${filename}" title="Preview (play locally)" onclick="event.stopPropagation(); previewSound(this.dataset.filename, this)"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M5 3l14 9-14 9V3z"/></svg></button>
                            ${editBtn}
                        </div>
                    </div>`;
                return `<div class="sound-item-wrap" data-filename="${filename}" ${reorderMode && isAdmin ? 'draggable="true"' : ''}>${inner}</div>`;
            }).join('');
            grid.classList.toggle('reorder-mode', reorderMode);
            grid.classList.toggle('compact-mode', compactMode);
            renderFavoritesBar();
            if (mobileView) renderMobileGrid();
            const msg = document.getElementById('userLockedMsg');
            const showLocked = playbackSuperadminOnly ? (isUser || isGuest || (user && user.role === 'admin')) : (isUser || isGuest) && playbackLocked;
            const showOverrideBlocked = cannotOverride && (playback.status === 'playing' || playback.status === 'paused');
            if (msg) {
                if (showOverrideBlocked) {
                    msg.textContent = superadminPlaying && (user && user.role) === 'admin' ? 'A superadmin is playing. You cannot override.' : 'An admin or superadmin is playing. You cannot override.';
                    msg.classList.remove('hidden');
                } else if (showLocked) {
                    msg.textContent = playbackSuperadminOnly ? 'Only superadmin can play.' : (playbackLockedBy === 'superadmin' ? 'Playback is locked by a superadmin.' : 'Playback is locked by an admin.');
                    msg.classList.remove('hidden');
                } else {
                    msg.classList.add('hidden');
                }
            }
        }

        function editSoundName(btn) {
            openSoundPanelFromSound(btn.dataset.filename);
        }

        function getAllTagsForAutocomplete() {
            const fromList = new Set(tagsList || []);
            (soundsList || []).forEach(s => { (s.tags || []).forEach(t => fromList.add(t)); });
            return [...fromList].sort();
        }

        function setupTagsAutocomplete(tagsEl) {
            if (!tagsEl) return;
            const suggestionsEl = document.getElementById('soundPanelTagsSuggestions');
            if (!suggestionsEl) return;
            let selectedIdx = -1;
            let hideTimeout = null;

            function getCurrentToken() {
                const val = tagsEl.value || '';
                const sep = /[,\s]/;
                let i = val.length - 1;
                while (i >= 0 && !sep.test(val[i])) i--;
                return val.slice(i + 1).toLowerCase();
            }

            function getPrefix() {
                const val = tagsEl.value || '';
                const sep = /[,\s]/;
                let i = val.length - 1;
                while (i >= 0 && !sep.test(val[i])) i--;
                return val.slice(0, i + 1);
            }

            function showSuggestions() {
                const token = getCurrentToken();
                const all = getAllTagsForAutocomplete();
                const matches = token ? all.filter(t => t.toLowerCase().startsWith(token) && t.toLowerCase() !== token) : all.slice(0, 10);
                selectedIdx = -1;
                if (matches.length === 0) {
                    suggestionsEl.classList.add('hidden');
                    suggestionsEl.innerHTML = '';
                    return;
                }
                suggestionsEl.innerHTML = matches.map((t, i) => `<div class="tag-suggestion" data-tag="${(t || '').replace(/"/g, '&quot;')}" data-idx="${i}">${(t || '').replace(/&/g, '&amp;').replace(/</g, '&lt;')}</div>`).join('');
                suggestionsEl.classList.remove('hidden');
                suggestionsEl.querySelectorAll('.tag-suggestion').forEach(el => {
                    el.addEventListener('click', () => {
                        applySuggestion(el.dataset.tag);
                        suggestionsEl.classList.add('hidden');
                    });
                });
            }

            function applySuggestion(tag) {
                const prefix = getPrefix();
                const sep = prefix && !/[,\s]$/.test(prefix) ? ', ' : '';
                tagsEl.value = prefix + sep + tag + ', ';
                tagsEl.focus();
                showSuggestions();
            }

            function hideSuggestions() {
                hideTimeout = setTimeout(() => suggestionsEl.classList.add('hidden'), 150);
            }

            tagsEl.removeEventListener('input', tagsEl._acInput);
            tagsEl.removeEventListener('keydown', tagsEl._acKeydown);
            tagsEl.removeEventListener('focus', tagsEl._acFocus);
            tagsEl.removeEventListener('blur', tagsEl._acBlur);

            tagsEl._acInput = () => { clearTimeout(hideTimeout); showSuggestions(); };
            tagsEl._acKeydown = (e) => {
                if (suggestionsEl.classList.contains('hidden')) return;
                const items = suggestionsEl.querySelectorAll('.tag-suggestion');
                if (e.key === 'ArrowDown') { e.preventDefault(); selectedIdx = Math.min(selectedIdx + 1, items.length - 1); items.forEach((el, i) => el.classList.toggle('selected', i === selectedIdx)); return; }
                if (e.key === 'ArrowUp') { e.preventDefault(); selectedIdx = Math.max(selectedIdx - 1, -1); items.forEach((el, i) => el.classList.toggle('selected', i === selectedIdx)); return; }
                if (e.key === 'Enter' && selectedIdx >= 0 && items[selectedIdx]) { e.preventDefault(); applySuggestion(items[selectedIdx].dataset.tag); suggestionsEl.classList.add('hidden'); return; }
                if (e.key === 'Escape') { e.preventDefault(); suggestionsEl.classList.add('hidden'); }
            };
            tagsEl._acFocus = () => { clearTimeout(hideTimeout); showSuggestions(); };
            tagsEl._acBlur = () => hideSuggestions();

            tagsEl.addEventListener('input', tagsEl._acInput);
            tagsEl.addEventListener('keydown', tagsEl._acKeydown);
            tagsEl.addEventListener('focus', tagsEl._acFocus);
            tagsEl.addEventListener('blur', tagsEl._acBlur);
        }

        let soundPanelWaveformData = null;
        let soundPanelWaveformDuration = 0;
        let soundPanelStartTime = 0;
        let soundPanelEndTime = null;
        let soundPanelPreviewAudio = null;
        let soundPanelPreviewPlayheadTime = null;

        function openSoundPanel(s) {
            if (soundPanelPreviewAudio) {
                soundPanelPreviewAudio.pause();
                soundPanelPreviewAudio = null;
                soundPanelPreviewPlayheadTime = null;
                const btn = document.getElementById('soundPanelPreviewBtn');
                if (btn) btn.textContent = '‚ñ∂ Preview';
            }
            const panel = document.getElementById('soundPanel');
            const nameEl = document.getElementById('soundPanelName');
            const tagsEl = document.getElementById('soundPanelTags');
            const durEl = document.getElementById('soundPanelDuration');
            const volEl = document.getElementById('soundPanelVolume');
            const volLabel = document.getElementById('soundPanelVolumeLabel');
            const customEl = document.getElementById('soundPanelColorCustom');
            const presetsEl = document.getElementById('soundPanelColorPresets');
            if (!panel || !nameEl || !tagsEl) return;
            nameEl.value = (s && (s.displayName || s.filename)) || '';
            nameEl.dataset.filename = (s && s.filename) || '';
            tagsEl.value = (s && (s.tags || []).join(', ')) || '';
            durEl.textContent = (s && s.duration != null) ? formatTime(s.duration) : '‚Äî';
            const vol = (s && typeof s.volume === 'number') ? Math.max(0, Math.min(2, s.volume)) : 1;
            if (volEl) { volEl.value = String(vol); volEl.dispatchEvent(new Event('input')); }
            if (volLabel) volLabel.textContent = Math.round(vol * 100) + '%';
            soundPanelStartTime = (s && typeof s.startTime === 'number' && s.startTime >= 0) ? s.startTime : 0;
            soundPanelEndTime = (s && typeof s.endTime === 'number' && s.endTime > 0) ? s.endTime : null;
            const color = (s && s.color && /^#[0-9a-fA-F]{6}$/.test(s.color)) ? s.color : '';
            if (presetsEl) {
                presetsEl.innerHTML = SOUND_COLOR_PRESETS.map(function(hex) {
                    var sel = (color === hex) ? ' selected' : '';
                    return '<button type="button" class="sound-color-preset' + sel + '" style="background:' + hex + '" data-color="' + hex + '" onclick="selectSoundPanelColor(this.dataset.color)" title="' + hex + '"></button>';
                }).join('');
            }
            if (customEl) customEl.value = color || '#7c3aed';
            panel.dataset.soundColor = color || '';
            panel.classList.remove('hidden');
            setupTagsAutocomplete(tagsEl);
            if (s && s.filename) loadSoundPanelWaveform(s.filename);
            const volInput = document.getElementById('soundPanelVolume');
            if (volInput && !volInput.dataset.bound) {
                volInput.dataset.bound = '1';
                volInput.addEventListener('input', () => {
                    const v = parseFloat(volInput.value) || 1;
                    const lbl = document.getElementById('soundPanelVolumeLabel');
                    if (lbl) lbl.textContent = Math.round(v * 100) + '%';
                });
            }
        }

        async function loadSoundPanelWaveform(filename) {
            soundPanelWaveformData = null;
            soundPanelWaveformDuration = 0;
            const wrap = document.getElementById('soundPanelWaveformWrap');
            const canvas = document.getElementById('soundPanelWaveform');
            if (!wrap || !canvas) return;
            try {
                const res = await fetch('/api/sounds/audio/' + encodeURIComponent(filename), { credentials: CREDENTIALS });
                if (!res.ok) return;
                const buf = await res.arrayBuffer();
                const ctx = new (window.AudioContext || window.webkitAudioContext)();
                const decoded = await ctx.decodeAudioData(buf);
                const ch = decoded.getChannelData(0);
                const duration = decoded.duration;
                const bars = 300;
                const step = Math.floor(ch.length / bars);
                const peaks = [];
                for (let i = 0; i < bars; i++) {
                    let min = 0, max = 0;
                    for (let j = 0; j < step; j++) {
                        const v = ch[i * step + j];
                        if (v < min) min = v;
                        if (v > max) max = v;
                    }
                    peaks.push({ min, max });
                }
                soundPanelWaveformData = peaks;
                soundPanelWaveformDuration = duration;
                drawSoundPanelWaveform();
                setupSoundPanelTrimHandles();
            } catch (e) { console.warn('Sound panel waveform load failed', e); }
        }

        function drawSoundPanelWaveform() {
            const canvas = document.getElementById('soundPanelWaveform');
            const wrap = document.getElementById('soundPanelWaveformWrap');
            if (!canvas || !wrap || !soundPanelWaveformData || !soundPanelWaveformData.length) return;
            const w = wrap.clientWidth || 400;
            const h = 80;
            canvas.width = w;
            canvas.height = h;
            const ctx = canvas.getContext('2d');
            const barCount = soundPanelWaveformData.length;
            const barW = Math.max(1, (w / barCount) - 0.5);
            const dur = soundPanelWaveformDuration;
            const startPct = dur > 0 ? soundPanelStartTime / dur : 0;
            const endPct = (soundPanelEndTime != null && dur > 0) ? soundPanelEndTime / dur : 1;
            ctx.clearRect(0, 0, w, h);
            soundPanelWaveformData.forEach((peak, i) => {
                const x = (i / barCount) * w;
                const pct = (i + 0.5) / barCount;
                const center = h / 2;
                const halfH = Math.max(1, (Math.abs(peak.max - peak.min) / 2) * (h * 0.45));
                const inRange = pct >= startPct && pct <= endPct;
                ctx.fillStyle = inRange ? 'rgba(124, 58, 237, 0.7)' : 'rgba(80, 80, 90, 0.5)';
                ctx.fillRect(x, center - halfH, barW, halfH * 2);
            });
            if (soundPanelPreviewPlayheadTime != null && dur > 0) {
                const playheadPct = soundPanelPreviewPlayheadTime / dur;
                const playheadX = Math.max(0, Math.min(w, playheadPct * w));
                ctx.fillStyle = 'rgba(255,255,255,0.95)';
                ctx.fillRect(Math.floor(playheadX), 0, 2, h);
            }
            updateSoundPanelTrimLabel();
            updateSoundPanelHandlePositions();
        }

        function updateSoundPanelHandlePositions() {
            const wrap = document.getElementById('soundPanelWaveformWrap');
            const handleStart = document.getElementById('soundPanelHandleStart');
            const handleEnd = document.getElementById('soundPanelHandleEnd');
            if (!wrap || !handleStart || !handleEnd || soundPanelWaveformDuration <= 0) return;
            const w = wrap.clientWidth || 400;
            const dur = soundPanelWaveformDuration;
            const startPct = dur > 0 ? soundPanelStartTime / dur : 0;
            const endPct = (soundPanelEndTime != null && dur > 0) ? soundPanelEndTime / dur : 1;
            handleStart.style.left = Math.max(0, startPct * w - 5) + 'px';
            handleStart.style.width = '10px';
            handleEnd.style.right = Math.max(0, (1 - endPct) * w - 5) + 'px';
            handleEnd.style.left = 'auto';
            handleEnd.style.width = '10px';
        }

        function updateSoundPanelTrimLabel() {
            const el = document.getElementById('soundPanelTrimLabel');
            if (!el) return;
            const end = soundPanelEndTime != null ? formatTime(soundPanelEndTime) : 'full';
            el.textContent = 'Start: ' + formatTime(soundPanelStartTime) + ' ‚Äî End: ' + end;
        }

        function setupSoundPanelTrimHandles() {
            const wrap = document.getElementById('soundPanelWaveformWrap');
            const handleStart = document.getElementById('soundPanelHandleStart');
            const handleEnd = document.getElementById('soundPanelHandleEnd');
            if (!wrap || !handleStart || !handleEnd || soundPanelWaveformDuration <= 0) return;
            const drag = (isStart) => {
                const move = (e) => {
                    const rect = wrap.getBoundingClientRect();
                    const x = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));
                    const t = x * soundPanelWaveformDuration;
                    if (isStart) {
                        soundPanelStartTime = Math.max(0, soundPanelEndTime != null ? Math.min(t, soundPanelEndTime - 0.1) : Math.min(t, soundPanelWaveformDuration - 0.1));
                    } else {
                        soundPanelEndTime = Math.min(soundPanelWaveformDuration, Math.max(t, soundPanelStartTime + 0.1));
                    }
                    drawSoundPanelWaveform();
                };
                document.addEventListener('mousemove', move);
                document.addEventListener('mouseup', () => { document.removeEventListener('mousemove', move); }, { once: true });
            };
            handleStart.onmousedown = (e) => { e.preventDefault(); drag(true); };
            handleEnd.onmousedown = (e) => { e.preventDefault(); drag(false); };
            updateSoundPanelHandlePositions();
            const ro = new ResizeObserver(() => { drawSoundPanelWaveform(); });
            ro.observe(wrap);
        }

        function soundPanelPreview() {
            const btn = document.getElementById('soundPanelPreviewBtn');
            if (soundPanelPreviewAudio) {
                soundPanelPreviewAudio.pause();
                soundPanelPreviewAudio.currentTime = 0;
                soundPanelPreviewAudio = null;
                soundPanelPreviewPlayheadTime = null;
                drawSoundPanelWaveform();
                if (btn) btn.textContent = '‚ñ∂ Preview';
                return;
            }
            const nameEl = document.getElementById('soundPanelName');
            const filename = nameEl && nameEl.dataset.filename;
            if (!filename) return;
            let url = '/api/sounds/audio/' + encodeURIComponent(filename);
            const params = [];
            if (soundPanelStartTime > 0) params.push('start=' + encodeURIComponent(soundPanelStartTime));
            if (soundPanelEndTime != null && soundPanelEndTime < soundPanelWaveformDuration) params.push('end=' + encodeURIComponent(soundPanelEndTime));
            if (params.length) url += '?' + params.join('&');
            const audio = new Audio(url);
            const volEl = document.getElementById('soundPanelVolume');
            audio.volume = volEl ? Math.max(0, Math.min(1, parseFloat(volEl.value) || 1)) : 1;
            soundPanelPreviewAudio = audio;
            const onTimeUpdate = () => {
                soundPanelPreviewPlayheadTime = soundPanelStartTime + audio.currentTime;
                drawSoundPanelWaveform();
            };
            const onEnded = () => {
                soundPanelPreviewAudio = null;
                soundPanelPreviewPlayheadTime = null;
                drawSoundPanelWaveform();
                if (btn) btn.textContent = '‚ñ∂ Preview';
                audio.removeEventListener('timeupdate', onTimeUpdate);
            };
            const onError = () => {
                soundPanelPreviewAudio = null;
                soundPanelPreviewPlayheadTime = null;
                drawSoundPanelWaveform();
                if (btn) btn.textContent = '‚ñ∂ Preview';
            };
            audio.addEventListener('timeupdate', onTimeUpdate);
            audio.addEventListener('ended', onEnded);
            audio.addEventListener('error', onError);
            if (btn) btn.textContent = '‚èπ Stop';
            soundPanelPreviewPlayheadTime = soundPanelStartTime;
            drawSoundPanelWaveform();
            audio.play().catch(onError);
        }

        function soundPanelResetTrim() {
            soundPanelStartTime = 0;
            soundPanelEndTime = null;
            drawSoundPanelWaveform();
        }

        function selectSoundPanelColor(hex) {
            var panel = document.getElementById('soundPanel');
            var presets = document.getElementById('soundPanelColorPresets');
            var customEl = document.getElementById('soundPanelColorCustom');
            if (!panel || !presets) return;
            presets.querySelectorAll('.sound-color-preset').forEach(function(btn) {
                btn.classList.toggle('selected', btn.dataset.color === hex);
            });
            if (customEl && hex) customEl.value = hex;
            panel.dataset.soundColor = hex || '';
        }

        function clearSoundPanelColor() {
            var panel = document.getElementById('soundPanel');
            var presets = document.getElementById('soundPanelColorPresets');
            var customEl = document.getElementById('soundPanelColorCustom');
            if (panel) panel.dataset.soundColor = '';
            if (presets) presets.querySelectorAll('.sound-color-preset').forEach(function(btn) { btn.classList.remove('selected'); });
            if (customEl) customEl.value = '#7c3aed';
        }

        function openSoundPanelFromSound(filename) {
            const s = soundsList.find(x => x.filename === filename);
            selectedSound = filename;
            renderSoundsGrid();
            openSoundPanel(s || { filename, displayName: filename, duration: null, tags: [] });
        }

        let previewAudio = null;
        let previewBtn = null;
        let previewId = 0;
        function previewSound(filename, btn) {
            if (!filename) return;
            if (previewBtn === btn && previewAudio) {
                previewAudio.pause();
                previewAudio = null;
                btn.classList.remove('playing');
                return;
            }
            if (previewAudio) {
                previewAudio.pause();
                previewAudio = null;
                if (previewBtn) previewBtn.classList.remove('playing');
            }
            const id = ++previewId;
            const url = '/api/sounds/audio/' + encodeURIComponent(filename);
            fetch(url, { credentials: 'include' }).then(r => {
                if (!r.ok) throw new Error('Preview failed');
                return r.arrayBuffer();
            }).then(buf => {
                if (id !== previewId) return;
                const blob = new Blob([buf]);
                const audio = new Audio(URL.createObjectURL(blob));
                audio.addEventListener('ended', () => { URL.revokeObjectURL(audio.src); previewAudio = null; if (previewBtn) previewBtn.classList.remove('playing'); });
                audio.addEventListener('error', () => { if (audio.src) URL.revokeObjectURL(audio.src); previewAudio = null; if (previewBtn) previewBtn.classList.remove('playing'); });
                previewAudio = audio;
                previewBtn = btn;
                btn.classList.add('playing');
                audio.play().catch(() => { previewAudio = null; btn.classList.remove('playing'); });
            }).catch(() => { if (id === previewId) { previewAudio = null; btn.classList.remove('playing'); } });
        }

        function closeSoundPanel() {
            if (soundPanelPreviewAudio) {
                soundPanelPreviewAudio.pause();
                soundPanelPreviewAudio = null;
                soundPanelPreviewPlayheadTime = null;
                const btn = document.getElementById('soundPanelPreviewBtn');
                if (btn) btn.textContent = '‚ñ∂ Preview';
            }
            selectedSound = null;
            const sp = document.getElementById('soundPanel'); if (sp) sp.classList.add('hidden');
            renderSoundsGrid();
        }

        async function saveSoundPanel() {
            const nameEl = document.getElementById('soundPanelName');
            const tagsEl = document.getElementById('soundPanelTags');
            const panel = document.getElementById('soundPanel');
            const volEl = document.getElementById('soundPanelVolume');
            const filename = nameEl && nameEl.dataset.filename;
            if (!filename) return;
            const displayName = ((nameEl && nameEl.value) || '').trim() || filename;
            const tagsRaw = ((tagsEl && tagsEl.value) || '').trim();
            const tags = tagsRaw ? tagsRaw.split(/[,\s]+/).map(t => t.trim()).filter(Boolean) : [];
            var color = null;
            if (panel) {
                const c = (panel.dataset.soundColor || '').trim();
                if (c && /^#[0-9a-fA-F]{6}$/.test(c)) color = c;
            }
            const volume = volEl ? parseFloat(volEl.value) : 1;
            const startTime = soundPanelStartTime > 0 ? soundPanelStartTime : null;
            const endTime = soundPanelEndTime != null && soundPanelEndTime < soundPanelWaveformDuration ? soundPanelEndTime : null;
            const res = await api('/api/sounds/metadata', {
                method: 'PATCH',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ filename, displayName, tags, color: color || null, volume: Number.isFinite(volume) ? volume : 1, startTime, endTime }),
            });
            if (res && res.ok) { fetchSounds(); nameEl.dataset.filename = filename; closeSoundPanel(); }
        }

        async function joinChannel() {
            const channelId = document.getElementById('channelSelect').value;
            const res = await api('/api/join', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ channelId }) });
            if (res && res.ok) fetchChannels();
        }

        async function leaveChannel() {
            const res = await api('/api/leave', { method: 'POST' });
            if (res && res.ok) fetchChannels();
        }

        async function playSound(filename, startTime) {
            const body = { filename };
            if (typeof startTime === 'number' && startTime > 0) body.startTime = startTime;
            const res = await api('/api/play', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(body) });
            if (!res) return;
            const data = await res.json().catch(() => ({}));
            if (!res.ok) {
                const msg = data.error || data.message || 'Failed to play';
                if (res.status === 429 && data.cooldownRemaining) {
                    if ((user && user.role) === 'guest') {
                        guestLastPlayTime = Date.now() - ((guestCooldownSec || 10) - data.cooldownRemaining) * 1000;
                    } else if ((user && user.role) === 'user') {
                        userLastPlayTime = Date.now() - ((userCooldownSec || 0) - data.cooldownRemaining) * 1000;
                    }
                    renderSoundsGrid();
                }
                alert(msg);
                return;
            }
            if ((user && user.role) === 'guest') guestLastPlayTime = Date.now();
            if ((user && user.role) === 'user') userLastPlayTime = Date.now();
            playback.duration = (data.duration != null ? data.duration : null);
            playback.startTime = Date.now();
            playback.startTimeOffset = (data.startTimeOffset != null ? data.startTimeOffset : 0);
            playback.serverCurrentTime = undefined;
            playback.status = 'playing';
            playback.displayName = (data.displayName != null ? data.displayName : filename);
            playback.filename = filename;
            playback.startedBy = (data.startedBy != null ? data.startedBy : { username: (user && user.username), role: (user && user.role) });
            pausedAt = 0;
            updateNowPlaying();
            updatePlayPauseButton();
            const timeEl = document.getElementById('progressTime');
            if (timeEl) timeEl.textContent = '0:00 / ' + (playback.duration != null ? formatTime(playback.duration) : '0:00');
            loadWaveform(filename);
            const newItem = { filename, displayName: playback.displayName || filename, playedBy: (user && user.username) || null, playedAt: Date.now() };
            serverRecentlyPlayed = [newItem, ...serverRecentlyPlayed.filter(x => x.filename !== filename)].slice(0, 5);
            renderRecentlyPlayed();
        }

        async function loadWaveform(filename) {
            waveformData = null;
            waveformDuration = 0;
            waveformFilename = null;
            document.getElementById('waveformPlaceholder').style.display = 'block';
            document.getElementById('waveformWrap').style.display = 'none';
            if (!filename) return;
            try {
                const res = await fetch('/api/sounds/audio/' + encodeURIComponent(filename), { credentials: CREDENTIALS });
                if (!res.ok) return;
                const buf = await res.arrayBuffer();
                const ctx = new (window.AudioContext || window.webkitAudioContext)();
                const decoded = await ctx.decodeAudioData(buf);
                const ch = decoded.getChannelData(0);
                const duration = decoded.duration;
                const bars = 120;
                const step = Math.floor(ch.length / bars);
                const peaks = [];
                for (let i = 0; i < bars; i++) {
                    let min = 0, max = 0;
                    for (let j = 0; j < step; j++) {
                        const v = ch[i * step + j];
                        if (v < min) min = v;
                        if (v > max) max = v;
                    }
                    peaks.push({ min, max });
                }
                waveformData = peaks;
                waveformDuration = duration;
                waveformFilename = filename;
                waveformCache[filename] = { peaks: peaks, duration: duration };
                document.getElementById('waveformPlaceholder').style.display = 'none';
                document.getElementById('waveformWrap').style.display = 'block';
                drawWaveform(Math.min(getCurrentPlaybackTime(), duration), duration);
            } catch (e) {
                console.warn('Waveform load failed', e);
            }
        }

        function drawWaveform(currentTime, totalDuration) {
            const canvas = document.getElementById('waveformCanvas');
            const wrap = document.getElementById('waveformWrap');
            if (!wrap || wrap.style.display === 'none' || !waveformData || !waveformData.length) return;
            const w = wrap.clientWidth || 600;
            const h = 48;
            canvas.width = w;
            canvas.height = h;
            const ctx = canvas.getContext('2d');
            const barCount = waveformData.length;
            const barW = Math.max(1, (w / barCount) - 1);
            const total = totalDuration != null && totalDuration > 0 ? totalDuration : waveformDuration;
            const progress = total > 0 ? Math.min(1, currentTime / total) : 0;
            const playheadX = progress * w;
            ctx.clearRect(0, 0, w, h);
            waveformData.forEach((peak, i) => {
                const x = (i / barCount) * w;
                const center = h / 2;
                const halfH = Math.max(1, (Math.abs(peak.max - peak.min) / 2) * (h * 0.4));
                const isPast = x + barW < playheadX;
                ctx.fillStyle = isPast ? 'rgba(124, 58, 237, 0.6)' : 'rgba(42, 42, 50, 0.8)';
                ctx.fillRect(x, center - halfH, barW, halfH * 2);
            });
            ctx.fillStyle = 'rgba(255,255,255,0.9)';
            ctx.fillRect(Math.floor(playheadX), 0, 2, h);
        }

        let lastServerCurrentTimeReceivedAt = 0;
        function isLocalPlayer() {
            return playback.startedBy && playback.startedBy.username === (user && user.username);
        }
        function getCurrentPlaybackTime() {
            if (isLocalPlayer()) {
                if (playback.status === 'playing' && playback.startTime != null) {
                    const start = Number(playback.startTime);
                    if (!Number.isFinite(start)) return 0;
                    const offset = playback.startTimeOffset || 0;
                    let current = offset + (Date.now() - start) / 1000;
                    if (playback.duration != null) current = Math.min(current, playback.duration);
                    return Math.max(0, current);
                }
                if (playback.status === 'paused') return pausedAt;
                return 0;
            }
            if (playback.serverCurrentTime != null) {
                if (playback.status === 'playing') {
                    const elapsed = (Date.now() - lastServerCurrentTimeReceivedAt) / 1000;
                    let current = playback.serverCurrentTime + elapsed;
                    if (playback.duration != null) current = Math.min(current, playback.duration);
                    return Math.max(0, current);
                }
                return playback.serverCurrentTime;
            }
            if (playback.status === 'playing' && playback.startTime != null) {
                const start = Number(playback.startTime);
                if (!Number.isFinite(start)) return 0;
                const offset = playback.startTimeOffset || 0;
                let current = offset + (Date.now() - start) / 1000;
                if (playback.duration != null) current = Math.min(current, playback.duration);
                return Math.max(0, current);
            }
            if (playback.status === 'paused') return pausedAt;
            return 0;
        }

        function tickWaveform() {
            const isActive = playback.status === 'playing' || playback.status === 'paused';
            if (isActive) {
                const current = getCurrentPlaybackTime();
                const timeEl = document.getElementById('progressTime');
                const dur = playback.duration;
                if (timeEl) timeEl.textContent = formatTime(current) + ' / ' + (dur != null ? formatTime(dur) : '‚Äî');
            }
            if (waveformData && waveformDuration > 0 && isActive) {
                const current = getCurrentPlaybackTime();
                const total = playback.duration != null ? playback.duration : waveformDuration;
                drawWaveform(Math.min(current, total), total);
            }
            if ((user && user.role) === 'guest') {
                const r = getGuestCooldownRemaining();
                if (r > 0 && r !== lastGuestCooldownShown) { lastGuestCooldownShown = r; renderSoundsGrid(); }
                else if (r === 0 && lastGuestCooldownShown > 0) { lastGuestCooldownShown = 0; renderSoundsGrid(); }
                else if (r === 0) lastGuestCooldownShown = -1;
            }
            if ((user && user.role) === 'user') {
                const r = getUserCooldownRemaining();
                if (r > 0 && r !== lastUserCooldownShown) { lastUserCooldownShown = r; renderSoundsGrid(); }
                else if (r === 0 && lastUserCooldownShown > 0) { lastUserCooldownShown = 0; renderSoundsGrid(); }
                else if (r === 0) lastUserCooldownShown = -1;
            }
        }

        async function stopPlayback() {
            const res = await api('/api/stop', { method: 'POST' });
            if (!res) return;
            playback = { status: 'idle', filename: null, displayName: null, startTime: null, duration: null, startTimeOffset: 0, startedBy: null };
            pausedAt = 0;
            waveformData = null;
            waveformDuration = 0;
            waveformFilename = null;
            document.getElementById('waveformPlaceholder').style.display = 'block';
            document.getElementById('waveformPlaceholder').textContent = 'Waveform will appear when a sound is playing';
            document.getElementById('waveformWrap').style.display = 'none';
            updateNowPlaying();
            updatePlayPauseButton();
        }

        async function togglePlayPause() {
            if (playback.status === 'playing') {
                await api('/api/pause', { method: 'POST' });
                const offset = playback.startTimeOffset || 0;
                pausedAt = offset + (Date.now() - (playback.startTime || 0)) / 1000;
                if (playback.duration != null) pausedAt = Math.min(pausedAt, playback.duration);
                playback.status = 'paused';
            } else if (playback.status === 'paused') {
                await api('/api/resume', { method: 'POST' });
                playback.startTime = Date.now();
                playback.startTimeOffset = pausedAt;
                playback.status = 'playing';
            }
            updatePlayPauseButton();
        }

        function updatePlayPauseButton() {
            const btn = document.getElementById('playPauseBtn');
            if (!btn || btn.classList.contains('hidden')) return;
            const isActive = playback.status === 'playing' || playback.status === 'paused';
            btn.disabled = !isActive;
            btn.textContent = playback.status === 'playing' ? '‚è∏' : '‚ñ∂';
            btn.title = playback.status === 'playing' ? 'Pause' : 'Play';
            updateStopButtons();
        }

        function updateStopButtons() {
            const stopAll = document.getElementById('stopAllBtn');
            const stopBtn = document.getElementById('stopBtn');
            const isActive = playback.status === 'playing' || playback.status === 'paused';
            const adminCantStop = (user && user.role) === 'admin' && playback.startedBy && (playback.startedBy.role === 'admin' || playback.startedBy.role === 'superadmin');
            const disabled = !isActive || adminCantStop;
            if (stopAll) { stopAll.disabled = disabled; stopAll.title = adminCantStop ? 'Only superadmin can stop admin playback' : 'Stop playback'; }
            if (stopBtn) { stopBtn.disabled = disabled; stopBtn.title = adminCantStop ? 'Only superadmin can stop admin playback' : 'Stop'; }
        }

        function updateNowPlaying() {
            const card = document.getElementById('playerCard');
            const text = document.getElementById('nowPlayingText');
            if (playback.status === 'idle' || !playback.displayName) {
                text.innerHTML = 'Nothing playing';
                card.classList.add('player-idle');
            } else {
                let html = 'Now playing: <strong>' + (playback.displayName || playback.filename || '') + '</strong>';
                if (playback.startedBy && playback.startedBy.username) {
                    html += ' <span style="color:var(--text-muted);font-weight:400">by ' + (playback.startedBy.username || '').replace(/&/g, '&amp;').replace(/</g, '&lt;') + (playback.startedBy.role ? ' (' + playback.startedBy.role + ')' : '') + '</span>';
                }
                text.innerHTML = html;
                card.classList.remove('player-idle');
            }
        }

        function formatTime(s) {
            if (s == null || !Number.isFinite(s)) return '0:00';
            const m = Math.floor(s / 60);
            const sec = Math.floor(s % 60);
            return m + ':' + (sec < 10 ? '0' : '') + sec;
        }

        let playbackPollingStarted = false;
        let pendingCountPollingStarted = false;
        let soundsPollingStarted = false;
        function startSoundsPolling() {
            if (soundsPollingStarted) return;
            soundsPollingStarted = true;
            setInterval(fetchSounds, 10000);
            document.addEventListener('visibilitychange', () => { if (document.visibilityState === 'visible' && user) fetchSounds(); });
        }
        function startPlaybackPolling() {
            if (playbackPollingStarted) return;
            playbackPollingStarted = true;
            refreshPlaybackState();
            setTimeout(() => setInterval(refreshPlaybackState, 400), 600);
        }
        function startPendingCountPolling() {
            if (pendingCountPollingStarted || (user && user.role) !== 'superadmin') return;
            pendingCountPollingStarted = true;
            fetchPendingCount();
            setInterval(fetchPendingCount, 30000);
            document.addEventListener('visibilitychange', () => { if (document.visibilityState === 'visible' && (user && user.role) === 'superadmin') fetchPendingCount(); });
        }

        function refreshPlaybackState() {
            if (!user) return;
            api('/api/playback-state').then(async (res) => {
                if (!res || !res.ok) return;
                const state = await res.json();
                const prevFilename = playback.filename;
                if (state.status === 'idle' && playback.status === 'playing' && playback.startTime != null) {
                    const started = Number(playback.startTime);
                    if (Number.isFinite(started) && (Date.now() - started) < 3000) return;
                }
                playback.status = state.status;
                playback.filename = state.filename;
                playback.displayName = (state.displayName != null ? state.displayName : state.filename);
                playback.startedBy = (state.startedBy != null ? state.startedBy : null);
                const amLocal = state.startedBy && state.startedBy.username === (user && user.username);
                if (!amLocal) {
                    if (state.startTime != null) playback.startTime = Number(state.startTime);
                    if (playback.startTimeOffset === undefined) playback.startTimeOffset = 0;
                }
                if (state.duration != null) playback.duration = state.duration;
                if (!amLocal && state.currentTime != null) { playback.serverCurrentTime = Number(state.currentTime); lastServerCurrentTimeReceivedAt = Date.now(); if (state.status === 'paused') pausedAt = playback.serverCurrentTime; }
                if (amLocal && state.status === 'paused' && state.currentTime != null) pausedAt = Number(state.currentTime);
                if (state.status === 'idle') { pausedAt = 0; playback.startTime = null; playback.startedBy = null; playback.serverCurrentTime = undefined; lastServerCurrentTimeReceivedAt = 0; waveformData = null; waveformFilename = null; }
                if (state.recentlyPlayed && Array.isArray(state.recentlyPlayed)) setRecentlyPlayedFromServer(state.recentlyPlayed);
                if ((state.status === 'playing' || state.status === 'paused') && state.filename && waveformFilename !== state.filename) loadWaveform(state.filename);
                updateNowPlaying();
                updatePlayPauseButton();
                updateStopButtons();

                const timeEl = document.getElementById('progressTime');
                let current = getCurrentPlaybackTime();
                const dur = playback.duration;
                timeEl.textContent = formatTime(current) + ' / ' + (dur != null ? formatTime(dur) : '‚Äî');

                const totalDur = dur != null ? dur : waveformDuration;
                if (waveformData && totalDur > 0) {
                    drawWaveform(Math.min(current, totalDur), totalDur);
                }
                renderSoundsGrid();
                if (state.voiceConnected !== undefined && isAdminOrSuperadmin()) {
                    const connectionCard = document.getElementById('connectionCard');
                    const voiceBar = document.getElementById('voiceConnectedBar');
                    const channelNameEl = document.getElementById('voiceChannelInfo');
                    const voiceChannelName = state.voiceChannelName || '';
                    if (connectionCard) connectionCard.classList.toggle('hidden', state.voiceConnected);
                    if (voiceBar) voiceBar.classList.toggle('hidden', !state.voiceConnected);
                    if (channelNameEl) {
                        channelNameEl.title = voiceChannelName ? 'Connected to: ' + voiceChannelName : '';
                        const nameSpan = document.getElementById('voiceChannelName');
                        if (nameSpan) nameSpan.textContent = voiceChannelName || '‚Äî';
                    }
                }
            });
        }

        const ww = document.getElementById('waveformWrap'); if (ww) ww.addEventListener('click', (e) => {
            if (!waveformData || waveformDuration <= 0 || !playback.filename) return;
            const canvas = document.getElementById('waveformCanvas');
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) / rect.width;
            const t = Math.max(0, Math.min(waveformDuration, x * waveformDuration));
            if (t < waveformDuration - 0.5) playSound(playback.filename, Number(t));
        });

        function setVolume(volume) {
            const v = parseFloat(volume);
            const pct = Math.round(v * 100) + '%';
            const label = document.getElementById('volumeLabel');
            const labelCard = document.getElementById('volumeLabelCard');
            const btnPct = document.getElementById('volumeBtnPct');
            const slider = document.getElementById('volumeSlider');
            const sliderCard = document.getElementById('volumeSliderCard');
            if (label) label.textContent = pct;
            if (labelCard) labelCard.textContent = pct;
            if (btnPct) btnPct.textContent = pct;
            if (slider) slider.value = v;
            if (sliderCard) sliderCard.value = v;
            fetch('/api/volume', { method: 'POST', headers: { 'Content-Type': 'application/json' }, credentials: CREDENTIALS, body: JSON.stringify({ volume: v }) });
        }

        function setVolumeExpanded(expanded) {
            savePrefs({ volumeExpanded: !!expanded });
            applyVolumeExpanded();
        }
        function applyVolumeExpanded() {
            const expanded = loadPrefs().volumeExpanded === true;
            const card = document.getElementById('volumeCard');
            const wrap = document.querySelector('.volume-btn-wrap');
            const check = document.getElementById('volumeExpandedCheck');
            const checkCard = document.getElementById('volumeExpandedCheckCard');
            if (card) card.classList.toggle('hidden', !expanded);
            if (wrap) wrap.classList.toggle('hidden', expanded);
            if (check) check.checked = expanded;
            if (checkCard) checkCard.checked = expanded;
            if (expanded) closeVolumeMenu();
        }

        function toggleVolumeMenu() {
            const menu = document.getElementById('volumeMenu');
            if (!menu) return;
            const isHidden = menu.classList.contains('hidden');
            menu.classList.toggle('hidden', !isHidden);
            if (isHidden) {
                setTimeout(function() { document.addEventListener('click', closeVolumeMenuOnce); }, 0);
            } else {
                document.removeEventListener('click', closeVolumeMenuOnce);
            }
        }
        function closeVolumeMenu() {
            const menu = document.getElementById('volumeMenu');
            if (menu) menu.classList.add('hidden');
            document.removeEventListener('click', closeVolumeMenuOnce);
        }
        function closeVolumeMenuOnce(e) {
            const wrap = document.querySelector('.volume-btn-wrap');
            if (wrap && !wrap.contains(e.target)) {
                closeVolumeMenu();
                document.removeEventListener('click', closeVolumeMenuOnce);
            }
        }

        var vs = document.getElementById('volumeSlider');
        var vsc = document.getElementById('volumeSliderCard');
        if (vs) vs.addEventListener('input', function(e) { setVolume(e.target.value); });
        if (vsc) vsc.addEventListener('input', function(e) { setVolume(e.target.value); });

        const cs = document.getElementById('channelSelect'); if (cs) cs.addEventListener('change', (e) => savePrefs({ lastChannelId: e.target.value }));

        (function initTheme() {
            applyTheme(loadPrefs().theme);
        })();

        function updateFilterClearVisibility() {
            const sfi = document.getElementById('soundFilterInput');
            const clearBtn = document.getElementById('soundFilterClear');
            if (sfi && clearBtn) clearBtn.classList.toggle('visible', (sfi.value || '').trim().length > 0);
        }
        function clearSoundFilter() {
            const sfi = document.getElementById('soundFilterInput');
            if (!sfi) return;
            sfi.value = '';
            soundFilter = '';
            savePrefs({ soundFilter });
            updateFilterClearVisibility();
            renderSoundsGrid();
            sfi.focus();
        }
        const sfi = document.getElementById('soundFilterInput'); if (sfi) {
            sfi.addEventListener('input', (e) => {
                soundFilter = (e.target.value || '').trim();
                savePrefs({ soundFilter });
                updateFilterClearVisibility();
                renderSoundsGrid();
            });
        }

        async function uploadSound(file) {
            const fileInput = document.getElementById('fileInput');
            const f = file || (fileInput && fileInput.files && fileInput.files[0]);
            if (!f) return;
            const formData = new FormData();
            formData.append('soundFile', f);
            const res = await api('/api/upload', { method: 'POST', body: formData });
            if (!res) return;
            const data = await res.json().catch(() => ({}));
            if (res.ok) {
                fileInput.value = '';
                fetchSounds();
                hideUploadSection();
                if (data.pending) alert(data.message || 'Upload sent for moderation.');
            } else {
                alert(data.error || 'Upload failed');
            }
        }

        document.getElementById('fileInput').addEventListener('change', () => uploadSound());

        (function initUploadZone() {
            const zone = document.getElementById('uploadZone');
            if (!zone) return;
            zone.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.stopPropagation();
                e.dataTransfer.dropEffect = 'copy';
                zone.classList.add('drag-over');
            });
            zone.addEventListener('dragleave', (e) => {
                e.preventDefault();
                e.stopPropagation();
                if (!zone.contains(e.relatedTarget)) zone.classList.remove('drag-over');
            });
            zone.addEventListener('drop', (e) => {
                e.preventDefault();
                e.stopPropagation();
                zone.classList.remove('drag-over');
                const f = e.dataTransfer.files && e.dataTransfer.files[0];
                if (f) uploadSound(f);
            });
        })();

        (async function init() {
            setupSoundGridDragDrop(document.getElementById('soundsList'));
            fetchGuestStatus();
            const ok = await checkAuth();
            if (!ok) return;
            applyPrefs();
            renderRecentlyPlayed();
            startPlaybackPolling();
            startSoundsPolling();
            setInterval(tickWaveform, 100);
            fetchChannels();
            fetchSounds();
            updateNowPlaying();
            updatePlayPauseButton();
            window.addEventListener('resize', () => { if (mobileView) renderMobileGrid(); });
            document.addEventListener('keydown', (e) => {
                const tag = document.activeElement && document.activeElement.tagName;
                if (tag === 'INPUT' || tag === 'TEXTAREA' || (document.activeElement && document.activeElement.isContentEditable)) return;
                if (e.key >= '1' && e.key <= '9') {
                    const fav = getFavorites()[parseInt(e.key, 10) - 1];
                    if (fav) { e.preventDefault(); playSound(fav); }
                } else if (e.key === ' ') {
                    if (playback.status === 'playing' || playback.status === 'paused') { e.preventDefault(); togglePlayPause(); }
                } else if (e.key === 's' || e.key === 'S') {
                    e.preventDefault();
                    stopPlayback();
                } else if (e.key === 'Escape') {
                    const panel = document.getElementById('soundPanel');
                    if (panel && !panel.classList.contains('hidden')) { e.preventDefault(); closeSoundPanel(); }
                }
            });
        })();
    </script>
</body>
</html>
