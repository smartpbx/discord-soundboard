<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Discord Soundboard</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=DM+Sans:ital,opsz,wght@0,9..40,400;0,9..40,500;0,9..40,600;0,9..40,700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg: #0f0f12;
            --surface: #18181c;
            --surface-hover: #1f1f24;
            --border: #2a2a32;
            --text: #e4e4e7;
            --text-muted: #a1a1aa;
            --accent: #7c3aed;
            --accent-hover: #6d28d9;
            --danger: #dc2626;
            --danger-hover: #b91c1c;
            --success: #22c55e;
            --radius: 12px;
            --radius-sm: 8px;
            --shadow: 0 4px 24px rgba(0,0,0,0.4);
        }
        * { box-sizing: border-box; }
        body {
            font-family: 'DM Sans', system-ui, sans-serif;
            margin: 0;
            min-height: 100vh;
            background: var(--bg);
            color: var(--text);
            line-height: 1.5;
        }
        .app { max-width: 720px; margin: 0 auto; padding: 1.5rem; }
        .app.hidden { display: none; }
        .hidden { display: none !important; }
        .login-screen {
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 1.5rem;
        }
        .login-screen.hidden { display: none; }
        .login-card {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            padding: 2rem;
            width: 100%;
            max-width: 360px;
            box-shadow: var(--shadow);
        }
        .login-card h1 { font-size: 1.5rem; margin: 0 0 1.5rem; }
        .login-card label { display: block; font-size: 0.85rem; color: var(--text-muted); margin-bottom: 0.35rem; }
        .login-card input {
            width: 100%;
            padding: 0.65rem 0.75rem;
            background: var(--surface-hover);
            border: 1px solid var(--border);
            border-radius: var(--radius-sm);
            color: var(--text);
            font: inherit;
            margin-bottom: 1rem;
        }
        .login-card input:focus { outline: none; border-color: var(--accent); }
        .login-card .btn { width: 100%; padding: 0.75rem; margin-top: 0.5rem; }
        .login-error { color: var(--danger); font-size: 0.85rem; margin-top: 0.5rem; }
        .header-row { display: flex; align-items: center; justify-content: space-between; flex-wrap: wrap; gap: 0.75rem; margin-bottom: 1rem; }
        .header-row { flex-wrap: wrap; }
        .header-row h1 { font-size: 1.5rem; font-weight: 700; margin: 0; letter-spacing: -0.02em; }
        .header-right { display: flex; align-items: center; gap: 1rem; flex-wrap: wrap; }
        .main-tabs { display: flex; gap: 0.25rem; }
        .main-tab { padding: 0.4rem 0.75rem; border-radius: var(--radius-sm); font-size: 0.85rem; background: var(--surface-hover); border: 1px solid var(--border); color: var(--text); cursor: pointer; }
        .main-tab:hover { border-color: var(--accent); }
        .main-tab.active { background: var(--accent); border-color: var(--accent); color: white; }
        .user-badge { font-size: 0.75rem; color: var(--text-muted); }
        .user-badge span { color: var(--accent); font-weight: 500; }
        .card {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            padding: 1.25rem 1.5rem;
            margin-bottom: 1rem;
            box-shadow: var(--shadow);
        }
        .card.admin-only { }
        .card-title { font-size: 0.75rem; font-weight: 600; text-transform: uppercase; letter-spacing: 0.06em; color: var(--text-muted); margin-bottom: 0.75rem; }
        .row { display: flex; align-items: center; gap: 0.75rem; flex-wrap: wrap; }
        select {
            flex: 1; min-width: 180px;
            padding: 0.6rem 0.75rem;
            background: var(--surface-hover);
            border: 1px solid var(--border);
            border-radius: var(--radius-sm);
            color: var(--text);
            font: inherit;
            cursor: pointer;
        }
        select:focus { outline: none; border-color: var(--accent); }
        .btn {
            padding: 0.6rem 1rem;
            border: none;
            border-radius: var(--radius-sm);
            font: inherit;
            font-weight: 500;
            cursor: pointer;
            transition: background 0.15s, transform 0.05s;
        }
        .btn:active { transform: scale(0.98); }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .btn-primary { background: var(--accent); color: white; }
        .btn-primary:hover:not(:disabled) { background: var(--accent-hover); }
        .btn-danger { background: var(--danger); color: white; }
        .btn-danger:hover:not(:disabled) { background: var(--danger-hover); }
        .btn-ghost { background: var(--surface-hover); color: var(--text); }
        .btn-ghost:hover:not(:disabled) { background: var(--border); }
        .btn-icon { width: 40px; height: 40px; padding: 0; display: inline-flex; align-items: center; justify-content: center; border-radius: var(--radius-sm); }
        .btn-icon svg { width: 20px; height: 20px; }
        .player {
            background: linear-gradient(135deg, var(--surface) 0%, #1a1a20 100%);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            padding: 1rem 1.25rem;
            margin-bottom: 1rem;
        }
        .player-idle .player-controls { opacity: 0.6; }
        .player-now-playing { font-size: 0.9rem; font-weight: 500; margin-bottom: 0.5rem; color: var(--text-muted); }
        .player-now-playing strong { color: var(--text); }
        .waveform-wrap {
            height: 48px;
            background: rgba(0,0,0,0.2);
            border-radius: var(--radius-sm);
            margin-bottom: 0.5rem;
            overflow: hidden;
            position: relative;
        }
        .waveform-wrap canvas { display: block; width: 100%; height: 100%; cursor: pointer; }
        .waveform-placeholder {
            height: 48px;
            background: var(--border);
            border-radius: var(--radius-sm);
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-muted);
            font-size: 0.8rem;
        }
        .progress-time { font-size: 0.7rem; color: var(--text-muted); margin-bottom: 0.5rem; }
        .player-buttons { display: flex; align-items: center; gap: 0.5rem; }
        .volume-row { align-items: center; gap: 1rem; }
        .volume-row input[type="range"] { flex: 1; min-width: 120px; accent-color: var(--accent); height: 6px; }
        .volume-label { font-size: 0.8rem; color: var(--text-muted); min-width: 2.5rem; }
        .sound-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)); gap: 0.75rem; }
        .sound-item { position: relative; display: flex; flex-direction: column; align-items: stretch; min-height: 100px; }
        .sound-btn {
            background: var(--surface-hover);
            border: 1px solid var(--border);
            border-radius: var(--radius-sm);
            padding: 0.6rem 0.5rem 0.4rem;
            color: var(--text);
            font: inherit;
            font-size: 0.85rem;
            font-weight: 500;
            cursor: pointer;
            transition: background 0.15s, border-color 0.15s;
            text-align: center;
            word-break: break-word;
            min-height: 100px;
            height: 100px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between;
        }
        .sound-btn-label { flex: 1; display: flex; align-items: center; justify-content: center; line-height: 1.2; }
        .sound-btn-duration { font-size: 0.7rem; color: var(--text-muted); flex-shrink: 0; }
        .sound-btn:hover:not(:disabled) { background: var(--border); border-color: var(--accent); }
        .sound-btn:active:not(:disabled) { transform: scale(0.98); }
        .sound-btn.disabled { opacity: 0.5; cursor: not-allowed; }
        .sound-edit {
            position: absolute; top: 4px; right: 4px;
            width: 24px; height: 24px; padding: 0;
            border: none; background: var(--surface);
            border-radius: 4px; color: var(--text-muted);
            cursor: pointer; display: flex; align-items: center; justify-content: center;
            opacity: 0; pointer-events: none; transition: opacity 0.15s;
        }
        .sound-item:hover .sound-edit { opacity: 0.7; pointer-events: auto; }
        .sound-edit:hover { opacity: 1; color: var(--accent); }
        .sound-edit.hidden { display: none; }
        .sound-edit svg { width: 12px; height: 12px; }
        .upload-zone { border: 2px dashed var(--border); border-radius: var(--radius-sm); padding: 1rem; text-align: center; color: var(--text-muted); font-size: 0.9rem; transition: border-color 0.15s, background 0.15s; }
        .upload-zone.drag-over { border-color: var(--accent); background: rgba(124, 58, 237, 0.1); }
        .upload-zone input[type="file"] { display: none; }
        .upload-zone label { cursor: pointer; display: block; }
        .upload-zone .browse { color: var(--accent); font-weight: 500; }
        .top-actions { display: flex; gap: 0.5rem; margin-bottom: 1rem; flex-wrap: wrap; }
        .top-actions.hidden { display: none; }
        .sounds-card-header { display: flex; align-items: center; justify-content: space-between; flex-wrap: wrap; gap: 0.5rem; margin-bottom: 0.75rem; }
        .sounds-card-header .card-title { margin-bottom: 0; }
        .sounds-header-buttons { display: flex; gap: 0.35rem; align-items: center; }
        .toggle-btn { font-size: 0.8rem; }
        .toggle-btn.active { background: var(--accent); color: white; }
        .sound-grid.reorder-mode .sound-item { user-select: none; }
        .sound-item-wrap { display: contents; }
        .sound-grid.reorder-mode .sound-item-wrap { display: flex; flex-direction: column; cursor: grab; }
        .sound-grid.reorder-mode .sound-item-wrap:active { cursor: grabbing; }
        .sound-grid.reorder-mode .sound-item-wrap.dragging { opacity: 0.5; }
        .sound-grid.reorder-mode .sound-item-wrap.drag-over { outline: 2px solid var(--accent); outline-offset: 2px; border-radius: var(--radius-sm); }
        .sound-grid.reorder-mode .sound-btn { pointer-events: none; }
        .sound-grid.reorder-mode .sound-edit { pointer-events: none; }
        .settings-row { align-items: center; gap: 0.5rem; }
        .settings-row label { display: flex; align-items: center; gap: 0.5rem; cursor: pointer; font-size: 0.9rem; }
        .settings-row input[type="checkbox"] { width: 1.1rem; height: 1.1rem; accent-color: var(--accent); }
        .user-locked-msg { color: var(--text-muted); font-size: 0.9rem; margin-top: 0.5rem; }
        .folder-tabs { display: flex; flex-wrap: wrap; gap: 0.35rem; margin-bottom: 0.75rem; align-items: center; }
        .folder-tab { padding: 0.4rem 0.75rem; border-radius: var(--radius-sm); font-size: 0.85rem; background: var(--surface-hover); border: 1px solid var(--border); color: var(--text); cursor: pointer; }
        .folder-tab:hover { border-color: var(--accent); }
        .folder-tab.active { background: var(--accent); border-color: var(--accent); color: white; }
        .folder-tab.delete { padding: 0.2rem 0.4rem; font-size: 0.75rem; color: var(--text-muted); }
        .folder-tab.delete:hover { color: var(--danger); }
        .folder-tab-wrap { display: inline-flex; align-items: center; gap: 0.15rem; }
        .folder-tabs.manage-mode .folder-tab-wrap { cursor: grab; }
        .folder-tabs.manage-mode .folder-tab-wrap:active { cursor: grabbing; }
        .folder-tabs.manage-mode .folder-tab-wrap.dragging { opacity: 0.5; }
        .folder-tabs.manage-mode .folder-tab-wrap.drag-over { outline: 2px solid var(--accent); outline-offset: 2px; border-radius: var(--radius-sm); }
        .folder-tab-rename { width: 6rem; padding: 0.2rem 0.4rem; font-size: 0.85rem; background: var(--surface); border: 1px solid var(--accent); border-radius: var(--radius-sm); color: var(--text); }
        .folders-admin { margin-bottom: 0.75rem; }
        .folders-admin .row { gap: 0.35rem; }
        .sound-filter-row { margin-bottom: 0.75rem; }
        .sound-filter-input { width: 100%; max-width: 320px; padding: 0.5rem 0.65rem; background: var(--surface-hover); border: 1px solid var(--border); border-radius: var(--radius-sm); color: var(--text); font-size: 0.9rem; }
        .sound-filter-input::placeholder { color: var(--text-muted); }
        .sound-filter-input:focus { outline: none; border-color: var(--accent); }
        .top-bar-lock { display: inline-flex; align-items: center; gap: 0.5rem; margin-left: 0.5rem; font-size: 0.85rem; color: var(--text-muted); cursor: pointer; }
        .top-bar-lock input[type="checkbox"] { width: 1rem; height: 1rem; accent-color: var(--accent); }
        .sound-panel { margin-top: 1rem; padding: 1rem; background: var(--surface-hover); border-radius: var(--radius-sm); border: 1px solid var(--border); }
        .sound-panel .row { margin-bottom: 0.5rem; }
        .sound-panel label { font-size: 0.85rem; color: var(--text-muted); min-width: 5rem; }
        .sound-panel input, .sound-panel select { flex: 1; padding: 0.4rem 0.5rem; background: var(--surface); border: 1px solid var(--border); border-radius: var(--radius-sm); color: var(--text); font-size: 0.9rem; }
        .sound-drag-handle { display: none; position: absolute; left: 4px; top: 50%; transform: translateY(-50%); width: 20px; color: var(--text-muted); font-size: 0.9rem; user-select: none; }
        .sound-grid.reorder-mode .sound-drag-handle { display: block; }
        .sound-item-selected { outline: 2px solid var(--accent); outline-offset: 2px; }
        .superadmin-only { }
        .guest-history-table td { padding: 0.35rem 0.5rem; border-bottom: 1px solid var(--border); }
        .guest-history-table .block-btn { padding: 0.2rem 0.5rem; font-size: 0.75rem; }
        .blocked-ips-list .ip-row { display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.35rem; }
    </style>
</head>
<body>
    <div class="login-screen" id="loginScreen">
        <div class="login-card">
            <h1>üîä Soundboard</h1>
            <form id="loginForm" onsubmit="return doLogin(event)">
                <label for="loginUser">Username</label>
                <input type="text" id="loginUser" name="username" placeholder="Username" autocomplete="username" required>
                <label for="loginPass">Password</label>
                <input type="password" id="loginPass" name="password" placeholder="Password" autocomplete="current-password" required>
                <button type="submit" class="btn btn-primary">Log in</button>
                <div class="login-error" id="loginError"></div>
                <div class="guest-divider" id="guestDivider" style="display:none; margin: 1rem 0; text-align: center; color: var(--text-muted); font-size: 0.85rem;">‚Äî or ‚Äî</div>
                <button type="button" class="btn btn-ghost" id="guestBtn" style="display:none; width:100%;" onclick="doGuestLogin()">Continue as guest</button>
            </form>
        </div>
    </div>

    <div class="app" id="app">
        <div class="header-row">
            <h1>üîä Soundboard</h1>
            <div class="header-right">
                <div class="main-tabs superadmin-only hidden" id="mainTabs">
                    <button type="button" class="main-tab active" data-tab="sounds" onclick="switchMainTab('sounds')">Sounds</button>
                    <button type="button" class="main-tab" data-tab="superadmin" onclick="switchMainTab('superadmin')">Superadmin</button>
                </div>
                <div class="user-badge">Logged in as <span id="currentUsername">‚Äî</span> <span id="currentRole">(admin)</span> <button type="button" class="btn btn-ghost" style="padding: 0.35rem 0.5rem; font-size: 0.8rem;" onclick="logout()">Log out</button></div>
            </div>
        </div>

        <div id="soundsView" class="main-view">
        <div class="top-actions" id="topActions">
            <button type="button" class="btn btn-danger" id="stopAllBtn" onclick="stopPlayback()" title="Stop playback">‚èπ Stop</button>
            <label class="top-bar-lock admin-only" title="Lock playback for users (superadmin locks everyone)">
                <span class="top-bar-lock-label">Lock playback</span>
                <input type="checkbox" id="playbackLockedTop" onchange="setPlaybackLocked(this.checked)">
            </label>
        </div>

        <div class="card admin-only" id="connectionCard">
            <div class="card-title">Connection</div>
            <div class="row">
                <select id="channelSelect"><option>Loading channels...</option></select>
                <button type="button" class="btn btn-primary" onclick="joinChannel()">Join Channel</button>
                <button type="button" class="btn btn-danger" onclick="leaveChannel()">Leave</button>
            </div>
        </div>

        <div class="player" id="playerCard">
            <div class="card-title">Now Playing</div>
            <div class="player-now-playing" id="nowPlayingText">Nothing playing</div>
            <div class="waveform-placeholder" id="waveformPlaceholder">Waveform will appear when a sound is playing</div>
            <div class="waveform-wrap" id="waveformWrap" style="display: none;">
                <canvas id="waveformCanvas" width="600" height="48"></canvas>
            </div>
            <div class="progress-time" id="progressTime">0:00 / 0:00</div>
            <div class="player-buttons">
                <button type="button" class="btn btn-ghost btn-icon" id="playPauseBtn" onclick="togglePlayPause()" title="Play / Pause" disabled>‚ñ∂</button>
                <button type="button" class="btn btn-ghost btn-icon" id="stopBtn" onclick="stopPlayback()" title="Stop">‚èπ</button>
            </div>
        </div>

        <div class="card admin-only" id="volumeCard">
            <div class="card-title">Volume</div>
            <div class="row volume-row">
                <span class="volume-label" id="volumeLabel">50%</span>
                <input type="range" id="volumeSlider" min="0" max="1" step="0.02" value="0.5" title="Volume">
            </div>
        </div>

        <div class="card" id="uploadCard">
            <div class="card-title">Upload Sound</div>
            <div class="upload-zone" id="uploadZone">
                <label for="fileInput"><span class="browse">Browse</span> or drag a file ‚Äî MP3, WAV, OGG</label>
                <input type="file" id="fileInput" accept="audio/*">
            </div>
            <div class="upload-hint" id="uploadHint" style="font-size: 0.8rem; color: var(--text-muted); margin-top: 0.5rem;"></div>
        </div>

        <div class="card">
            <div class="sounds-card-header">
                <span class="card-title">Sounds</span>
                <div class="sounds-header-buttons">
                    <button type="button" class="btn btn-ghost toggle-btn" id="reorderBtn" onclick="toggleReorder()" title="Drag to reorder (switch to All to reorder)">Reorder</button>
                    <button type="button" class="btn btn-ghost toggle-btn admin-only" id="manageFoldersBtn" onclick="toggleManageFolders()" title="Manage folders: rename, reorder, delete">Manage folders</button>
                </div>
            </div>
            <div class="folders-admin admin-only hidden" id="foldersAdmin">
                <div class="row">
                    <input type="text" id="newFolderInput" placeholder="New folder name" style="max-width: 160px; padding: 0.4rem 0.5rem; background: var(--surface-hover); border: 1px solid var(--border); border-radius: var(--radius-sm); color: var(--text); font-size: 0.85rem;">
                    <button type="button" class="btn btn-ghost" style="padding: 0.4rem 0.6rem; font-size: 0.85rem;" onclick="addFolder()">Add folder</button>
                </div>
            </div>
            <div class="sound-filter-row">
                <input type="text" id="soundFilterInput" placeholder="Filter sounds by name..." class="sound-filter-input" autocomplete="off">
            </div>
            <div class="folder-tabs" id="folderTabs"></div>
            <div id="soundsList" class="sound-grid"></div>
            <div class="sound-panel hidden" id="soundPanel">
                <div class="card-title">Edit sound</div>
                <div class="row"><label>Name</label><input type="text" id="soundPanelName" placeholder="Display name"></div>
                <div class="row"><label>Folder</label><select id="soundPanelFolder"><option value="">(None)</option></select></div>
                <div class="row"><label>Duration</label><span id="soundPanelDuration" class="text-muted">‚Äî</span></div>
                <div class="row" style="margin-top: 0.5rem;">
                    <button type="button" class="btn btn-primary" onclick="saveSoundPanel()">Save</button>
                    <button type="button" class="btn btn-ghost" onclick="closeSoundPanel()">Close</button>
                </div>
            </div>
            <div class="user-locked-msg hidden" id="userLockedMsg">Playback is locked by an admin.</div>
        </div>
        </div>

        <div id="superadminView" class="main-view hidden">
        <div class="card" id="superadminCard">
            <div class="card-title">Guest Access</div>
            <div class="settings-row" style="margin-bottom: 0.75rem;">
                <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer;">
                    <input type="checkbox" id="guestEnabledToggle" onchange="setGuestEnabled(this.checked)">
                    <span>Allow guest access (no login, 7s max, 10s cooldown)</span>
                </label>
            </div>
            <div class="card-title" style="margin-top: 1rem;">User & Guest Uploads</div>
            <div class="settings-row" style="margin-bottom: 0.5rem;">
                <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer;">
                    <input type="checkbox" id="userUploadEnabledToggle" onchange="setUserUploadEnabled(this.checked)">
                    <span>Allow users and guests to upload (goes to moderation queue)</span>
                </label>
            </div>
            <div class="row" style="margin-bottom: 0.75rem; gap: 1rem;">
                <label style="display: flex; align-items: center; gap: 0.5rem; font-size: 0.9rem;">
                    <span>Max duration (s):</span>
                    <input type="number" id="maxUploadDurationInput" min="1" max="60" value="7" style="width: 4rem; padding: 0.35rem; background: var(--surface-hover); border: 1px solid var(--border); border-radius: var(--radius-sm); color: var(--text);" onchange="setMaxUploadDuration(this.value)">
                </label>
                <label style="display: flex; align-items: center; gap: 0.5rem; font-size: 0.9rem;">
                    <span>Max size (KB):</span>
                    <input type="number" id="maxUploadBytesInput" min="100" max="10240" value="2048" style="width: 5rem; padding: 0.35rem; background: var(--surface-hover); border: 1px solid var(--border); border-radius: var(--radius-sm); color: var(--text);" onchange="setMaxUploadBytes(this.value)">
                </label>
            </div>
            <div class="card-title" style="margin-top: 1rem;">Guest History</div>
            <div class="guest-history-table-wrap" style="max-height: 200px; overflow-y: auto; margin-bottom: 0.75rem;">
                <table class="guest-history-table" style="width:100%; font-size: 0.85rem; border-collapse: collapse;">
                    <thead><tr><th style="text-align:left; padding: 0.35rem 0.5rem;">IP</th><th style="text-align:left; padding: 0.35rem 0.5rem;">Time</th><th style="text-align:left; padding: 0.35rem 0.5rem;">Sound</th><th></th></tr></thead>
                    <tbody id="guestHistoryBody"></tbody>
                </table>
            </div>
            <div class="card-title">Blocked IPs</div>
            <div id="blockedIPsList" class="blocked-ips-list" style="font-size: 0.85rem; margin-bottom: 1rem;"></div>
            <div class="card-title">Moderation Queue</div>
            <p style="font-size: 0.85rem; color: var(--text-muted); margin-bottom: 0.5rem;">User and guest uploads await approval here.</p>
            <div class="pending-uploads-wrap" style="max-height: 220px; overflow-y: auto;">
                <table class="guest-history-table" style="width:100%; font-size: 0.85rem; border-collapse: collapse;">
                    <thead><tr><th style="text-align:left; padding: 0.35rem 0.5rem;">File</th><th style="text-align:left; padding: 0.35rem 0.5rem;">By</th><th style="text-align:left; padding: 0.35rem 0.5rem;">Time</th><th></th></tr></thead>
                    <tbody id="pendingUploadsBody"></tbody>
                </table>
            </div>
            <div id="pendingUploadsEmpty" class="pending-empty" style="font-size: 0.85rem; color: var(--text-muted); padding: 0.5rem;">No pending uploads</div>
        </div>
        </div>
    </div>

    <script>
        const CREDENTIALS = 'include';
        const MAX_USER_DURATION = 7;
        const GUEST_COOLDOWN_SEC = 10;
        let user = null;
        let playback = { status: 'idle', filename: null, displayName: null, startTime: null, duration: null, startTimeOffset: 0, startedBy: null };
        let playbackLockedBy = null;
        let guestLastPlayTime = 0;
        let guestEnabled = false;
        let userUploadEnabled = false;
        let maxUploadDuration = 7;
        let maxUploadBytes = 2097152;
        let pausedAt = 0;
        let waveformData = null;
        let waveformDuration = 0;
        let reorderMode = false;
        let playbackLocked = false;
        let soundsList = [];
        let foldersList = [];
        let selectedFolder = null;
        let selectedSound = null;
        let manageFoldersMode = false;
        let soundFilter = '';
        let lastGuestCooldownShown = -1;

        async function api(path, opts = {}) {
            const res = await fetch(path, { credentials: CREDENTIALS, ...opts });
            if (res.status === 401) { showLogin(); return null; }
            return res;
        }

        function isAdminOrSuperadmin() { return user?.role === 'admin' || user?.role === 'superadmin'; }

        function switchMainTab(tab) {
            document.querySelectorAll('.main-tab').forEach(t => t.classList.toggle('active', t.dataset.tab === tab));
            document.getElementById('soundsView').classList.toggle('hidden', tab !== 'sounds');
            document.getElementById('superadminView').classList.toggle('hidden', tab !== 'superadmin');
            if (tab === 'superadmin') { fetchGuestHistory(); fetchBlockedIPs(); fetchPendingUploads(); }
        }

        async function checkAuth() {
            const res = await api('/api/me');
            if (!res) return false;
            if (res.ok) {
                user = await res.json();
                document.getElementById('loginScreen').classList.add('hidden');
                document.getElementById('app').classList.remove('hidden');
                document.getElementById('currentUsername').textContent = user.username;
                document.getElementById('currentRole').textContent = '(' + (user.role || 'user') + ')';
                if (user.role === 'user' || user.role === 'guest') {
                    document.querySelectorAll('.admin-only').forEach(el => el.classList.add('hidden'));
                    document.querySelectorAll('.superadmin-only').forEach(el => el.classList.add('hidden'));
                    document.getElementById('topActions').classList.add('hidden');
                    document.getElementById('playPauseBtn').classList.add('hidden');
                    document.getElementById('stopBtn').classList.add('hidden');
                } else {
                    document.getElementById('topActions').classList.remove('hidden');
                    document.getElementById('playPauseBtn').classList.remove('hidden');
                    document.getElementById('stopBtn').classList.remove('hidden');
                    document.querySelectorAll('.admin-only').forEach(el => el.classList.remove('hidden'));
                    if (user.role === 'superadmin') document.querySelectorAll('.superadmin-only').forEach(el => el.classList.remove('hidden'));
                    else document.querySelectorAll('.superadmin-only').forEach(el => el.classList.add('hidden'));
                }
                fetchSettings();
                if (user?.role === 'superadmin') { fetchGuestHistory(); fetchBlockedIPs(); fetchPendingUploads(); }
                updateUploadCardVisibility();
                return true;
            }
            showLogin();
            return false;
        }

        function showLogin() {
            user = null;
            document.getElementById('loginScreen').classList.remove('hidden');
            document.getElementById('app').classList.add('hidden');
            fetchGuestStatus();
        }

        async function fetchGuestStatus() {
            try {
                const res = await fetch('/api/guest-status', { credentials: CREDENTIALS });
                if (res.ok) {
                    const d = await res.json();
                    guestEnabled = d.guestEnabled === true;
                    const div = document.getElementById('guestDivider');
                    const btn = document.getElementById('guestBtn');
                    if (div && btn) { div.style.display = guestEnabled ? 'block' : 'none'; btn.style.display = guestEnabled ? 'block' : 'none'; }
                }
            } catch (e) {}
        }

        async function doGuestLogin() {
            document.getElementById('loginError').textContent = '';
            const res = await fetch('/api/guest/start', { method: 'POST', credentials: CREDENTIALS });
            const data = await res.json().catch(() => ({}));
            if (!res.ok) {
                document.getElementById('loginError').textContent = data.error || 'Guest access unavailable';
                return;
            }
            await checkAuth();
            startPlaybackPolling();
            fetchSounds();
            fetchFolders();
            return false;
        }

        async function doLogin(e) {
            e.preventDefault();
            const username = document.getElementById('loginUser').value.trim();
            const password = document.getElementById('loginPass').value;
            document.getElementById('loginError').textContent = '';
            const res = await fetch('/api/login', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                credentials: CREDENTIALS,
                body: JSON.stringify({ username, password }),
            });
            const data = await res.json().catch(() => ({}));
            if (!res.ok) {
                document.getElementById('loginError').textContent = data.error || 'Login failed';
                return false;
            }
            await checkAuth();
            startPlaybackPolling();
            fetchChannels();
            fetchSounds();
            fetchFolders();
            fetch('/api/volume', { credentials: CREDENTIALS }).then(r => r.json()).then(d => {
                const v = d.volume ?? 0.5;
                document.getElementById('volumeSlider').value = v;
                document.getElementById('volumeLabel').textContent = Math.round(v * 100) + '%';
            }).catch(() => {});
            return false;
        }

        async function logout() {
            await fetch('/api/logout', { method: 'POST', credentials: CREDENTIALS });
            showLogin();
        }

        async function fetchChannels() {
            if (!isAdminOrSuperadmin()) return;
            const res = await api('/api/channels');
            if (!res || !res.ok) return;
            const channels = await res.json();
            const select = document.getElementById('channelSelect');
            select.innerHTML = channels.map(c => `<option value="${c.id}">${c.name}</option>`).join('');
        }

        async function fetchSettings() {
            const res = await api('/api/settings');
            if (!res || !res.ok) return;
            const d = await res.json();
            playbackLocked = d.playbackLocked === true;
            playbackLockedBy = d.playbackLockedBy || null;
            if (d.userUploadEnabled !== undefined) userUploadEnabled = d.userUploadEnabled;
            if (d.maxUploadDuration !== undefined) maxUploadDuration = d.maxUploadDuration;
            if (d.maxUploadBytes !== undefined) maxUploadBytes = d.maxUploadBytes;
            const cb = document.getElementById('playbackLockedTop');
            if (cb) cb.checked = playbackLocked;
            const msg = document.getElementById('userLockedMsg');
            if (msg) {
                if ((user?.role === 'user' || user?.role === 'guest') && playbackLocked) {
                    msg.textContent = playbackLockedBy === 'superadmin' ? 'Playback is locked by a superadmin.' : 'Playback is locked by an admin.';
                    msg.classList.remove('hidden');
                } else {
                    msg.classList.add('hidden');
                }
            }
            if (user?.role === 'superadmin') {
                if (d.guestEnabled !== undefined) { guestEnabled = d.guestEnabled; const g = document.getElementById('guestEnabledToggle'); if (g) g.checked = guestEnabled; }
                if (d.userUploadEnabled !== undefined) { const g = document.getElementById('userUploadEnabledToggle'); if (g) g.checked = d.userUploadEnabled; }
                if (d.maxUploadDuration !== undefined) { const g = document.getElementById('maxUploadDurationInput'); if (g) g.value = d.maxUploadDuration; }
                if (d.maxUploadBytes !== undefined) { const g = document.getElementById('maxUploadBytesInput'); if (g) g.value = Math.round(d.maxUploadBytes / 1024); }
            }
            updateUploadCardVisibility();
        }

        function updateUploadCardVisibility() {
            const card = document.getElementById('uploadCard');
            const hint = document.getElementById('uploadHint');
            if (!card || !hint) return;
            const canDirect = isAdminOrSuperadmin();
            const canPending = (user?.role === 'user' || user?.role === 'guest') && (typeof userUploadEnabled !== 'undefined' ? userUploadEnabled : false);
            if (canDirect) {
                card.classList.remove('hidden');
                hint.textContent = '';
            } else if (canPending) {
                card.classList.remove('hidden');
                const maxSec = maxUploadDuration || 7;
                const maxKB = Math.round((maxUploadBytes || 2097152) / 1024);
                hint.textContent = 'Uploads go to a moderation queue. Max ' + maxSec + 's, ' + maxKB + 'KB. A superadmin must approve before they appear.';
            } else {
                card.classList.add('hidden');
                hint.textContent = '';
            }
        }

        async function setGuestEnabled(enabled) {
            const res = await api('/api/settings', { method: 'PATCH', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ guestEnabled: enabled }) });
            if (!res || !res.ok) return;
            guestEnabled = enabled;
            await fetchSettings();
        }

        async function setUserUploadEnabled(enabled) {
            const res = await api('/api/settings', { method: 'PATCH', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ userUploadEnabled: enabled }) });
            if (!res || !res.ok) return;
            userUploadEnabled = enabled;
            await fetchSettings();
            updateUploadCardVisibility();
        }

        async function setMaxUploadDuration(sec) {
            const n = parseInt(sec, 10);
            if (!Number.isFinite(n) || n < 1) return;
            await api('/api/settings', { method: 'PATCH', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ maxUploadDuration: n }) });
            await fetchSettings();
        }

        async function setMaxUploadBytes(kb) {
            const n = parseInt(kb, 10);
            if (!Number.isFinite(n) || n < 100) return;
            await api('/api/settings', { method: 'PATCH', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ maxUploadBytes: n * 1024 }) });
            await fetchSettings();
        }

        async function fetchGuestHistory() {
            const res = await api('/api/guest/history');
            if (!res || !res.ok) return;
            const history = await res.json();
            const tbody = document.getElementById('guestHistoryBody');
            if (!tbody) return;
            const esc = (x) => (x ?? '').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
            tbody.innerHTML = history.slice(0, 100).map(h => {
                const dt = new Date(h.timestamp);
                const timeStr = dt.toLocaleString();
                const ip = esc(h.ip);
                return '<tr><td>' + ip + '</td><td>' + esc(timeStr) + '</td><td>' + esc(h.displayName || h.filename) + '</td><td><button type="button" class="btn btn-ghost block-btn" data-ip="' + ip + '" onclick="blockGuestIP(this.dataset.ip)">Block</button></td></tr>';
            }).join('');
        }

        async function fetchBlockedIPs() {
            const res = await api('/api/guest/blocked');
            if (!res || !res.ok) return;
            const ips = await res.json();
            const el = document.getElementById('blockedIPsList');
            if (!el) return;
            const esc = (x) => (x ?? '').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
            if (ips.length === 0) { el.innerHTML = '<span style="color:var(--text-muted)">None</span>'; return; }
            el.innerHTML = ips.map(ip => '<div class="ip-row"><span>' + esc(ip) + '</span><button type="button" class="btn btn-ghost block-btn" data-ip="' + esc(ip) + '" onclick="unblockGuestIP(this.dataset.ip)">Unblock</button></div>').join('');
        }

        async function blockGuestIP(ip) {
            const res = await api('/api/guest/block-ip', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ ip }) });
            if (res && res.ok) fetchBlockedIPs();
        }

        async function unblockGuestIP(ip) {
            const res = await api('/api/guest/block-ip/' + encodeURIComponent(ip), { method: 'DELETE' });
            if (res && res.ok) fetchBlockedIPs();
        }

        async function fetchPendingUploads() {
            const res = await api('/api/superadmin/pending-uploads');
            if (!res || !res.ok) return;
            const uploads = await res.json();
            const tbody = document.getElementById('pendingUploadsBody');
            const empty = document.getElementById('pendingUploadsEmpty');
            if (!tbody || !empty) return;
            const esc = (x) => (x ?? '').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
            if (uploads.length === 0) {
                tbody.innerHTML = '';
                empty.classList.remove('hidden');
                return;
            }
            empty.classList.add('hidden');
            tbody.innerHTML = uploads.map(u => {
                const dt = new Date(u.uploadedAt);
                const by = u.uploadedBy || (u.uploadedByIP ? 'guest' : '?');
                const dur = u.duration != null ? u.duration.toFixed(1) + 's' : '‚Äî';
                const sz = u.size != null ? Math.round(u.size / 1024) + 'KB' : '‚Äî';
                return '<tr><td><a href="/api/superadmin/pending-uploads/audio/' + encodeURIComponent(u.filename) + '" target="_blank" rel="noopener" style="color:var(--accent)">' + esc(u.filename) + '</a> <span style="color:var(--text-muted);font-size:0.8em">' + dur + ' ' + sz + '</span></td><td>' + esc(by) + '</td><td>' + esc(dt.toLocaleString()) + '</td><td><button type="button" class="btn btn-primary block-btn" data-filename="' + esc(u.filename) + '" onclick="approvePendingUpload(this.dataset.filename)">Approve</button> <button type="button" class="btn btn-danger block-btn" data-filename="' + esc(u.filename) + '" onclick="rejectPendingUpload(this.dataset.filename)">Reject</button></td></tr>';
            }).join('');
        }

        async function approvePendingUpload(filename) {
            const res = await api('/api/superadmin/pending-uploads/approve/' + encodeURIComponent(filename), { method: 'POST' });
            if (res && res.ok) { fetchPendingUploads(); fetchSounds(); }
            else if (res) { const d = await res.json().catch(() => ({})); alert(d.error || 'Failed'); }
        }

        async function rejectPendingUpload(filename) {
            const res = await api('/api/superadmin/pending-uploads/reject/' + encodeURIComponent(filename), { method: 'DELETE' });
            if (res && res.ok) fetchPendingUploads();
        }

        async function setPlaybackLocked(locked) {
            const res = await api('/api/settings', { method: 'PATCH', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ playbackLocked: locked }) });
            if (!res || !res.ok) return;
            playbackLocked = locked;
            await fetchSettings();
            if (user?.role === 'user' || user?.role === 'guest') fetchSounds();
        }

        function getGuestCooldownRemaining() {
            if (user?.role !== 'guest') return 0;
            const elapsed = (Date.now() - guestLastPlayTime) / 1000;
            return Math.max(0, Math.ceil(GUEST_COOLDOWN_SEC - elapsed));
        }

        function toggleReorder() {
            if (selectedFolder != null) { alert('Switch to "All" to reorder sounds.'); return; }
            reorderMode = !reorderMode;
            const btn = document.getElementById('reorderBtn');
            const grid = document.getElementById('soundsList');
            if (btn) btn.classList.toggle('active', reorderMode);
            if (grid) grid.classList.toggle('reorder-mode', reorderMode);
            renderSoundsGrid();
        }

        function setupSoundGridDragDrop(grid) {
            if (!grid || grid.dataset.dragSetup) return;
            grid.dataset.dragSetup = '1';
            grid.addEventListener('dragstart', (e) => {
                if (!reorderMode) return;
                const wrap = e.target.closest('.sound-item-wrap');
                if (!wrap) return;
                e.dataTransfer.setData('text/plain', wrap.dataset.filename || '');
                e.dataTransfer.effectAllowed = 'move';
                e.stopPropagation();
                wrap.classList.add('dragging');
            });
            grid.addEventListener('dragend', (e) => {
                e.target.closest('.sound-item-wrap')?.classList.remove('dragging');
                grid.querySelectorAll('.sound-item-wrap').forEach(el => el.classList.remove('drag-over'));
            });
            grid.addEventListener('dragover', (e) => {
                if (!reorderMode) return;
                e.preventDefault();
                e.stopPropagation();
                e.dataTransfer.dropEffect = 'move';
                const wrap = e.target.closest('.sound-item-wrap');
                grid.querySelectorAll('.sound-item-wrap').forEach(el => el.classList.remove('drag-over'));
                if (wrap) wrap.classList.add('drag-over');
            });
            grid.addEventListener('drop', async (e) => {
                if (!reorderMode) return;
                e.preventDefault();
                e.stopPropagation();
                const fromFilename = e.dataTransfer.getData('text/plain');
                const toWrap = e.target.closest('.sound-item-wrap');
                grid.querySelectorAll('.sound-item-wrap').forEach(el => el.classList.remove('drag-over'));
                if (!fromFilename || !toWrap) return;
                const wraps = [...grid.querySelectorAll('.sound-item-wrap')];
                const fromIdx = wraps.findIndex(w => w.dataset.filename === fromFilename);
                const toIdx = wraps.findIndex(w => w === toWrap);
                if (fromIdx === -1 || toIdx === -1 || fromIdx === toIdx) return;
                const order = wraps.map(w => w.dataset.filename);
                const [removed] = order.splice(fromIdx, 1);
                order.splice(toIdx, 0, removed);
                const res = await api('/api/sounds/order', { method: 'PATCH', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ order }) });
                if (res && res.ok) fetchSounds();
            });
        }

        async function fetchFolders() {
            const res = await api('/api/folders');
            if (!res || !res.ok) return;
            foldersList = await res.json();
            renderFolderTabs();
        }

        function renderFolderTabs() {
            const container = document.getElementById('folderTabs');
            const isAdmin = isAdminOrSuperadmin();
            const showManage = isAdmin && manageFoldersMode;
            const esc = (x) => (x ?? '').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
            let html = '<button type="button" class="folder-tab' + (selectedFolder === null ? ' active' : '') + '" data-folder="" onclick="selectFolder(null)">All</button>';
            (foldersList || []).forEach(f => {
                const active = selectedFolder === f;
                if (showManage) {
                    html += '<div class="folder-tab-wrap" data-folder="' + esc(f) + '" draggable="true">';
                    html += '<button type="button" class="folder-tab' + (active ? ' active' : '') + '" data-folder="' + esc(f) + '" onclick="selectFolder(this.dataset.folder)" ondblclick="event.preventDefault(); startRenameFolder(this.dataset.folder)" title="Double-click to rename">' + esc(f) + '</button>';
                    html += '<button type="button" class="folder-tab delete" data-folder="' + esc(f) + '" onclick="event.stopPropagation(); deleteFolder(this.dataset.folder)" title="Delete folder">‚úï</button>';
                    html += '</div>';
                } else {
                    html += '<button type="button" class="folder-tab' + (active ? ' active' : '') + '" data-folder="' + esc(f) + '" onclick="selectFolder(this.dataset.folder)">' + esc(f) + '</button>';
                }
            });
            container.innerHTML = html;
            container.classList.toggle('manage-mode', showManage);
            document.getElementById('manageFoldersBtn')?.classList.toggle('active', manageFoldersMode);
            document.getElementById('foldersAdmin')?.classList.toggle('hidden', !showManage);
            if (showManage) setupFolderTabDragDrop(container);
        }

        function setupFolderTabDragDrop(container) {
            container.addEventListener('dragstart', (e) => {
                const wrap = e.target.closest('.folder-tab-wrap');
                if (!wrap) return;
                e.dataTransfer.setData('text/plain', wrap.dataset.folder || '');
                e.dataTransfer.effectAllowed = 'move';
                e.stopPropagation();
                wrap.classList.add('dragging');
            });
            container.addEventListener('dragend', (e) => {
                e.target.closest('.folder-tab-wrap')?.classList.remove('dragging');
                container.querySelectorAll('.folder-tab-wrap').forEach(el => el.classList.remove('drag-over'));
            });
            container.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.stopPropagation();
                e.dataTransfer.dropEffect = 'move';
                const wrap = e.target.closest('.folder-tab-wrap');
                container.querySelectorAll('.folder-tab-wrap').forEach(el => el.classList.remove('drag-over'));
                if (wrap) wrap.classList.add('drag-over');
            });
            container.addEventListener('drop', async (e) => {
                e.preventDefault();
                e.stopPropagation();
                const fromName = e.dataTransfer.getData('text/plain');
                const toWrap = e.target.closest('.folder-tab-wrap');
                container.querySelectorAll('.folder-tab-wrap').forEach(el => el.classList.remove('drag-over'));
                if (!fromName || !toWrap) return;
                const wraps = [...container.querySelectorAll('.folder-tab-wrap')];
                const fromIdx = wraps.findIndex(w => w.dataset.folder === fromName);
                const toIdx = wraps.findIndex(w => w === toWrap);
                if (fromIdx === -1 || toIdx === -1 || fromIdx === toIdx) return;
                const order = wraps.map(w => w.dataset.folder);
                const [removed] = order.splice(fromIdx, 1);
                order.splice(toIdx, 0, removed);
                const res = await api('/api/folders', { method: 'PATCH', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ folders: order }) });
                if (res && res.ok) { foldersList = await res.json(); renderFolderTabs(); fetchSounds(); }
            });
        }

        function toggleManageFolders() {
            manageFoldersMode = !manageFoldersMode;
            renderFolderTabs();
        }

        function startRenameFolder(currentName) {
            const container = document.getElementById('folderTabs');
            const wrap = container ? [...container.querySelectorAll('.folder-tab-wrap')].find(w => w.dataset.folder === currentName) : null;
            if (!wrap) return;
            const tabBtn = wrap.querySelector('.folder-tab:not(.delete)');
            if (!tabBtn) return;
            const input = document.createElement('input');
            input.type = 'text';
            input.className = 'folder-tab-rename';
            input.value = currentName;
            tabBtn.style.display = 'none';
            wrap.insertBefore(input, tabBtn);
            input.focus();
            input.select();
            function finish() {
                const newName = input.value.trim();
                input.remove();
                tabBtn.style.display = '';
                if (newName && newName !== currentName) {
                    api('/api/folders/rename', { method: 'PATCH', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ oldName: currentName, newName }) }).then(async (res) => {
                        if (res && res.ok) {
                            const data = await res.json().catch(() => ({}));
                            if (data.folders) foldersList = data.folders;
                            else await fetchFolders();
                            if (selectedFolder === currentName) selectedFolder = newName;
                            renderFolderTabs();
                            fetchSounds();
                        }
                    });
                }
            }
            input.addEventListener('blur', finish);
            input.addEventListener('keydown', (e) => { if (e.key === 'Enter') finish(); if (e.key === 'Escape') { input.value = currentName; finish(); } });
        }

        function selectFolder(folder) {
            selectedFolder = folder || null;
            renderFolderTabs();
            renderSoundsGrid();
        }

        async function addFolder() {
            const input = document.getElementById('newFolderInput');
            const name = (input?.value || '').trim();
            if (!name) return;
            const next = [...(foldersList || []), name];
            const res = await api('/api/folders', { method: 'PATCH', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ folders: next }) });
            if (!res || !res.ok) return;
            foldersList = next;
            if (input) input.value = '';
            renderFolderTabs();
        }

        async function deleteFolder(name) {
            if (!confirm('Delete folder "' + name + '"? Sounds in it will move to All.')) return;
            const res = await api('/api/folders/' + encodeURIComponent(name), { method: 'DELETE' });
            if (!res || !res.ok) return;
            foldersList = (foldersList || []).filter(f => f !== name);
            if (selectedFolder === name) selectedFolder = null;
            renderFolderTabs();
            fetchSounds();
        }

        async function fetchSounds() {
            const res = await api('/api/sounds');
            if (!res || !res.ok) return;
            const sounds = await res.json();
            soundsList = sounds;
            renderSoundsGrid();
        }

        function renderSoundsGrid() {
            const grid = document.getElementById('soundsList');
            let filtered = selectedFolder != null ? soundsList.filter(s => (s.folder || null) === selectedFolder) : soundsList;
            const q = (soundFilter || '').trim().toLowerCase();
            if (q) {
                filtered = filtered.filter(s => {
                    const title = (s.displayName || s.filename || '').toLowerCase();
                    return title.includes(q);
                });
            }
            const isUser = user?.role === 'user';
            const isGuest = user?.role === 'guest';
            const guestCooldown = getGuestCooldownRemaining();
            const canPlay = (!isUser && !isGuest) || ((!playbackLocked) && (isGuest ? guestCooldown === 0 : true));
            const tooLong = (dur) => (isUser || isGuest) && dur != null && dur > MAX_USER_DURATION;
            const isAdmin = isAdminOrSuperadmin();
            grid.innerHTML = filtered.map((s, idx) => {
                const esc = (x) => (x ?? '').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#39;');
                const name = esc(s.displayName || s.filename);
                const filename = esc(s.filename);
                const dur = s.duration;
                const disabled = !canPlay || tooLong(dur);
                const selected = selectedSound === s.filename ? ' sound-item-selected' : '';
                let title = '';
                if (!canPlay) title = playbackLocked ? 'Playback is locked' : (isGuest && guestCooldown > 0 ? 'Wait ' + guestCooldown + 's before playing again' : 'Cannot play');
                else if (tooLong(dur)) title = 'Only sounds 7s or shorter allowed';
                const inner = `
                    <div class="sound-item${selected}" data-filename="${filename}" data-index="${idx}">
                        <span class="sound-drag-handle" data-filename="${filename}" title="Drag to reorder">‚ãÆ‚ãÆ</span>
                        <button type="button" class="sound-btn ${disabled ? 'disabled' : ''}" data-filename="${filename}" data-displayname="${name}" data-duration="${dur ?? ''}" data-folder="${esc(s.folder || '')}" ${disabled ? 'disabled' : ''} title="${title}" onclick="playSound(this.dataset.filename)">
                            <span class="sound-btn-label">${name}</span>
                            <span class="sound-btn-duration">${dur != null ? formatTime(dur) : '‚Äî'}</span>
                        </button>
                        ${isAdmin && !reorderMode ? `<button type="button" class="sound-edit" data-filename="${filename}" title="Edit sound" onclick="event.stopPropagation(); openSoundPanelFromSound(this.dataset.filename)"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/></svg></button>` : ''}
                    </div>`;
                return `<div class="sound-item-wrap" data-filename="${filename}" ${reorderMode && isAdmin ? 'draggable="true"' : ''}>${inner}</div>`;
            }).join('');
            grid.classList.toggle('reorder-mode', reorderMode);
            const msg = document.getElementById('userLockedMsg');
            if (msg && (isUser || isGuest) && playbackLocked) msg.classList.remove('hidden');
            else if (msg) msg.classList.add('hidden');
        }

        function editSoundName(btn) {
            const filename = btn.dataset.filename;
            const currentName = btn.dataset.displayname || filename;
            const currentFolder = btn.dataset.folder || '';
            const newName = prompt('Button label:', currentName);
            if (newName === null) return;
            let newFolder = currentFolder;
            if (isAdminOrSuperadmin() && foldersList.length > 0) {
                const msg = 'Folder (number or name, or leave blank for None):\n' + foldersList.map((f, i) => (i + 1) + ' = ' + f).join('\n');
                const folderPrompt = prompt(msg, currentFolder || '');
                if (folderPrompt !== null) {
                    const trimmed = folderPrompt.trim();
                    if (trimmed === '') newFolder = '';
                    else if (foldersList.includes(trimmed)) newFolder = trimmed;
                    else if (/^\d+$/.test(trimmed)) { const n = parseInt(trimmed, 10); if (n >= 1 && n <= foldersList.length) newFolder = foldersList[n - 1]; }
                    else if (trimmed) newFolder = trimmed;
                }
            }
            fetch('/api/sounds/metadata', {
                method: 'PATCH',
                headers: { 'Content-Type': 'application/json' },
                credentials: CREDENTIALS,
                body: JSON.stringify({ filename, displayName: newName.trim() || filename, folder: newFolder || null }),
            }).then(() => { fetchSounds(); fetchFolders(); });
        }

        function openSoundPanel(s) {
            const panel = document.getElementById('soundPanel');
            const nameEl = document.getElementById('soundPanelName');
            const folderEl = document.getElementById('soundPanelFolder');
            const durEl = document.getElementById('soundPanelDuration');
            if (!panel || !nameEl || !folderEl) return;
            nameEl.value = (s && (s.displayName || s.filename)) || '';
            nameEl.dataset.filename = (s && s.filename) || '';
            durEl.textContent = (s && s.duration != null) ? formatTime(s.duration) : '‚Äî';
            folderEl.innerHTML = '<option value="">(None)</option>' + (foldersList || []).map(f => '<option value="' + (f.replace(/&/g, '&amp;').replace(/"/g, '&quot;')) + '">' + (f.replace(/&/g, '&amp;').replace(/</g, '&lt;')) + '</option>').join('');
            folderEl.value = (s && s.folder) || '';
            panel.classList.remove('hidden');
        }

        function openSoundPanelFromSound(filename) {
            const s = soundsList.find(x => x.filename === filename);
            selectedSound = filename;
            renderSoundsGrid();
            openSoundPanel(s || { filename, displayName: filename, duration: null, folder: null });
        }

        function closeSoundPanel() {
            selectedSound = null;
            document.getElementById('soundPanel')?.classList.add('hidden');
            renderSoundsGrid();
        }

        async function saveSoundPanel() {
            const nameEl = document.getElementById('soundPanelName');
            const folderEl = document.getElementById('soundPanelFolder');
            const filename = nameEl?.dataset.filename;
            if (!filename) return;
            const displayName = (nameEl?.value || '').trim() || filename;
            const folder = (folderEl?.value || '').trim() || null;
            const res = await api('/api/sounds/metadata', {
                method: 'PATCH',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ filename, displayName, folder }),
            });
            if (res && res.ok) { fetchSounds(); fetchFolders(); nameEl.dataset.filename = filename; }
        }

        async function joinChannel() {
            const channelId = document.getElementById('channelSelect').value;
            await api('/api/join', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ channelId }) });
        }

        async function leaveChannel() {
            await api('/api/leave', { method: 'POST' });
        }

        async function playSound(filename, startTime) {
            const body = { filename };
            if (typeof startTime === 'number' && startTime > 0) body.startTime = startTime;
            const res = await api('/api/play', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(body) });
            if (!res) return;
            const data = await res.json().catch(() => ({}));
            if (!res.ok) {
                const msg = data.error || data.message || 'Failed to play';
                if (res.status === 429 && data.cooldownRemaining) {
                    guestLastPlayTime = Date.now() - (GUEST_COOLDOWN_SEC - data.cooldownRemaining) * 1000;
                    renderSoundsGrid();
                }
                alert(msg);
                return;
            }
            if (user?.role === 'guest') guestLastPlayTime = Date.now();
            playback.duration = data.duration ?? null;
            playback.startTime = Date.now();
            playback.startTimeOffset = data.startTimeOffset ?? 0;
            playback.status = 'playing';
            playback.displayName = data.displayName ?? filename;
            playback.filename = filename;
            playback.startedBy = data.startedBy ?? { username: user?.username, role: user?.role };
            pausedAt = 0;
            updateNowPlaying();
            updatePlayPauseButton();
            const timeEl = document.getElementById('progressTime');
            if (timeEl) timeEl.textContent = '0:00 / ' + (playback.duration != null ? formatTime(playback.duration) : '0:00');
            loadWaveform(filename);
        }

        async function loadWaveform(filename) {
            waveformData = null;
            waveformDuration = 0;
            document.getElementById('waveformPlaceholder').style.display = 'block';
            document.getElementById('waveformWrap').style.display = 'none';
            if (!filename) return;
            try {
                const res = await fetch('/api/sounds/audio/' + encodeURIComponent(filename), { credentials: CREDENTIALS });
                if (!res.ok) return;
                const buf = await res.arrayBuffer();
                const ctx = new (window.AudioContext || window.webkitAudioContext)();
                const decoded = await ctx.decodeAudioData(buf);
                const ch = decoded.getChannelData(0);
                const duration = decoded.duration;
                const bars = 120;
                const step = Math.floor(ch.length / bars);
                const peaks = [];
                for (let i = 0; i < bars; i++) {
                    let min = 0, max = 0;
                    for (let j = 0; j < step; j++) {
                        const v = ch[i * step + j];
                        if (v < min) min = v;
                        if (v > max) max = v;
                    }
                    peaks.push({ min, max });
                }
                waveformData = peaks;
                waveformDuration = duration;
                document.getElementById('waveformPlaceholder').style.display = 'none';
                document.getElementById('waveformWrap').style.display = 'block';
                drawWaveform(playback.startTimeOffset || 0);
            } catch (e) {
                console.warn('Waveform load failed', e);
            }
        }

        function drawWaveform(currentTime) {
            const canvas = document.getElementById('waveformCanvas');
            const wrap = document.getElementById('waveformWrap');
            if (!wrap || wrap.style.display === 'none' || !waveformData || !waveformData.length) return;
            const w = wrap.clientWidth || 600;
            const h = 48;
            canvas.width = w;
            canvas.height = h;
            const ctx = canvas.getContext('2d');
            const barCount = waveformData.length;
            const barW = Math.max(1, (w / barCount) - 1);
            const progress = waveformDuration > 0 ? Math.min(1, currentTime / waveformDuration) : 0;
            const playheadX = progress * w;
            ctx.clearRect(0, 0, w, h);
            waveformData.forEach((peak, i) => {
                const x = (i / barCount) * w;
                const center = h / 2;
                const halfH = Math.max(1, (Math.abs(peak.max - peak.min) / 2) * (h * 0.4));
                const isPast = x + barW < playheadX;
                ctx.fillStyle = isPast ? 'rgba(124, 58, 237, 0.6)' : 'rgba(42, 42, 50, 0.8)';
                ctx.fillRect(x, center - halfH, barW, halfH * 2);
            });
            ctx.fillStyle = 'rgba(255,255,255,0.9)';
            ctx.fillRect(Math.floor(playheadX), 0, 2, h);
        }

        function getCurrentPlaybackTime() {
            if (playback.status === 'playing' && playback.startTime != null) {
                const start = Number(playback.startTime);
                if (!Number.isFinite(start)) return 0;
                const offset = playback.startTimeOffset || 0;
                let current = offset + (Date.now() - start) / 1000;
                if (playback.duration != null) current = Math.min(current, playback.duration);
                return Math.max(0, current);
            }
            if (playback.status === 'paused') return pausedAt;
            return 0;
        }

        function tickWaveform() {
            const isActive = playback.status === 'playing' || playback.status === 'paused';
            if (isActive) {
                const current = getCurrentPlaybackTime();
                const timeEl = document.getElementById('progressTime');
                const dur = playback.duration;
                if (timeEl) timeEl.textContent = formatTime(current) + ' / ' + (dur != null ? formatTime(dur) : '‚Äî');
            }
            if (waveformData && waveformDuration > 0 && isActive) {
                const current = getCurrentPlaybackTime();
                drawWaveform(Math.min(current, waveformDuration));
            }
            if (user?.role === 'guest') {
                const r = getGuestCooldownRemaining();
                if (r > 0 && r !== lastGuestCooldownShown) { lastGuestCooldownShown = r; renderSoundsGrid(); }
                else if (r === 0 && lastGuestCooldownShown > 0) { lastGuestCooldownShown = 0; renderSoundsGrid(); }
                else if (r === 0) lastGuestCooldownShown = -1;
            }
        }

        async function stopPlayback() {
            const res = await api('/api/stop', { method: 'POST' });
            if (!res) return;
            playback = { status: 'idle', filename: null, displayName: null, startTime: null, duration: null, startTimeOffset: 0, startedBy: null };
            pausedAt = 0;
            waveformData = null;
            waveformDuration = 0;
            document.getElementById('waveformPlaceholder').style.display = 'block';
            document.getElementById('waveformPlaceholder').textContent = 'Waveform will appear when a sound is playing';
            document.getElementById('waveformWrap').style.display = 'none';
            updateNowPlaying();
            updatePlayPauseButton();
        }

        async function togglePlayPause() {
            if (playback.status === 'playing') {
                await api('/api/pause', { method: 'POST' });
                const offset = playback.startTimeOffset || 0;
                pausedAt = offset + (Date.now() - (playback.startTime || 0)) / 1000;
                if (playback.duration != null) pausedAt = Math.min(pausedAt, playback.duration);
                playback.status = 'paused';
            } else if (playback.status === 'paused') {
                await api('/api/resume', { method: 'POST' });
                playback.startTime = Date.now() - (pausedAt * 1000);
                playback.status = 'playing';
            }
            updatePlayPauseButton();
        }

        function updatePlayPauseButton() {
            const btn = document.getElementById('playPauseBtn');
            if (!btn || btn.classList.contains('hidden')) return;
            const isActive = playback.status === 'playing' || playback.status === 'paused';
            btn.disabled = !isActive;
            btn.textContent = playback.status === 'playing' ? '‚è∏' : '‚ñ∂';
            btn.title = playback.status === 'playing' ? 'Pause' : 'Play';
            updateStopButtons();
        }

        function updateStopButtons() {
            const stopAll = document.getElementById('stopAllBtn');
            const stopBtn = document.getElementById('stopBtn');
            const isActive = playback.status === 'playing' || playback.status === 'paused';
            const adminCantStop = user?.role === 'admin' && playback.startedBy && (playback.startedBy.role === 'admin' || playback.startedBy.role === 'superadmin');
            const disabled = !isActive || adminCantStop;
            if (stopAll) { stopAll.disabled = disabled; stopAll.title = adminCantStop ? 'Only superadmin can stop admin playback' : 'Stop playback'; }
            if (stopBtn) { stopBtn.disabled = disabled; stopBtn.title = adminCantStop ? 'Only superadmin can stop admin playback' : 'Stop'; }
        }

        function updateNowPlaying() {
            const card = document.getElementById('playerCard');
            const text = document.getElementById('nowPlayingText');
            if (playback.status === 'idle' || !playback.displayName) {
                text.innerHTML = 'Nothing playing';
                card.classList.add('player-idle');
            } else {
                let html = 'Now playing: <strong>' + (playback.displayName || playback.filename || '') + '</strong>';
                if (playback.startedBy && playback.startedBy.username) {
                    html += ' <span style="color:var(--text-muted);font-weight:400">by ' + (playback.startedBy.username || '').replace(/&/g, '&amp;').replace(/</g, '&lt;') + (playback.startedBy.role ? ' (' + playback.startedBy.role + ')' : '') + '</span>';
                }
                text.innerHTML = html;
                card.classList.remove('player-idle');
            }
        }

        function formatTime(s) {
            if (s == null || !Number.isFinite(s)) return '0:00';
            const m = Math.floor(s / 60);
            const sec = Math.floor(s % 60);
            return m + ':' + (sec < 10 ? '0' : '') + sec;
        }

        let playbackPollingStarted = false;
        function startPlaybackPolling() {
            if (playbackPollingStarted) return;
            playbackPollingStarted = true;
            refreshPlaybackState();
            setTimeout(() => setInterval(refreshPlaybackState, 400), 600);
        }

        function refreshPlaybackState() {
            if (!user) return;
            api('/api/playback-state').then(async (res) => {
                if (!res || !res.ok) return;
                const state = await res.json();
                if (state.status === 'idle' && playback.status === 'playing' && playback.startTime != null) {
                    const started = Number(playback.startTime);
                    if (Number.isFinite(started) && (Date.now() - started) < 3000) return;
                }
                playback.status = state.status;
                playback.filename = state.filename;
                playback.displayName = state.displayName ?? state.filename;
                playback.startedBy = state.startedBy ?? null;
                if (state.startTime != null) playback.startTime = Number(state.startTime);
                if (state.duration != null) playback.duration = state.duration;
                if (playback.startTimeOffset === undefined) playback.startTimeOffset = 0;
                if (state.status === 'idle') { pausedAt = 0; playback.startTime = null; playback.startedBy = null; }
                updateNowPlaying();
                updatePlayPauseButton();
                updateStopButtons();

                const timeEl = document.getElementById('progressTime');
                let current = getCurrentPlaybackTime();
                const dur = playback.duration;
                timeEl.textContent = formatTime(current) + ' / ' + (dur != null ? formatTime(dur) : '‚Äî');

                if (waveformData && waveformDuration > 0) {
                    drawWaveform(Math.min(current, waveformDuration));
                }
            });
        }

        document.getElementById('waveformWrap')?.addEventListener('click', (e) => {
            if (!waveformData || waveformDuration <= 0 || !playback.filename) return;
            const canvas = document.getElementById('waveformCanvas');
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) / rect.width;
            const t = Math.max(0, Math.min(waveformDuration, x * waveformDuration));
            if (t < waveformDuration - 0.5) playSound(playback.filename, Number(t));
        });

        function setVolume(volume) {
            const v = parseFloat(volume);
            document.getElementById('volumeLabel').textContent = Math.round(v * 100) + '%';
            fetch('/api/volume', { method: 'POST', headers: { 'Content-Type': 'application/json' }, credentials: CREDENTIALS, body: JSON.stringify({ volume: v }) });
        }

        document.getElementById('volumeSlider').addEventListener('input', (e) => setVolume(e.target.value));

        document.getElementById('soundFilterInput')?.addEventListener('input', (e) => {
            soundFilter = (e.target.value || '').trim();
            renderSoundsGrid();
        });

        async function uploadSound(file) {
            const fileInput = document.getElementById('fileInput');
            const f = file || fileInput?.files?.[0];
            if (!f) return;
            const formData = new FormData();
            formData.append('soundFile', f);
            const res = await api('/api/upload', { method: 'POST', body: formData });
            if (!res) return;
            const data = await res.json().catch(() => ({}));
            if (res.ok) {
                fileInput.value = '';
                fetchSounds();
                if (data.pending) alert(data.message || 'Upload sent for moderation.');
            } else {
                alert(data.error || 'Upload failed');
            }
        }

        document.getElementById('fileInput').addEventListener('change', () => uploadSound());

        (function initUploadZone() {
            const zone = document.getElementById('uploadZone');
            if (!zone) return;
            zone.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.stopPropagation();
                e.dataTransfer.dropEffect = 'copy';
                zone.classList.add('drag-over');
            });
            zone.addEventListener('dragleave', (e) => {
                e.preventDefault();
                e.stopPropagation();
                if (!zone.contains(e.relatedTarget)) zone.classList.remove('drag-over');
            });
            zone.addEventListener('drop', (e) => {
                e.preventDefault();
                e.stopPropagation();
                zone.classList.remove('drag-over');
                const f = e.dataTransfer.files?.[0];
                if (f) uploadSound(f);
            });
        })();

        (async function init() {
            setupSoundGridDragDrop(document.getElementById('soundsList'));
            fetchGuestStatus();
            const ok = await checkAuth();
            if (!ok) return;
            startPlaybackPolling();
            setInterval(tickWaveform, 100);
            fetchChannels();
            fetchSounds();
            fetchFolders();
            updateNowPlaying();
            updatePlayPauseButton();

        })();
    </script>
</body>
</html>
