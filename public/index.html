<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Discord Soundboard</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=DM+Sans:ital,opsz,wght@0,9..40,400;0,9..40,500;0,9..40,600;0,9..40,700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg: #0f0f12;
            --surface: #18181c;
            --surface-hover: #1f1f24;
            --border: #2a2a32;
            --text: #e4e4e7;
            --text-muted: #a1a1aa;
            --accent: #7c3aed;
            --accent-hover: #6d28d9;
            --danger: #dc2626;
            --danger-hover: #b91c1c;
            --success: #22c55e;
            --radius: 12px;
            --radius-sm: 8px;
            --shadow: 0 4px 24px rgba(0,0,0,0.4);
        }
        [data-theme="light"] {
            --bg: #f4f4f5;
            --surface: #ffffff;
            --surface-hover: #e4e4e7;
            --border: #d4d4d8;
            --text: #18181b;
            --text-muted: #71717a;
            --accent: #7c3aed;
            --accent-hover: #6d28d9;
            --danger: #dc2626;
            --danger-hover: #b91c1c;
            --success: #22c55e;
            --shadow: 0 4px 24px rgba(0,0,0,0.08);
        }
        [data-theme="light"] .waveform-placeholder { color: var(--text-muted); }
        [data-theme="light"] .sound-btn:hover:not(:disabled) { background: var(--border); }
        [data-theme="light"] canvas { background: transparent; }
        [data-theme="light"] .player { background: linear-gradient(135deg, var(--surface) 0%, #f0f0f2 100%); }
        [data-theme="light"] .waveform-wrap { background: rgba(0,0,0,0.06); }
        .theme-toggle {
            position: fixed; top: 1rem; right: 1rem; z-index: 100;
            width: 36px; height: 36px; padding: 0;
            border: 1px solid var(--border); border-radius: var(--radius-sm);
            background: var(--surface); color: var(--text-muted);
            cursor: pointer; display: flex; align-items: center; justify-content: center;
            font-size: 1.1rem; transition: color 0.15s, border-color 0.15s;
        }
        .theme-toggle:hover { color: var(--accent); border-color: var(--accent); }
        * { box-sizing: border-box; }
        body {
            font-family: 'DM Sans', system-ui, sans-serif;
            margin: 0;
            min-height: 100vh;
            background: var(--bg);
            color: var(--text);
            line-height: 1.5;
        }
        .app { max-width: 720px; margin: 0 auto; padding: 1.5rem; }
        .app.hidden { display: none; }
        .hidden { display: none !important; }
        .login-screen {
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 1.5rem;
        }
        .login-screen.hidden { display: none; }
        .login-card {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            padding: 2rem;
            width: 100%;
            max-width: 360px;
            box-shadow: var(--shadow);
        }
        .login-card h1 { font-size: 1.5rem; margin: 0 0 1.5rem; }
        .login-card label { display: block; font-size: 0.85rem; color: var(--text-muted); margin-bottom: 0.35rem; }
        .login-card input {
            width: 100%;
            padding: 0.65rem 0.75rem;
            background: var(--surface-hover);
            border: 1px solid var(--border);
            border-radius: var(--radius-sm);
            color: var(--text);
            font: inherit;
            margin-bottom: 1rem;
        }
        .login-card input:focus { outline: none; border-color: var(--accent); }
        .login-card .btn { width: 100%; padding: 0.75rem; margin-top: 0.5rem; }
        .login-error { color: var(--danger); font-size: 0.85rem; margin-top: 0.5rem; }
        .header-row { display: flex; align-items: center; justify-content: space-between; flex-wrap: wrap; gap: 0.75rem; margin-bottom: 1rem; }
        .header-row { flex-wrap: wrap; }
        .header-row h1 { font-size: 1.5rem; font-weight: 700; margin: 0; letter-spacing: -0.02em; }
        .header-right { display: flex; align-items: center; gap: 1rem; flex-wrap: wrap; }
        .main-tabs { display: flex; gap: 0.25rem; }
        .main-tab { padding: 0.4rem 0.75rem; border-radius: var(--radius-sm); font-size: 0.85rem; background: var(--surface-hover); border: 1px solid var(--border); color: var(--text); cursor: pointer; position: relative; }
        .main-tab:hover { border-color: var(--accent); }
        .main-tab.active { background: var(--accent); border-color: var(--accent); color: white; }
        .main-tab .pending-badge { position: absolute; top: -4px; right: -4px; min-width: 1.1rem; height: 1.1rem; padding: 0 0.25rem; font-size: 0.7rem; font-weight: 600; line-height: 1.1rem; text-align: center; background: var(--danger); color: white; border-radius: 10px; }
        .user-badge { font-size: 0.75rem; color: var(--text-muted); }
        .user-badge span { color: var(--accent); font-weight: 500; }
        .card {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            padding: 1.25rem 1.5rem;
            margin-bottom: 1rem;
            box-shadow: var(--shadow);
        }
        .card.admin-only { }
        .card-title { font-size: 0.75rem; font-weight: 600; text-transform: uppercase; letter-spacing: 0.06em; color: var(--text-muted); margin-bottom: 0.75rem; }
        .row { display: flex; align-items: center; gap: 0.75rem; flex-wrap: wrap; }
        select {
            flex: 1; min-width: 180px;
            padding: 0.6rem 0.75rem;
            background: var(--surface-hover);
            border: 1px solid var(--border);
            border-radius: var(--radius-sm);
            color: var(--text);
            font: inherit;
            cursor: pointer;
        }
        select:focus { outline: none; border-color: var(--accent); }
        .btn {
            padding: 0.6rem 1rem;
            border: none;
            border-radius: var(--radius-sm);
            font: inherit;
            font-weight: 500;
            cursor: pointer;
            transition: background 0.15s, transform 0.05s;
        }
        .btn:active { transform: scale(0.98); }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .btn-primary { background: var(--accent); color: white; }
        .btn-primary:hover:not(:disabled) { background: var(--accent-hover); }
        .btn-danger { background: var(--danger); color: white; }
        .btn-danger:hover:not(:disabled) { background: var(--danger-hover); }
        .btn-ghost { background: var(--surface-hover); color: var(--text); }
        .btn-ghost:hover:not(:disabled) { background: var(--border); }
        .btn-icon { width: 40px; height: 40px; padding: 0; display: inline-flex; align-items: center; justify-content: center; border-radius: var(--radius-sm); }
        .btn-icon svg { width: 20px; height: 20px; }
        .player {
            background: linear-gradient(135deg, var(--surface) 0%, #1a1a20 100%);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            padding: 1rem 1.25rem;
            margin-bottom: 1rem;
        }
        .player-idle .player-controls { opacity: 0.6; }
        .player-now-playing { font-size: 0.9rem; font-weight: 500; margin-bottom: 0.5rem; color: var(--text-muted); }
        .player-now-playing strong { color: var(--text); }
        .waveform-wrap {
            height: 48px;
            background: rgba(0,0,0,0.2);
            border-radius: var(--radius-sm);
            margin-bottom: 0.5rem;
            overflow: hidden;
            position: relative;
        }
        .waveform-wrap canvas { display: block; width: 100%; height: 100%; cursor: pointer; }
        .waveform-placeholder {
            height: 48px;
            background: var(--border);
            border-radius: var(--radius-sm);
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-muted);
            font-size: 0.8rem;
        }
        .progress-time { font-size: 0.7rem; color: var(--text-muted); margin-bottom: 0.5rem; }
        .player-buttons { display: flex; align-items: center; gap: 0.5rem; }
        .volume-row { align-items: center; gap: 1rem; }
        .volume-row input[type="range"] { flex: 1; min-width: 120px; accent-color: var(--accent); height: 6px; }
        .volume-label { font-size: 0.8rem; color: var(--text-muted); min-width: 2.5rem; }
        .sound-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)); gap: 0.75rem; }
        .sound-item { position: relative; display: flex; flex-direction: column; align-items: stretch; min-height: 100px; }
        .sound-btn {
            background: var(--surface-hover);
            border: 1px solid var(--border);
            border-radius: var(--radius-sm);
            padding: 0.6rem 0.5rem 0.4rem;
            color: var(--text);
            font: inherit;
            font-size: 0.85rem;
            font-weight: 500;
            cursor: pointer;
            transition: background 0.15s, border-color 0.15s;
            text-align: center;
            word-break: break-word;
            min-height: 100px;
            height: 100px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between;
        }
        .sound-btn-label { flex: 1; display: flex; align-items: center; justify-content: center; line-height: 1.2; }
        .sound-btn-duration { font-size: 0.7rem; color: var(--text-muted); flex-shrink: 0; }
        .sound-btn:hover:not(:disabled) { background: var(--border); border-color: var(--accent); }
        .sound-btn:active:not(:disabled) { transform: scale(0.98); }
        .sound-btn.disabled { opacity: 0.5; cursor: not-allowed; }
        .sound-item-actions { position: absolute; top: 4px; right: 4px; display: flex; gap: 4px; opacity: 0; pointer-events: none; transition: opacity 0.15s; }
        .sound-item:hover .sound-item-actions { opacity: 1; pointer-events: auto; }
        .sound-preview, .sound-edit, .sound-fav {
            width: 24px; height: 24px; padding: 0;
            border: none; background: var(--surface);
            border-radius: 4px; color: var(--text-muted);
            cursor: pointer; display: flex; align-items: center; justify-content: center;
            transition: color 0.15s;
        }
        .sound-preview:hover, .sound-edit:hover, .sound-fav:hover { color: var(--accent); }
        .sound-preview.playing { color: var(--accent); }
        .sound-fav.active { color: var(--accent); }
        .sound-edit.hidden { display: none; }
        .sound-preview svg, .sound-edit svg, .sound-fav svg { width: 12px; height: 12px; }
        .sound-grid.reorder-mode .sound-preview, .sound-grid.reorder-mode .sound-fav { pointer-events: none; }
        .favorites-bar { display: flex; flex-wrap: wrap; gap: 0.35rem; margin-bottom: 0.75rem; align-items: center; }
        .favorites-bar .fav-slot {
            padding: 0.35rem 0.6rem; font-size: 0.8rem; min-width: 2rem;
            background: var(--surface-hover); border: 1px solid var(--border);
            border-radius: var(--radius-sm); color: var(--text); cursor: pointer;
            transition: border-color 0.15s, background 0.15s;
        }
        .favorites-bar .fav-slot:hover:not(.empty) { border-color: var(--accent); }
        .favorites-bar .fav-slot.empty { color: var(--text-muted); cursor: default; }
        .favorites-bar .fav-slot .fav-num { font-weight: 600; margin-right: 0.25rem; }
        .upload-zone { border: 2px dashed var(--border); border-radius: var(--radius-sm); padding: 1rem; text-align: center; color: var(--text-muted); font-size: 0.9rem; transition: border-color 0.15s, background 0.15s; }
        .upload-zone.drag-over { border-color: var(--accent); background: rgba(124, 58, 237, 0.1); }
        .upload-zone input[type="file"] { display: none; }
        .upload-zone label { cursor: pointer; display: block; }
        .upload-zone .browse { color: var(--accent); font-weight: 500; }
        .top-actions { display: flex; gap: 0.5rem; margin-bottom: 1rem; flex-wrap: wrap; }
        .top-actions.hidden { display: none; }
        .sounds-card-header { display: flex; align-items: center; justify-content: space-between; flex-wrap: wrap; gap: 0.5rem; margin-bottom: 0.75rem; }
        .sounds-card-header .card-title { margin-bottom: 0; }
        .sounds-header-buttons { display: flex; gap: 0.35rem; align-items: center; }
        .toggle-btn { font-size: 0.8rem; }
        .toggle-btn.active { background: var(--accent); color: white; }
        .sound-grid.reorder-mode .sound-item { user-select: none; }
        .sound-item-wrap { display: contents; }
        .sound-grid.reorder-mode .sound-item-wrap { display: flex; flex-direction: column; cursor: grab; }
        .sound-grid.reorder-mode .sound-item-wrap:active { cursor: grabbing; }
        .sound-grid.reorder-mode .sound-item-wrap.dragging { opacity: 0.5; }
        .sound-grid.reorder-mode .sound-item-wrap.drag-over { outline: 2px solid var(--accent); outline-offset: 2px; border-radius: var(--radius-sm); }
        .sound-grid.reorder-mode .sound-btn { pointer-events: none; }
        .sound-grid.reorder-mode .sound-edit { pointer-events: none; }
        .sound-grid.reorder-mode .sound-item-actions { pointer-events: none; }
        .sound-grid.compact-mode { grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); gap: 0.5rem; }
        .sound-grid.compact-mode .sound-item { min-height: 72px; }
        .sound-grid.compact-mode .sound-btn { min-height: 72px; height: 72px; padding: 0.4rem 0.35rem 0.3rem; font-size: 0.78rem; }
        .sound-grid.compact-mode .sound-btn-duration { font-size: 0.65rem; }
        .sound-grid.compact-mode .sound-item-actions { top: 2px; right: 2px; }
        .sound-grid.compact-mode .sound-preview, .sound-grid.compact-mode .sound-edit, .sound-grid.compact-mode .sound-fav { width: 20px; height: 20px; }
        .sound-grid.compact-mode .sound-preview svg, .sound-grid.compact-mode .sound-edit svg, .sound-grid.compact-mode .sound-fav svg { width: 10px; height: 10px; }
        .sounds-card.mobile-active .sound-filter-row,
        .sounds-card.mobile-active .sound-grid,
        .sounds-card.mobile-active .tags-admin,
        .sounds-card.mobile-active .favorites-bar { display: none !important; }
        .sounds-card.mobile-active .mobile-grid-wrap { display: flex; }
        .sounds-card.mobile-active .sounds-header-buttons .toggle-btn:not(#mobileBtn) { display: none; }
        /* Mobile view: fullscreen soundboard section */
        .sounds-card.mobile-active {
            position: fixed; inset: 0; z-index: 50; margin: 0; border-radius: 0;
            display: flex; flex-direction: column; max-width: none;
            background: var(--bg); overflow: hidden;
        }
        .sounds-card.mobile-active .sounds-card-header { flex-shrink: 0; padding: 0.75rem 1rem; }
        .sounds-card.mobile-active .tag-tabs { flex-shrink: 0; margin: 0 1rem 0.5rem; }
        .mobile-grid-wrap { display: none; flex: 1; flex-direction: column; min-height: 0; overflow: hidden; }
        .mobile-grid-area {
            flex: 1; min-height: 0; padding: 0 1rem 1rem;
            display: grid; gap: 0.5rem;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
        }
        @media (min-width: 380px) {
            .mobile-grid-area { grid-template-columns: repeat(4, 1fr); }
        }
        @media (min-height: 480px) {
            .mobile-grid-area { grid-template-rows: repeat(4, 1fr); }
        }
        .mobile-grid-area.paged { overflow: hidden; }
        .mobile-grid-btn {
            aspect-ratio: 1; min-width: 0; min-height: 0; max-width: 160px; max-height: 160px;
            padding: 0.5rem; width: 100%; height: 100%;
            background: var(--surface-hover); border: 2px solid var(--border);
            border-radius: var(--radius-sm); font-size: 0.85rem; font-weight: 600;
            color: var(--text); cursor: pointer; display: flex; flex-direction: column;
            align-items: center; justify-content: center; gap: 0.15rem;
            transition: background 0.15s, border-color 0.15s, transform 0.2s;
            word-break: break-word; text-align: center; overflow: hidden;
        }
        .mobile-grid-area.paged .mobile-grid-btn { max-width: none; max-height: none; }
        .mobile-grid-btn:hover:not(:disabled) { background: var(--border); border-color: var(--accent); }
        .mobile-grid-btn:active:not(:disabled) { transform: scale(0.98); }
        .mobile-grid-btn.disabled { opacity: 0.5; cursor: not-allowed; }
        .mobile-grid-btn .duration { font-size: 0.7rem; font-weight: 400; color: var(--text-muted); }
        .mobile-grid-nav { display: none; flex-shrink: 0; align-items: center; justify-content: center; gap: 1rem; padding: 0.5rem 1rem; }
        .mobile-grid-wrap.paged .mobile-grid-nav { display: flex !important; }
        .mobile-grid-nav button { width: 44px; height: 44px; border-radius: 50%; border: 1px solid var(--border); background: var(--surface-hover); color: var(--text); font-size: 1.2rem; cursor: pointer; }
        .mobile-grid-nav button:hover:not(:disabled) { border-color: var(--accent); color: var(--accent); }
        .mobile-grid-nav button:disabled { opacity: 0.4; cursor: not-allowed; }
        .mobile-grid-page { font-size: 0.8rem; color: var(--text-muted); min-width: 4rem; text-align: center; }
        .settings-row { align-items: center; gap: 0.5rem; }
        .settings-row label { display: flex; align-items: center; gap: 0.5rem; cursor: pointer; font-size: 0.9rem; }
        .settings-row input[type="checkbox"] { width: 1.1rem; height: 1.1rem; accent-color: var(--accent); }
        .user-locked-msg { color: var(--text-muted); font-size: 0.9rem; margin-top: 0.5rem; }
        .tag-tabs, .folder-tabs { display: flex; flex-wrap: wrap; gap: 0.35rem; margin-bottom: 0.75rem; align-items: center; }
        .tag-tab, .folder-tab { padding: 0.4rem 0.75rem; border-radius: var(--radius-sm); font-size: 0.85rem; background: var(--surface-hover); border: 1px solid var(--border); color: var(--text); cursor: pointer; }
        .tag-tab:hover, .folder-tab:hover { border-color: var(--accent); }
        .tag-tab.active, .folder-tab.active { background: var(--accent); border-color: var(--accent); color: white; }
        .tag-tab.delete, .folder-tab.delete { padding: 0.2rem 0.4rem; font-size: 0.75rem; color: var(--text-muted); }
        .tag-tab.delete:hover, .folder-tab.delete:hover { color: var(--danger); }
        .tag-tab.hidden-tag { opacity: 0.6; }
        .tag-tab-wrap, .folder-tab-wrap { display: inline-flex; align-items: center; gap: 0.15rem; }
        .tag-tabs.manage-mode .tag-tab-wrap, .folder-tabs.manage-mode .folder-tab-wrap { cursor: grab; }
        .tag-tabs.manage-mode .tag-tab-wrap:active, .folder-tabs.manage-mode .folder-tab-wrap:active { cursor: grabbing; }
        .tag-tabs.manage-mode .tag-tab-wrap.dragging, .folder-tabs.manage-mode .folder-tab-wrap.dragging { opacity: 0.5; }
        .tag-tabs.manage-mode .tag-tab-wrap.drag-over, .folder-tabs.manage-mode .folder-tab-wrap.drag-over { outline: 2px solid var(--accent); outline-offset: 2px; border-radius: var(--radius-sm); }
        .tag-tab-rename, .folder-tab-rename { width: 6rem; padding: 0.2rem 0.4rem; font-size: 0.85rem; background: var(--surface); border: 1px solid var(--accent); border-radius: var(--radius-sm); color: var(--text); }
        .tags-admin, .folders-admin { margin-bottom: 0.75rem; }
        .tags-admin .row, .folders-admin .row { gap: 0.35rem; }
        .tags-input-wrap { flex: 1; min-width: 0; position: relative; }
        .tags-input { width: 100%; min-width: 0; padding: 0.4rem 0.5rem; background: var(--surface-hover); border: 1px solid var(--border); border-radius: var(--radius-sm); color: var(--text); font-size: 0.9rem; }
        .tags-input:focus { outline: none; border-color: var(--accent); }
        .tags-suggestions { position: absolute; top: 100%; left: 0; right: 0; margin-top: 2px; max-height: 160px; overflow-y: auto; background: var(--surface); border: 1px solid var(--border); border-radius: var(--radius-sm); box-shadow: var(--shadow); z-index: 100; }
        .tags-suggestions .tag-suggestion { padding: 0.4rem 0.6rem; cursor: pointer; font-size: 0.9rem; }
        .tags-suggestions .tag-suggestion:hover, .tags-suggestions .tag-suggestion.selected { background: var(--surface-hover); }
        .sound-filter-row { margin-bottom: 0.75rem; }
        .sound-filter-input { width: 100%; max-width: 320px; padding: 0.5rem 0.65rem; background: var(--surface-hover); border: 1px solid var(--border); border-radius: var(--radius-sm); color: var(--text); font-size: 0.9rem; }
        .sound-filter-input::placeholder { color: var(--text-muted); }
        .sound-filter-input:focus { outline: none; border-color: var(--accent); }
        .top-bar-lock { display: inline-flex; align-items: center; gap: 0.5rem; margin-left: 0.5rem; font-size: 0.85rem; color: var(--text-muted); cursor: pointer; }
        .top-bar-lock input[type="checkbox"] { width: 1rem; height: 1rem; accent-color: var(--accent); }
        .sound-panel { margin-top: 1rem; padding: 1rem; background: var(--surface-hover); border-radius: var(--radius-sm); border: 1px solid var(--border); }
        .sound-panel .row { margin-bottom: 0.5rem; }
        .sound-panel label { font-size: 0.85rem; color: var(--text-muted); min-width: 5rem; }
        .sound-panel input, .sound-panel select { flex: 1; padding: 0.4rem 0.5rem; background: var(--surface); border: 1px solid var(--border); border-radius: var(--radius-sm); color: var(--text); font-size: 0.9rem; }
        .sound-drag-handle { display: none; position: absolute; left: 4px; top: 50%; transform: translateY(-50%); width: 20px; color: var(--text-muted); font-size: 0.9rem; user-select: none; }
        .sound-grid.reorder-mode .sound-drag-handle { display: block; }
        .sound-item-selected { outline: 2px solid var(--accent); outline-offset: 2px; }
        .superadmin-only { }
        .guest-history-table td { padding: 0.35rem 0.5rem; border-bottom: 1px solid var(--border); }
        .guest-history-table .block-btn { padding: 0.2rem 0.5rem; font-size: 0.75rem; }
        .blocked-ips-list .ip-row { display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.35rem; }
    </style>
</head>
<body>
    <script>
        (function(){try{var p=localStorage.getItem('soundboard-prefs');var t=p?JSON.parse(p).theme:null;document.documentElement.setAttribute('data-theme',t==='light'?'light':'dark');}catch(e){}})();
    </script>
    <button type="button" class="theme-toggle" id="themeToggle" title="Toggle light/dark theme" aria-label="Toggle theme">üåô</button>
    <div class="login-screen" id="loginScreen">
        <div class="login-card">
            <h1>üîä Soundboard</h1>
            <form id="loginForm" onsubmit="return doLogin(event)">
                <label for="loginUser">Username</label>
                <input type="text" id="loginUser" name="username" placeholder="Username" autocomplete="username" required>
                <label for="loginPass">Password</label>
                <input type="password" id="loginPass" name="password" placeholder="Password" autocomplete="current-password" required>
                <button type="submit" class="btn btn-primary">Log in</button>
                <div class="login-error" id="loginError"></div>
                <div class="guest-divider" id="guestDivider" style="display:none; margin: 1rem 0; text-align: center; color: var(--text-muted); font-size: 0.85rem;">‚Äî or ‚Äî</div>
                <button type="button" class="btn btn-ghost" id="guestBtn" style="display:none; width:100%;" onclick="doGuestLogin()">Continue as guest</button>
            </form>
        </div>
    </div>

    <div class="app hidden" id="app">
        <div class="header-row">
            <h1>üîä Soundboard</h1>
            <div class="header-right">
                <div class="main-tabs superadmin-only hidden" id="mainTabs">
                    <button type="button" class="main-tab active" data-tab="sounds" onclick="switchMainTab('sounds')">Sounds</button>
                    <button type="button" class="main-tab" data-tab="superadmin" onclick="switchMainTab('superadmin')">Superadmin<span class="pending-badge hidden" id="pendingBadge">0</span></button>
                </div>
                <div class="user-badge">Logged in as <span id="currentUsername">‚Äî</span> <span id="currentRole">(admin)</span> <button type="button" class="btn btn-ghost" style="padding: 0.35rem 0.5rem; font-size: 0.8rem;" onclick="logout()">Log out</button></div>
            </div>
        </div>

        <div id="soundsView" class="main-view">
        <div class="top-actions" id="topActions">
            <button type="button" class="btn btn-danger" id="stopAllBtn" onclick="stopPlayback()" title="Stop playback">‚èπ Stop</button>
            <label class="top-bar-lock admin-only" title="Lock playback for users (superadmin locks everyone)">
                <span class="top-bar-lock-label">Lock playback</span>
                <input type="checkbox" id="playbackLockedTop" onchange="setPlaybackLocked(this.checked)">
            </label>
        </div>

        <div class="card admin-only" id="connectionCard">
            <div class="card-title">Connection</div>
            <div class="row">
                <select id="channelSelect"><option>Loading channels...</option></select>
                <button type="button" class="btn btn-primary" onclick="joinChannel()">Join Channel</button>
                <button type="button" class="btn btn-danger" onclick="leaveChannel()">Leave</button>
            </div>
        </div>

        <div class="player" id="playerCard">
            <div class="card-title">Now Playing</div>
            <div class="player-now-playing" id="nowPlayingText">Nothing playing</div>
            <div class="waveform-placeholder" id="waveformPlaceholder">Waveform will appear when a sound is playing</div>
            <div class="waveform-wrap" id="waveformWrap" style="display: none;">
                <canvas id="waveformCanvas" width="600" height="48"></canvas>
            </div>
            <div class="progress-time" id="progressTime">0:00 / 0:00</div>
            <div class="player-buttons">
                <button type="button" class="btn btn-ghost btn-icon" id="playPauseBtn" onclick="togglePlayPause()" title="Play / Pause" disabled>‚ñ∂</button>
                <button type="button" class="btn btn-ghost btn-icon" id="stopBtn" onclick="stopPlayback()" title="Stop">‚èπ</button>
            </div>
        </div>

        <div class="card admin-only" id="volumeCard">
            <div class="card-title">Volume</div>
            <div class="row volume-row">
                <span class="volume-label" id="volumeLabel">50%</span>
                <input type="range" id="volumeSlider" min="0" max="1" step="0.02" value="0.5" title="Volume">
            </div>
        </div>

        <div class="card" id="uploadCard">
            <div class="card-title">Upload Sound</div>
            <div class="upload-zone" id="uploadZone">
                <label for="fileInput"><span class="browse">Browse</span> or drag a file ‚Äî MP3, WAV, OGG</label>
                <input type="file" id="fileInput" accept="audio/*">
            </div>
            <div class="upload-hint" id="uploadHint" style="font-size: 0.8rem; color: var(--text-muted); margin-top: 0.5rem;"></div>
        </div>

        <div class="card sounds-card">
            <div class="sounds-card-header">
                <span class="card-title">Sounds</span>
                <div class="sounds-header-buttons">
                    <button type="button" class="btn btn-ghost toggle-btn" id="mobileBtn" onclick="toggleMobileView()" title="Mobile view: fullscreen soundboard with responsive grid">Mobile</button>
                    <button type="button" class="btn btn-ghost toggle-btn" id="compactBtn" onclick="toggleCompact()" title="Compact view: smaller buttons, more on screen">Compact</button>
                    <button type="button" class="btn btn-ghost toggle-btn" id="reorderBtn" onclick="toggleReorder()" title="Drag to reorder (switch to All to reorder)">Reorder</button>
                    <button type="button" class="btn btn-ghost toggle-btn admin-only" id="manageTagsBtn" onclick="toggleManageTags()" title="Manage tags: reorder, delete, hide">Manage tags</button>
                </div>
            </div>
            <div class="tags-admin admin-only hidden" id="tagsAdmin">
                <p style="font-size: 0.85rem; color: var(--text-muted); margin-bottom: 0.5rem;">Drag to reorder. Click ‚úï to delete, üëÅ to hide (hidden tags don't show as buttons but remain searchable).</p>
            </div>
            <div class="sound-filter-row">
                <input type="text" id="soundFilterInput" placeholder="Filter by name or tag..." class="sound-filter-input" autocomplete="off">
            </div>
            <div class="tag-tabs" id="tagTabs"></div>
            <div class="favorites-bar" id="favoritesBar"></div>
            <div class="mobile-grid-wrap" id="mobileGridWrap">
                <div class="mobile-grid-area" id="mobileGridArea"></div>
                <div class="mobile-grid-nav" id="mobileGridNav">
                    <button type="button" id="mobilePrevBtn" onclick="mobilePagePrev()" title="Previous page">‚Äπ</button>
                    <span class="mobile-grid-page" id="mobileGridPage">‚Äî</span>
                    <button type="button" id="mobileNextBtn" onclick="mobilePageNext()" title="Next page">‚Ä∫</button>
                </div>
            </div>
            <div id="soundsList" class="sound-grid"></div>
            <div class="sound-panel hidden" id="soundPanel">
                <div class="card-title">Edit sound</div>
                <div class="row"><label>Name</label><input type="text" id="soundPanelName" placeholder="Display name"></div>
                <div class="row"><label>Tags</label><div class="tags-input-wrap"><input type="text" id="soundPanelTags" placeholder="Add tags (comma or space separated)" class="tags-input" autocomplete="off"><div id="soundPanelTagsSuggestions" class="tags-suggestions hidden"></div></div></div>
                <div class="row"><label>Duration</label><span id="soundPanelDuration" class="text-muted">‚Äî</span></div>
                <div class="row" style="margin-top: 0.5rem;">
                    <button type="button" class="btn btn-primary" onclick="saveSoundPanel()">Save</button>
                    <button type="button" class="btn btn-ghost" onclick="closeSoundPanel()">Close</button>
                </div>
            </div>
            <div class="user-locked-msg hidden" id="userLockedMsg">Playback is locked by an admin.</div>
        </div>
        </div>

        <div id="superadminView" class="main-view hidden">
        <div class="card" id="superadminCard">
            <div class="card-title">Guest Access</div>
            <div class="settings-row" style="margin-bottom: 0.75rem;">
                <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer;">
                    <input type="checkbox" id="guestEnabledToggle" onchange="setGuestEnabled(this.checked)">
                    <span>Allow guest access (no login, 7s max, 10s cooldown)</span>
                </label>
            </div>
            <div class="card-title" style="margin-top: 1rem;">User & Guest Uploads</div>
            <div class="settings-row" style="margin-bottom: 0.5rem;">
                <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer;">
                    <input type="checkbox" id="userUploadEnabledToggle" onchange="setUserUploadEnabled(this.checked)">
                    <span>Allow users and guests to upload (goes to moderation queue)</span>
                </label>
            </div>
            <div class="row" style="margin-bottom: 0.75rem; gap: 1rem;">
                <label style="display: flex; align-items: center; gap: 0.5rem; font-size: 0.9rem;">
                    <span>Max duration (s):</span>
                    <input type="number" id="maxUploadDurationInput" min="1" max="60" value="7" style="width: 4rem; padding: 0.35rem; background: var(--surface-hover); border: 1px solid var(--border); border-radius: var(--radius-sm); color: var(--text);" onchange="setMaxUploadDuration(this.value)">
                </label>
                <label style="display: flex; align-items: center; gap: 0.5rem; font-size: 0.9rem;">
                    <span>Max size (KB):</span>
                    <input type="number" id="maxUploadBytesInput" min="100" max="10240" value="2048" style="width: 5rem; padding: 0.35rem; background: var(--surface-hover); border: 1px solid var(--border); border-radius: var(--radius-sm); color: var(--text);" onchange="setMaxUploadBytes(this.value)">
                </label>
            </div>
            <div class="card-title" style="margin-top: 1rem;">Guest History</div>
            <div class="guest-history-table-wrap" style="max-height: 200px; overflow-y: auto; margin-bottom: 0.75rem;">
                <table class="guest-history-table" style="width:100%; font-size: 0.85rem; border-collapse: collapse;">
                    <thead><tr><th style="text-align:left; padding: 0.35rem 0.5rem;">IP</th><th style="text-align:left; padding: 0.35rem 0.5rem;">Time</th><th style="text-align:left; padding: 0.35rem 0.5rem;">Sound</th><th></th></tr></thead>
                    <tbody id="guestHistoryBody"></tbody>
                </table>
            </div>
            <div class="card-title">Blocked IPs</div>
            <div id="blockedIPsList" class="blocked-ips-list" style="font-size: 0.85rem; margin-bottom: 1rem;"></div>
            <div class="card-title">Moderation Queue</div>
            <p style="font-size: 0.85rem; color: var(--text-muted); margin-bottom: 0.5rem;">User and guest uploads await approval here.</p>
            <div class="pending-uploads-wrap" style="max-height: 220px; overflow-y: auto;">
                <table class="guest-history-table" style="width:100%; font-size: 0.85rem; border-collapse: collapse;">
                    <thead><tr><th style="text-align:left; padding: 0.35rem 0.5rem;">File</th><th style="text-align:left; padding: 0.35rem 0.5rem;">By</th><th style="text-align:left; padding: 0.35rem 0.5rem;">Time</th><th></th></tr></thead>
                    <tbody id="pendingUploadsBody"></tbody>
                </table>
            </div>
            <div id="pendingUploadsEmpty" class="pending-empty" style="font-size: 0.85rem; color: var(--text-muted); padding: 0.5rem;">No pending uploads</div>
        </div>
        </div>
    </div>

    <script>
        const CREDENTIALS = 'include';
        const MAX_USER_DURATION = 7;
        const GUEST_COOLDOWN_SEC = 10;
        let user = null;
        let playback = { status: 'idle', filename: null, displayName: null, startTime: null, duration: null, startTimeOffset: 0, startedBy: null };
        let playbackLockedBy = null;
        let guestLastPlayTime = 0;
        let guestEnabled = false;
        let userUploadEnabled = false;
        let maxUploadDuration = 7;
        let maxUploadBytes = 2097152;
        let pausedAt = 0;
        let waveformData = null;
        let waveformDuration = 0;
        let waveformFilename = null;
        let reorderMode = false;
        let playbackLocked = false;
        let soundsList = [];
        let tagsList = [];
        let hiddenTags = [];
        let selectedTag = null;
        let selectedSound = null;
        let manageTagsMode = false;
        let soundFilter = '';
        let lastGuestCooldownShown = -1;
        let compactMode = false;
        let mobileView = false;
        let mobilePageIndex = 0;
        let mobileTouchStartX = 0;

        const PREFS_KEY = 'soundboard-prefs';
        function loadPrefs() {
            try {
                const raw = localStorage.getItem(PREFS_KEY);
                return raw ? JSON.parse(raw) : {};
            } catch { return {}; }
        }
        function savePrefs(prefs) {
            try {
                const merged = { ...loadPrefs(), ...prefs };
                localStorage.setItem(PREFS_KEY, JSON.stringify(merged));
            } catch (e) {}
        }
        function applyPrefs() {
            const prefs = loadPrefs();
            soundFilter = prefs.soundFilter || '';
            const filterInput = document.getElementById('soundFilterInput');
            if (filterInput) filterInput.value = soundFilter;
            compactMode = prefs.compact === true;
            mobileView = prefs.mobileView === true;
            const grid = document.getElementById('soundsList');
            const compactBtn = document.getElementById('compactBtn');
            const soundsCard = document.querySelector('.sounds-card');
            const mobileBtn = document.getElementById('mobileBtn');
            if (grid) grid.classList.toggle('compact-mode', compactMode);
            if (compactBtn) compactBtn.classList.toggle('active', compactMode);
            if (soundsCard) soundsCard.classList.toggle('mobile-active', mobileView);
            if (mobileBtn) mobileBtn.classList.toggle('active', mobileView);
            if (mobileView) renderMobileGrid();
        }
        function toggleCompact() {
            compactMode = !compactMode;
            const grid = document.getElementById('soundsList');
            const compactBtn = document.getElementById('compactBtn');
            if (grid) grid.classList.toggle('compact-mode', compactMode);
            if (compactBtn) compactBtn.classList.toggle('active', compactMode);
            savePrefs({ compact: compactMode });
        }

        function toggleMobileView() {
            mobileView = !mobileView;
            const soundsCard = document.querySelector('.sounds-card');
            const mobileBtn = document.getElementById('mobileBtn');
            if (soundsCard) soundsCard.classList.toggle('mobile-active', mobileView);
            if (mobileBtn) mobileBtn.classList.toggle('active', mobileView);
            savePrefs({ mobileView });
            if (mobileView) renderMobileGrid();
        }

        function getFavorites() {
            const arr = loadPrefs().favorites;
            return Array.isArray(arr) ? arr.slice(0, 9) : [];
        }
        function setFavorites(arr) {
            const safe = (Array.isArray(arr) ? arr : []).slice(0, 9);
            savePrefs({ favorites: safe });
        }
        function toggleFavorite(filename) {
            if (!filename) return;
            let fav = getFavorites();
            const idx = fav.indexOf(filename);
            if (idx >= 0) {
                fav = fav.filter(f => f !== filename);
            } else if (fav.length < 9) {
                fav = [...fav, filename];
            }
            setFavorites(fav);
            renderFavoritesBar();
            renderSoundsGrid();
        }
        function renderFavoritesBar() {
            const bar = document.getElementById('favoritesBar');
            if (!bar) return;
            const fav = getFavorites();
            const sounds = soundsList || [];
            bar.innerHTML = [1,2,3,4,5,6,7,8,9].map((n, i) => {
                const fn = fav[i];
                const s = fn ? sounds.find(x => x.filename === fn) : null;
                const name = s ? (s.displayName || s.filename || '') : '';
                const label = name ? (name.length > 12 ? name.slice(0, 12) + '‚Ä¶' : name) : '‚Äî';
                const cls = fn ? '' : ' empty';
                const title = fn ? `${n}: ${(s && s.displayName) || (s && s.filename) || fn} (click to play)` : `${n}: empty (star a sound to add)`;
                return `<button type="button" class="fav-slot${cls}" data-slot="${n}" data-filename="${(fn || '').replace(/"/g, '&quot;')}" ${fn ? '' : 'disabled'} title="${(title || '').replace(/"/g, '&quot;')}">` +
                    `<span class="fav-num">${n}</span><span class="fav-label">${(label || '‚Äî').replace(/&/g, '&amp;').replace(/</g, '&lt;')}</span></button>`;
            }).join('');
            bar.querySelectorAll('.fav-slot:not(.empty)').forEach(btn => {
                btn.onclick = () => playSound(btn.dataset.filename);
            });
        }

        function getFilteredSounds() {
            const list = soundsList || [];
            let filtered = selectedTag != null ? list.filter(s => (s.tags || []).includes(selectedTag)) : list;
            const q = (soundFilter || '').trim().toLowerCase();
            if (q) {
                const terms = q.split(/\s+/).filter(t => t);
                filtered = filtered.filter(s => {
                    const name = ((s.displayName || s.filename) || '').toLowerCase();
                    const tags = (s.tags || []).map(t => t.toLowerCase());
                    return terms.every(term => name.includes(term) || tags.some(t => t.includes(term)));
                });
            }
            return filtered;
        }

        function getMobileGridLayout() {
            const w = window.innerWidth;
            const h = window.innerHeight;
            const cols = w < 380 ? 3 : 4;
            const rows = h < 480 ? 3 : 4;
            return { cols, rows, perPage: cols * rows };
        }

        function renderMobileGrid() {
            const area = document.getElementById('mobileGridArea');
            const wrap = document.getElementById('mobileGridWrap');
            const nav = document.getElementById('mobileGridNav');
            const pageEl = document.getElementById('mobileGridPage');
            const prevBtn = document.getElementById('mobilePrevBtn');
            const nextBtn = document.getElementById('mobileNextBtn');
            if (!area || !mobileView) return;
            const filtered = getFilteredSounds();
            const { perPage } = getMobileGridLayout();
            const totalPages = Math.max(1, Math.ceil(filtered.length / perPage));
            const isPaged = filtered.length > perPage;
            if (isPaged) {
                mobilePageIndex = Math.max(0, Math.min(mobilePageIndex, totalPages - 1));
            } else {
                mobilePageIndex = 0;
            }
            if (wrap) wrap.classList.toggle('paged', isPaged);
            area.classList.toggle('paged', isPaged);
            const isUser = (user && user.role) === 'user';
            const isGuest = (user && user.role) === 'guest';
            const guestCooldown = getGuestCooldownRemaining();
            const adminPlaying = (playback.status === 'playing' || playback.status === 'paused') && ((playback.startedBy && playback.startedBy.role) === 'admin' || (playback.startedBy && playback.startedBy.role) === 'superadmin');
            const cannotOverride = (isUser || isGuest) && adminPlaying;
            const canPlay = (!isUser && !isGuest) || ((!playbackLocked) && (isGuest ? guestCooldown === 0 : true) && !cannotOverride);
            const tooLong = (dur) => (isUser || isGuest) && dur != null && dur > MAX_USER_DURATION;
            if (filtered.length === 0) {
                area.innerHTML = '<div style="grid-column:1/-1; padding:2rem; text-align:center; color:var(--text-muted)">No sounds</div>';
                if (pageEl) pageEl.textContent = '‚Äî';
                return;
            }
            const start = isPaged ? mobilePageIndex * perPage : 0;
            const end = isPaged ? Math.min(start + perPage, filtered.length) : filtered.length;
            const pageSounds = filtered.slice(start, end);
            area.innerHTML = pageSounds.map(s => {
                const disabled = !canPlay || tooLong(s.duration);
                const name = (s.displayName || s.filename || '').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
                const dur = s.duration != null ? formatTime(s.duration) : '‚Äî';
                const fn = (s.filename || '').replace(/"/g, '&quot;');
                return `<button type="button" class="mobile-grid-btn ${disabled ? 'disabled' : ''}" data-filename="${fn}" ${disabled ? 'disabled' : ''} onclick="playSound(this.dataset.filename)"><span>${name}</span><span class="duration">${dur}</span></button>`;
            }).join('');
            if (pageEl) pageEl.textContent = isPaged ? `${mobilePageIndex + 1} / ${totalPages}` : '‚Äî';
            if (prevBtn) prevBtn.disabled = !isPaged || mobilePageIndex <= 0;
            if (nextBtn) nextBtn.disabled = !isPaged || mobilePageIndex >= totalPages - 1;
            if (isPaged) setupMobileSwipeHandlers();
        }

        function mobilePagePrev() {
            const filtered = getFilteredSounds();
            const { perPage } = getMobileGridLayout();
            if (filtered.length <= perPage) return;
            if (mobilePageIndex > 0) { mobilePageIndex--; renderMobileGrid(); }
        }

        function mobilePageNext() {
            const filtered = getFilteredSounds();
            const { perPage } = getMobileGridLayout();
            const totalPages = Math.ceil(filtered.length / perPage);
            if (mobilePageIndex < totalPages - 1) { mobilePageIndex++; renderMobileGrid(); }
        }

        function setupMobileSwipeHandlers() {
            const area = document.getElementById('mobileGridArea');
            if (!area) return;
            area.ontouchstart = (e) => { mobileTouchStartX = e.touches[0].clientX; };
            area.ontouchend = (e) => {
                if (!(e.changedTouches && e.changedTouches[0])) return;
                const dx = e.changedTouches[0].clientX - mobileTouchStartX;
                if (dx > 60) mobilePagePrev();
                else if (dx < -60) mobilePageNext();
            };
        }

        function applyTheme(theme) {
            document.documentElement.setAttribute('data-theme', theme || 'dark');
            const btn = document.getElementById('themeToggle');
            if (btn) btn.textContent = (theme === 'light') ? 'üåô' : '‚òÄÔ∏è';
        }
        function toggleTheme() {
            const current = document.documentElement.getAttribute('data-theme') || 'dark';
            const next = current === 'dark' ? 'light' : 'dark';
            applyTheme(next);
            savePrefs({ theme: next });
        }

        async function api(path, opts = {}) {
            const res = await fetch(path, { credentials: CREDENTIALS, ...opts });
            if (res.status === 401) { showLogin(); return null; }
            return res;
        }

        function isAdminOrSuperadmin() { return (user && user.role) === 'admin' || (user && user.role) === 'superadmin'; }

        function switchMainTab(tab) {
            document.querySelectorAll('.main-tab').forEach(t => t.classList.toggle('active', t.dataset.tab === tab));
            document.getElementById('soundsView').classList.toggle('hidden', tab !== 'sounds');
            document.getElementById('superadminView').classList.toggle('hidden', tab !== 'superadmin');
            if (tab === 'superadmin') { fetchGuestHistory(); fetchBlockedIPs(); fetchPendingUploads(); }
        }

        async function checkAuth() {
            const res = await api('/api/me');
            if (!res) return false;
            if (res.ok) {
                user = await res.json();
                document.getElementById('loginScreen').classList.add('hidden');
                document.getElementById('app').classList.remove('hidden');
                document.getElementById('currentUsername').textContent = user.username;
                document.getElementById('currentRole').textContent = '(' + (user.role || 'user') + ')';
                if (user.role === 'user' || user.role === 'guest') {
                    document.querySelectorAll('.admin-only').forEach(el => el.classList.add('hidden'));
                    document.querySelectorAll('.superadmin-only').forEach(el => el.classList.add('hidden'));
                    document.getElementById('topActions').classList.add('hidden');
                    document.getElementById('playPauseBtn').classList.add('hidden');
                    document.getElementById('stopBtn').classList.add('hidden');
                } else {
                    document.getElementById('topActions').classList.remove('hidden');
                    document.getElementById('playPauseBtn').classList.remove('hidden');
                    document.getElementById('stopBtn').classList.remove('hidden');
                    document.querySelectorAll('.admin-only').forEach(el => el.classList.remove('hidden'));
                    if (user.role === 'superadmin') {
                    document.querySelectorAll('.superadmin-only').forEach(el => el.classList.remove('hidden'));
                    startPendingCountPolling();
                } else {
                    document.querySelectorAll('.superadmin-only').forEach(el => el.classList.add('hidden'));
                }
                }
                fetchSettings();
                if ((user && user.role) === 'superadmin') { fetchGuestHistory(); fetchBlockedIPs(); fetchPendingUploads(); }
                updateUploadCardVisibility();
                return true;
            }
            showLogin();
            return false;
        }

        function showLogin() {
            user = null;
            document.getElementById('loginScreen').classList.remove('hidden');
            document.getElementById('app').classList.add('hidden');
            fetchGuestStatus();
        }

        async function fetchGuestStatus() {
            try {
                const res = await fetch('/api/guest-status', { credentials: CREDENTIALS });
                if (res.ok) {
                    const d = await res.json();
                    guestEnabled = d.guestEnabled === true;
                    const div = document.getElementById('guestDivider');
                    const btn = document.getElementById('guestBtn');
                    if (div && btn) { div.style.display = guestEnabled ? 'block' : 'none'; btn.style.display = guestEnabled ? 'block' : 'none'; }
                }
            } catch (e) {}
        }

        async function doGuestLogin() {
            document.getElementById('loginError').textContent = '';
            const res = await fetch('/api/guest/start', { method: 'POST', credentials: CREDENTIALS });
            const data = await res.json().catch(() => ({}));
            if (!res.ok) {
                document.getElementById('loginError').textContent = data.error || 'Guest access unavailable';
                return;
            }
            await checkAuth();
            applyPrefs();
            startPlaybackPolling();
            fetchSounds();
            return false;
        }

        async function doLogin(e) {
            e.preventDefault();
            const username = document.getElementById('loginUser').value.trim();
            const password = document.getElementById('loginPass').value;
            document.getElementById('loginError').textContent = '';
            const res = await fetch('/api/login', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                credentials: CREDENTIALS,
                body: JSON.stringify({ username, password }),
            });
            const data = await res.json().catch(() => ({}));
            if (!res.ok) {
                document.getElementById('loginError').textContent = data.error || 'Login failed';
                return false;
            }
            await checkAuth();
            applyPrefs();
            startPlaybackPolling();
            fetchChannels();
            fetchSounds();
            fetch('/api/volume', { credentials: CREDENTIALS }).then(r => r.json()).then(d => {
                const v = (d.volume != null ? d.volume : 0.5);
                document.getElementById('volumeSlider').value = v;
                document.getElementById('volumeLabel').textContent = Math.round(v * 100) + '%';
            }).catch(() => {});
            return false;
        }

        async function logout() {
            await fetch('/api/logout', { method: 'POST', credentials: CREDENTIALS });
            showLogin();
        }

        async function fetchChannels() {
            if (!isAdminOrSuperadmin()) return;
            const res = await api('/api/channels');
            if (!res || !res.ok) return;
            const data = await res.json();
            const channels = Array.isArray(data) ? data : (data.channels || []);
            const serverLastChannel = data.lastChannelId || null;
            const lastChannel = loadPrefs().lastChannelId || serverLastChannel;
            const select = document.getElementById('channelSelect');
            select.innerHTML = channels.map(c => `<option value="${c.id}">${c.name}</option>`).join('');
            if (lastChannel && channels.some(c => c.id === lastChannel)) {
                select.value = lastChannel;
                if (!loadPrefs().lastChannelId) savePrefs({ lastChannelId: lastChannel });
            }
        }

        async function fetchSettings() {
            const res = await api('/api/settings');
            if (!res || !res.ok) return;
            const d = await res.json();
            playbackLocked = d.playbackLocked === true;
            playbackLockedBy = d.playbackLockedBy || null;
            if (d.userUploadEnabled !== undefined) userUploadEnabled = d.userUploadEnabled;
            if (d.maxUploadDuration !== undefined) maxUploadDuration = d.maxUploadDuration;
            if (d.maxUploadBytes !== undefined) maxUploadBytes = d.maxUploadBytes;
            const cb = document.getElementById('playbackLockedTop');
            if (cb) cb.checked = playbackLocked;
            const msg = document.getElementById('userLockedMsg');
            if (msg) {
                if (((user && user.role) === 'user' || (user && user.role) === 'guest') && playbackLocked) {
                    msg.textContent = playbackLockedBy === 'superadmin' ? 'Playback is locked by a superadmin.' : 'Playback is locked by an admin.';
                    msg.classList.remove('hidden');
                } else {
                    msg.classList.add('hidden');
                }
            }
            if ((user && user.role) === 'superadmin') {
                if (d.guestEnabled !== undefined) { guestEnabled = d.guestEnabled; const g = document.getElementById('guestEnabledToggle'); if (g) g.checked = guestEnabled; }
                if (d.userUploadEnabled !== undefined) { const g = document.getElementById('userUploadEnabledToggle'); if (g) g.checked = d.userUploadEnabled; }
                if (d.maxUploadDuration !== undefined) { const g = document.getElementById('maxUploadDurationInput'); if (g) g.value = d.maxUploadDuration; }
                if (d.maxUploadBytes !== undefined) { const g = document.getElementById('maxUploadBytesInput'); if (g) g.value = Math.round(d.maxUploadBytes / 1024); }
            }
            if (d.volume !== undefined && Number.isFinite(d.volume)) {
                const v = Math.max(0, Math.min(1, d.volume));
                const slider = document.getElementById('volumeSlider');
                const label = document.getElementById('volumeLabel');
                if (slider) slider.value = v;
                if (label) label.textContent = Math.round(v * 100) + '%';
            }
            if ((user && user.role) === 'superadmin' && d.pendingCount !== undefined) {
                updatePendingBadge(d.pendingCount);
            }
            updateUploadCardVisibility();
        }

        function updateUploadCardVisibility() {
            const card = document.getElementById('uploadCard');
            const hint = document.getElementById('uploadHint');
            if (!card || !hint) return;
            const canDirect = isAdminOrSuperadmin();
            const canPending = ((user && user.role) === 'user' || (user && user.role) === 'guest') && (typeof userUploadEnabled !== 'undefined' ? userUploadEnabled : false);
            if (canDirect) {
                card.classList.remove('hidden');
                hint.textContent = '';
            } else if (canPending) {
                card.classList.remove('hidden');
                const maxSec = maxUploadDuration || 7;
                const maxKB = Math.round((maxUploadBytes || 2097152) / 1024);
                hint.textContent = 'Uploads go to a moderation queue. Max ' + maxSec + 's, ' + maxKB + 'KB. A superadmin must approve before they appear.';
            } else {
                card.classList.add('hidden');
                hint.textContent = '';
            }
        }

        async function setGuestEnabled(enabled) {
            const res = await api('/api/settings', { method: 'PATCH', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ guestEnabled: enabled }) });
            if (!res || !res.ok) return;
            guestEnabled = enabled;
            await fetchSettings();
        }

        async function setUserUploadEnabled(enabled) {
            const res = await api('/api/settings', { method: 'PATCH', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ userUploadEnabled: enabled }) });
            if (!res || !res.ok) return;
            userUploadEnabled = enabled;
            await fetchSettings();
            updateUploadCardVisibility();
        }

        async function setMaxUploadDuration(sec) {
            const n = parseInt(sec, 10);
            if (!Number.isFinite(n) || n < 1) return;
            await api('/api/settings', { method: 'PATCH', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ maxUploadDuration: n }) });
            await fetchSettings();
        }

        async function setMaxUploadBytes(kb) {
            const n = parseInt(kb, 10);
            if (!Number.isFinite(n) || n < 100) return;
            await api('/api/settings', { method: 'PATCH', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ maxUploadBytes: n * 1024 }) });
            await fetchSettings();
        }

        async function fetchGuestHistory() {
            const res = await api('/api/guest/history');
            if (!res || !res.ok) return;
            const history = await res.json();
            const tbody = document.getElementById('guestHistoryBody');
            if (!tbody) return;
            const esc = (x) => (x != null ? x : '').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
            tbody.innerHTML = history.slice(0, 100).map(h => {
                const dt = new Date(h.timestamp);
                const timeStr = dt.toLocaleString();
                const ip = esc(h.ip);
                return '<tr><td>' + ip + '</td><td>' + esc(timeStr) + '</td><td>' + esc(h.displayName || h.filename) + '</td><td><button type="button" class="btn btn-ghost block-btn" data-ip="' + ip + '" onclick="blockGuestIP(this.dataset.ip)">Block</button></td></tr>';
            }).join('');
        }

        async function fetchBlockedIPs() {
            const res = await api('/api/guest/blocked');
            if (!res || !res.ok) return;
            const ips = await res.json();
            const el = document.getElementById('blockedIPsList');
            if (!el) return;
            const esc = (x) => (x != null ? x : '').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
            if (ips.length === 0) { el.innerHTML = '<span style="color:var(--text-muted)">None</span>'; return; }
            el.innerHTML = ips.map(ip => '<div class="ip-row"><span>' + esc(ip) + '</span><button type="button" class="btn btn-ghost block-btn" data-ip="' + esc(ip) + '" onclick="unblockGuestIP(this.dataset.ip)">Unblock</button></div>').join('');
        }

        async function blockGuestIP(ip) {
            const res = await api('/api/guest/block-ip', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ ip }) });
            if (res && res.ok) fetchBlockedIPs();
        }

        async function unblockGuestIP(ip) {
            const res = await api('/api/guest/block-ip/' + encodeURIComponent(ip), { method: 'DELETE' });
            if (res && res.ok) fetchBlockedIPs();
        }

        function updatePendingBadge(count) {
            const badge = document.getElementById('pendingBadge');
            if (!badge) return;
            if (count > 0) {
                badge.textContent = count > 99 ? '99+' : String(count);
                badge.classList.remove('hidden');
            } else {
                badge.classList.add('hidden');
            }
        }

        async function fetchPendingCount() {
            if ((user && user.role) !== 'superadmin') return;
            const res = await api('/api/superadmin/pending-count');
            if (!res || !res.ok) return;
            const d = await res.json().catch(() => ({}));
            updatePendingBadge(d.count != null ? d.count : 0);
        }

        async function fetchPendingUploads() {
            const res = await api('/api/superadmin/pending-uploads');
            if (!res || !res.ok) return;
            const uploads = await res.json();
            updatePendingBadge(uploads.length);
            const tbody = document.getElementById('pendingUploadsBody');
            const empty = document.getElementById('pendingUploadsEmpty');
            if (!tbody || !empty) return;
            const esc = (x) => (x != null ? x : '').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
            if (uploads.length === 0) {
                tbody.innerHTML = '';
                empty.classList.remove('hidden');
                return;
            }
            empty.classList.add('hidden');
            tbody.innerHTML = uploads.map(u => {
                const dt = new Date(u.uploadedAt);
                const by = u.uploadedBy || (u.uploadedByIP ? 'guest' : '?');
                const dur = u.duration != null ? u.duration.toFixed(1) + 's' : '‚Äî';
                const sz = u.size != null ? Math.round(u.size / 1024) + 'KB' : '‚Äî';
                return '<tr><td><a href="/api/superadmin/pending-uploads/audio/' + encodeURIComponent(u.filename) + '" target="_blank" rel="noopener" style="color:var(--accent)">' + esc(u.filename) + '</a> <span style="color:var(--text-muted);font-size:0.8em">' + dur + ' ' + sz + '</span></td><td>' + esc(by) + '</td><td>' + esc(dt.toLocaleString()) + '</td><td><button type="button" class="btn btn-primary block-btn" data-filename="' + esc(u.filename) + '" onclick="approvePendingUpload(this.dataset.filename)">Approve</button> <button type="button" class="btn btn-danger block-btn" data-filename="' + esc(u.filename) + '" onclick="rejectPendingUpload(this.dataset.filename)">Reject</button></td></tr>';
            }).join('');
        }

        async function approvePendingUpload(filename) {
            const res = await api('/api/superadmin/pending-uploads/approve/' + encodeURIComponent(filename), { method: 'POST' });
            if (res && res.ok) { fetchPendingUploads(); fetchSounds(); }
            else if (res) { const d = await res.json().catch(() => ({})); alert(d.error || 'Failed'); }
        }

        async function rejectPendingUpload(filename) {
            const res = await api('/api/superadmin/pending-uploads/reject/' + encodeURIComponent(filename), { method: 'DELETE' });
            if (res && res.ok) fetchPendingUploads();
        }

        async function setPlaybackLocked(locked) {
            const res = await api('/api/settings', { method: 'PATCH', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ playbackLocked: locked }) });
            if (!res || !res.ok) return;
            playbackLocked = locked;
            await fetchSettings();
            if ((user && user.role) === 'user' || (user && user.role) === 'guest') fetchSounds();
        }

        function getGuestCooldownRemaining() {
            if ((user && user.role) !== 'guest') return 0;
            const elapsed = (Date.now() - guestLastPlayTime) / 1000;
            return Math.max(0, Math.ceil(GUEST_COOLDOWN_SEC - elapsed));
        }

        function toggleReorder() {
            if (selectedTag != null) { alert('Switch to "All" to reorder sounds.'); return; }
            reorderMode = !reorderMode;
            const btn = document.getElementById('reorderBtn');
            const grid = document.getElementById('soundsList');
            if (btn) btn.classList.toggle('active', reorderMode);
            if (grid) grid.classList.toggle('reorder-mode', reorderMode);
            renderSoundsGrid();
        }

        function setupSoundGridDragDrop(grid) {
            if (!grid || grid.dataset.dragSetup) return;
            grid.dataset.dragSetup = '1';
            grid.addEventListener('dragstart', (e) => {
                if (!reorderMode) return;
                const wrap = e.target.closest('.sound-item-wrap');
                if (!wrap) return;
                e.dataTransfer.setData('text/plain', wrap.dataset.filename || '');
                e.dataTransfer.effectAllowed = 'move';
                e.stopPropagation();
                wrap.classList.add('dragging');
            });
            grid.addEventListener('dragend', (e) => {
                const siw = e.target.closest('.sound-item-wrap'); if (siw) siw.classList.remove('dragging');
                grid.querySelectorAll('.sound-item-wrap').forEach(el => el.classList.remove('drag-over'));
            });
            grid.addEventListener('dragover', (e) => {
                if (!reorderMode) return;
                e.preventDefault();
                e.stopPropagation();
                e.dataTransfer.dropEffect = 'move';
                const wrap = e.target.closest('.sound-item-wrap');
                grid.querySelectorAll('.sound-item-wrap').forEach(el => el.classList.remove('drag-over'));
                if (wrap) wrap.classList.add('drag-over');
            });
            grid.addEventListener('drop', async (e) => {
                if (!reorderMode) return;
                e.preventDefault();
                e.stopPropagation();
                const fromFilename = e.dataTransfer.getData('text/plain');
                const toWrap = e.target.closest('.sound-item-wrap');
                grid.querySelectorAll('.sound-item-wrap').forEach(el => el.classList.remove('drag-over'));
                if (!fromFilename || !toWrap) return;
                const wraps = [...grid.querySelectorAll('.sound-item-wrap')];
                const fromIdx = wraps.findIndex(w => w.dataset.filename === fromFilename);
                const toIdx = wraps.findIndex(w => w === toWrap);
                if (fromIdx === -1 || toIdx === -1 || fromIdx === toIdx) return;
                const order = wraps.map(w => w.dataset.filename);
                const [removed] = order.splice(fromIdx, 1);
                order.splice(toIdx, 0, removed);
                const res = await api('/api/sounds/order', { method: 'PATCH', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ order }) });
                if (res && res.ok) fetchSounds();
            });
        }

        async function fetchTags() {
            const res = await api('/api/tags');
            if (!res || !res.ok) return;
            const d = await res.json();
            tagsList = d.tags || [];
            hiddenTags = d.hidden || [];
            const prefs = loadPrefs();
            if (prefs.lastTag != null && tagsList.includes(prefs.lastTag)) selectedTag = prefs.lastTag;
            renderTagTabs();
        }

        function renderTagTabs() {
            const container = document.getElementById('tagTabs');
            const isAdmin = isAdminOrSuperadmin();
            const showManage = isAdmin && manageTagsMode;
            const esc = (x) => (x != null ? x : '').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
            const visibleTags = showManage ? (tagsList || []) : (tagsList || []).filter(t => !hiddenTags.includes(t));
            let html = '<button type="button" class="tag-tab' + (selectedTag === null ? ' active' : '') + '" data-tag="" onclick="selectTag(null)">All</button>';
            visibleTags.forEach(t => {
                const active = selectedTag === t;
                const isHidden = hiddenTags.includes(t);
                if (showManage) {
                    html += '<div class="tag-tab-wrap" data-tag="' + esc(t) + '" draggable="true">';
                    html += '<button type="button" class="tag-tab' + (active ? ' active' : '') + (isHidden ? ' hidden-tag' : '') + '" data-tag="' + esc(t) + '" onclick="selectTag(this.dataset.tag)" ondblclick="event.preventDefault(); startRenameTag(this.dataset.tag)" title="Double-click to rename">' + esc(t) + '</button>';
                    html += '<button type="button" class="tag-tab" data-tag="' + esc(t) + '" onclick="event.stopPropagation(); toggleTagHidden(this.dataset.tag)" title="' + (isHidden ? 'Show' : 'Hide') + '">' + (isHidden ? 'üëÅ‚Äçüó®' : 'üëÅ') + '</button>';
                    html += '<button type="button" class="tag-tab delete" data-tag="' + esc(t) + '" onclick="event.stopPropagation(); deleteTag(this.dataset.tag)" title="Delete tag">‚úï</button>';
                    html += '</div>';
                } else {
                    html += '<button type="button" class="tag-tab' + (active ? ' active' : '') + '" data-tag="' + esc(t) + '" onclick="selectTag(this.dataset.tag)">' + esc(t) + '</button>';
                }
            });
            container.innerHTML = html;
            container.classList.toggle('manage-mode', showManage);
            const mtb = document.getElementById('manageTagsBtn'); if (mtb) mtb.classList.toggle('active', manageTagsMode);
            const ta = document.getElementById('tagsAdmin'); if (ta) ta.classList.toggle('hidden', !showManage);
            if (showManage) setupTagTabDragDrop(container);
        }

        function setupTagTabDragDrop(container) {
            container.addEventListener('dragstart', (e) => {
                const wrap = e.target.closest('.tag-tab-wrap');
                if (!wrap) return;
                e.dataTransfer.setData('text/plain', wrap.dataset.tag || '');
                e.dataTransfer.effectAllowed = 'move';
                e.stopPropagation();
                wrap.classList.add('dragging');
            });
            container.addEventListener('dragend', (e) => {
                const ttw = e.target.closest('.tag-tab-wrap'); if (ttw) ttw.classList.remove('dragging');
                container.querySelectorAll('.tag-tab-wrap').forEach(el => el.classList.remove('drag-over'));
            });
            container.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.stopPropagation();
                e.dataTransfer.dropEffect = 'move';
                const wrap = e.target.closest('.tag-tab-wrap');
                container.querySelectorAll('.tag-tab-wrap').forEach(el => el.classList.remove('drag-over'));
                if (wrap) wrap.classList.add('drag-over');
            });
            container.addEventListener('drop', async (e) => {
                e.preventDefault();
                e.stopPropagation();
                const fromName = e.dataTransfer.getData('text/plain');
                const toWrap = e.target.closest('.tag-tab-wrap');
                container.querySelectorAll('.tag-tab-wrap').forEach(el => el.classList.remove('drag-over'));
                if (!fromName || !toWrap) return;
                const wraps = [...container.querySelectorAll('.tag-tab-wrap')];
                const fromIdx = wraps.findIndex(w => w.dataset.tag === fromName);
                const toIdx = wraps.findIndex(w => w === toWrap);
                if (fromIdx === -1 || toIdx === -1 || fromIdx === toIdx) return;
                const order = wraps.map(w => w.dataset.tag);
                const [removed] = order.splice(fromIdx, 1);
                order.splice(toIdx, 0, removed);
                const res = await api('/api/tags', { method: 'PATCH', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ tags: order }) });
                if (res && res.ok) { const d = await res.json(); tagsList = d.tags || tagsList; renderTagTabs(); fetchSounds(); }
            });
        }

        function toggleManageTags() {
            manageTagsMode = !manageTagsMode;
            renderTagTabs();
        }

        function startRenameTag(currentName) {
            const container = document.getElementById('tagTabs');
            const wrap = container ? [...container.querySelectorAll('.tag-tab-wrap')].find(w => w.dataset.tag === currentName) : null;
            if (!wrap) return;
            const tabBtn = wrap.querySelector('.tag-tab:not(.delete)');
            if (!tabBtn) return;
            const input = document.createElement('input');
            input.type = 'text';
            input.className = 'tag-tab-rename';
            input.value = currentName;
            tabBtn.style.display = 'none';
            wrap.insertBefore(input, tabBtn);
            input.focus();
            input.select();
            function finish() {
                const newName = input.value.trim();
                input.remove();
                tabBtn.style.display = '';
                if (newName && newName !== currentName) {
                    api('/api/tags/rename', { method: 'PATCH', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ oldName: currentName, newName }) }).then(async (res) => {
                        if (res && res.ok) {
                            await fetchTags();
                            if (selectedTag === currentName) selectedTag = newName;
                            renderTagTabs();
                            fetchSounds();
                        }
                    });
                }
            }
            input.addEventListener('blur', finish);
            input.addEventListener('keydown', (e) => { if (e.key === 'Enter') finish(); if (e.key === 'Escape') { input.value = currentName; finish(); } });
        }

        async function toggleTagHidden(tag) {
            const isHidden = hiddenTags.includes(tag);
            const res = await api('/api/tags/' + encodeURIComponent(tag) + '/hidden', { method: 'PATCH', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ hidden: !isHidden }) });
            if (res && res.ok) { await fetchTags(); renderTagTabs(); }
        }

        function selectTag(tag) {
            selectedTag = tag || null;
            savePrefs({ lastTag: selectedTag });
            if (mobileView) mobilePageIndex = 0;
            renderTagTabs();
            renderSoundsGrid();
        }

        async function deleteTag(name) {
            if (!confirm('Delete tag "' + name + '"? It will be removed from all sounds.')) return;
            const res = await api('/api/tags/' + encodeURIComponent(name), { method: 'DELETE' });
            if (!res || !res.ok) return;
            tagsList = (tagsList || []).filter(t => t !== name);
            if (selectedTag === name) selectedTag = null;
            renderTagTabs();
            fetchSounds();
        }

        async function fetchSounds() {
            const res = await api('/api/sounds');
            if (!res || !res.ok) return;
            const data = await res.json();
            soundsList = Array.isArray(data) ? data : (data.list || []);
            if (data && !Array.isArray(data)) {
                if (Array.isArray(data.tags)) tagsList = data.tags;
                if (Array.isArray(data.hidden)) hiddenTags = data.hidden;
                const prefs = loadPrefs();
                if (prefs.lastTag != null && tagsList.includes(prefs.lastTag)) selectedTag = prefs.lastTag;
                renderTagTabs();
            }
            renderSoundsGrid();
        }

        function renderSoundsGrid() {
            const grid = document.getElementById('soundsList');
            const filtered = getFilteredSounds();
            const isUser = (user && user.role) === 'user';
            const isGuest = (user && user.role) === 'guest';
            const guestCooldown = getGuestCooldownRemaining();
            const adminPlaying = (playback.status === 'playing' || playback.status === 'paused') && ((playback.startedBy && playback.startedBy.role) === 'admin' || (playback.startedBy && playback.startedBy.role) === 'superadmin');
            const cannotOverride = (isUser || isGuest) && adminPlaying;
            const canPlay = (!isUser && !isGuest) || ((!playbackLocked) && (isGuest ? guestCooldown === 0 : true) && !cannotOverride);
            const tooLong = (dur) => (isUser || isGuest) && dur != null && dur > MAX_USER_DURATION;
            const isAdmin = isAdminOrSuperadmin();
            grid.innerHTML = filtered.map((s, idx) => {
                const esc = (x) => (x != null ? x : '').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#39;');
                const name = esc(s.displayName || s.filename);
                const filename = esc(s.filename);
                const dur = s.duration;
                const disabled = !canPlay || tooLong(dur);
                const selected = selectedSound === s.filename ? ' sound-item-selected' : '';
                let title = '';
                if (!canPlay) title = cannotOverride ? 'An admin or superadmin is playing. You cannot override.' : (playbackLocked ? 'Playback is locked' : (isGuest && guestCooldown > 0 ? 'Wait ' + guestCooldown + 's before playing again' : 'Cannot play'));
                else if (tooLong(dur)) title = 'Only sounds 7s or shorter allowed';
                const editBtn = isAdmin && !reorderMode ? `<button type="button" class="sound-edit" data-filename="${filename}" title="Edit sound" onclick="event.stopPropagation(); openSoundPanelFromSound(this.dataset.filename)"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/></svg></button>` : '';
                const favIdx = getFavorites().indexOf(s.filename);
                const favActive = favIdx >= 0 ? ' active' : '';
                const favTitle = favIdx >= 0 ? `Favorite slot ${favIdx + 1} (click to remove)` : 'Add to favorites (1‚Äì9)';
                const favBtn = `<button type="button" class="sound-fav${favActive}" data-filename="${filename}" title="${favTitle}" onclick="event.stopPropagation(); toggleFavorite(this.dataset.filename)"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linejoin="round"><polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"/></svg></button>`;
                const inner = `
                    <div class="sound-item${selected}" data-filename="${filename}" data-index="${idx}">
                        <span class="sound-drag-handle" data-filename="${filename}" title="Drag to reorder">‚ãÆ‚ãÆ</span>
                        <button type="button" class="sound-btn ${disabled ? 'disabled' : ''}" data-filename="${filename}" data-displayname="${name}" data-duration="${dur != null ? dur : ''}" data-tags="${esc((s.tags || []).join(', '))}" ${disabled ? 'disabled' : ''} title="${title}" onclick="playSound(this.dataset.filename)">
                            <span class="sound-btn-label">${name}</span>
                            <span class="sound-btn-duration">${dur != null ? formatTime(dur) : '‚Äî'}</span>
                        </button>
                        <div class="sound-item-actions">
                            ${favBtn}
                            <button type="button" class="sound-preview" data-filename="${filename}" title="Preview (play locally)" onclick="event.stopPropagation(); previewSound(this.dataset.filename, this)"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M5 3l14 9-14 9V3z"/></svg></button>
                            ${editBtn}
                        </div>
                    </div>`;
                return `<div class="sound-item-wrap" data-filename="${filename}" ${reorderMode && isAdmin ? 'draggable="true"' : ''}>${inner}</div>`;
            }).join('');
            grid.classList.toggle('reorder-mode', reorderMode);
            grid.classList.toggle('compact-mode', compactMode);
            renderFavoritesBar();
            if (mobileView) renderMobileGrid();
            const msg = document.getElementById('userLockedMsg');
            if (msg && (isUser || isGuest) && playbackLocked) msg.classList.remove('hidden');
            else if (msg) msg.classList.add('hidden');
        }

        function editSoundName(btn) {
            openSoundPanelFromSound(btn.dataset.filename);
        }

        function getAllTagsForAutocomplete() {
            const fromList = new Set(tagsList || []);
            (soundsList || []).forEach(s => { (s.tags || []).forEach(t => fromList.add(t)); });
            return [...fromList].sort();
        }

        function setupTagsAutocomplete(tagsEl) {
            if (!tagsEl) return;
            const suggestionsEl = document.getElementById('soundPanelTagsSuggestions');
            if (!suggestionsEl) return;
            let selectedIdx = -1;
            let hideTimeout = null;

            function getCurrentToken() {
                const val = tagsEl.value || '';
                const sep = /[,\s]/;
                let i = val.length - 1;
                while (i >= 0 && !sep.test(val[i])) i--;
                return val.slice(i + 1).toLowerCase();
            }

            function getPrefix() {
                const val = tagsEl.value || '';
                const sep = /[,\s]/;
                let i = val.length - 1;
                while (i >= 0 && !sep.test(val[i])) i--;
                return val.slice(0, i + 1);
            }

            function showSuggestions() {
                const token = getCurrentToken();
                const all = getAllTagsForAutocomplete();
                const matches = token ? all.filter(t => t.toLowerCase().startsWith(token) && t.toLowerCase() !== token) : all.slice(0, 10);
                selectedIdx = -1;
                if (matches.length === 0) {
                    suggestionsEl.classList.add('hidden');
                    suggestionsEl.innerHTML = '';
                    return;
                }
                suggestionsEl.innerHTML = matches.map((t, i) => `<div class="tag-suggestion" data-tag="${(t || '').replace(/"/g, '&quot;')}" data-idx="${i}">${(t || '').replace(/&/g, '&amp;').replace(/</g, '&lt;')}</div>`).join('');
                suggestionsEl.classList.remove('hidden');
                suggestionsEl.querySelectorAll('.tag-suggestion').forEach(el => {
                    el.addEventListener('click', () => {
                        applySuggestion(el.dataset.tag);
                        suggestionsEl.classList.add('hidden');
                    });
                });
            }

            function applySuggestion(tag) {
                const prefix = getPrefix();
                const sep = prefix && !/[,\s]$/.test(prefix) ? ', ' : '';
                tagsEl.value = prefix + sep + tag + ', ';
                tagsEl.focus();
                showSuggestions();
            }

            function hideSuggestions() {
                hideTimeout = setTimeout(() => suggestionsEl.classList.add('hidden'), 150);
            }

            tagsEl.removeEventListener('input', tagsEl._acInput);
            tagsEl.removeEventListener('keydown', tagsEl._acKeydown);
            tagsEl.removeEventListener('focus', tagsEl._acFocus);
            tagsEl.removeEventListener('blur', tagsEl._acBlur);

            tagsEl._acInput = () => { clearTimeout(hideTimeout); showSuggestions(); };
            tagsEl._acKeydown = (e) => {
                if (suggestionsEl.classList.contains('hidden')) return;
                const items = suggestionsEl.querySelectorAll('.tag-suggestion');
                if (e.key === 'ArrowDown') { e.preventDefault(); selectedIdx = Math.min(selectedIdx + 1, items.length - 1); items.forEach((el, i) => el.classList.toggle('selected', i === selectedIdx)); return; }
                if (e.key === 'ArrowUp') { e.preventDefault(); selectedIdx = Math.max(selectedIdx - 1, -1); items.forEach((el, i) => el.classList.toggle('selected', i === selectedIdx)); return; }
                if (e.key === 'Enter' && selectedIdx >= 0 && items[selectedIdx]) { e.preventDefault(); applySuggestion(items[selectedIdx].dataset.tag); suggestionsEl.classList.add('hidden'); return; }
                if (e.key === 'Escape') { e.preventDefault(); suggestionsEl.classList.add('hidden'); }
            };
            tagsEl._acFocus = () => { clearTimeout(hideTimeout); showSuggestions(); };
            tagsEl._acBlur = () => hideSuggestions();

            tagsEl.addEventListener('input', tagsEl._acInput);
            tagsEl.addEventListener('keydown', tagsEl._acKeydown);
            tagsEl.addEventListener('focus', tagsEl._acFocus);
            tagsEl.addEventListener('blur', tagsEl._acBlur);
        }

        function openSoundPanel(s) {
            const panel = document.getElementById('soundPanel');
            const nameEl = document.getElementById('soundPanelName');
            const tagsEl = document.getElementById('soundPanelTags');
            const durEl = document.getElementById('soundPanelDuration');
            if (!panel || !nameEl || !tagsEl) return;
            nameEl.value = (s && (s.displayName || s.filename)) || '';
            nameEl.dataset.filename = (s && s.filename) || '';
            tagsEl.value = (s && (s.tags || []).join(', ')) || '';
            durEl.textContent = (s && s.duration != null) ? formatTime(s.duration) : '‚Äî';
            panel.classList.remove('hidden');
            setupTagsAutocomplete(tagsEl);
        }

        function openSoundPanelFromSound(filename) {
            const s = soundsList.find(x => x.filename === filename);
            selectedSound = filename;
            renderSoundsGrid();
            openSoundPanel(s || { filename, displayName: filename, duration: null, tags: [] });
        }

        let previewAudio = null;
        let previewBtn = null;
        let previewId = 0;
        function previewSound(filename, btn) {
            if (!filename) return;
            if (previewBtn === btn && previewAudio) {
                previewAudio.pause();
                previewAudio = null;
                btn.classList.remove('playing');
                return;
            }
            if (previewAudio) {
                previewAudio.pause();
                previewAudio = null;
                if (previewBtn) previewBtn.classList.remove('playing');
            }
            const id = ++previewId;
            const url = '/api/sounds/audio/' + encodeURIComponent(filename);
            fetch(url, { credentials: 'include' }).then(r => {
                if (!r.ok) throw new Error('Preview failed');
                return r.arrayBuffer();
            }).then(buf => {
                if (id !== previewId) return;
                const blob = new Blob([buf]);
                const audio = new Audio(URL.createObjectURL(blob));
                audio.addEventListener('ended', () => { URL.revokeObjectURL(audio.src); previewAudio = null; if (previewBtn) previewBtn.classList.remove('playing'); });
                audio.addEventListener('error', () => { if (audio.src) URL.revokeObjectURL(audio.src); previewAudio = null; if (previewBtn) previewBtn.classList.remove('playing'); });
                previewAudio = audio;
                previewBtn = btn;
                btn.classList.add('playing');
                audio.play().catch(() => { previewAudio = null; btn.classList.remove('playing'); });
            }).catch(() => { if (id === previewId) { previewAudio = null; btn.classList.remove('playing'); } });
        }

        function closeSoundPanel() {
            selectedSound = null;
            const sp = document.getElementById('soundPanel'); if (sp) sp.classList.add('hidden');
            renderSoundsGrid();
        }

        async function saveSoundPanel() {
            const nameEl = document.getElementById('soundPanelName');
            const tagsEl = document.getElementById('soundPanelTags');
            const filename = nameEl && nameEl.dataset.filename;
            if (!filename) return;
            const displayName = ((nameEl && nameEl.value) || '').trim() || filename;
            const tagsRaw = ((tagsEl && tagsEl.value) || '').trim();
            const tags = tagsRaw ? tagsRaw.split(/[,\s]+/).map(t => t.trim()).filter(Boolean);
            const res = await api('/api/sounds/metadata', {
                method: 'PATCH',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ filename, displayName, tags }),
            });
            if (res && res.ok) { fetchSounds(); nameEl.dataset.filename = filename; }
        }

        async function joinChannel() {
            const channelId = document.getElementById('channelSelect').value;
            await api('/api/join', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ channelId }) });
        }

        async function leaveChannel() {
            await api('/api/leave', { method: 'POST' });
        }

        async function playSound(filename, startTime) {
            const body = { filename };
            if (typeof startTime === 'number' && startTime > 0) body.startTime = startTime;
            const res = await api('/api/play', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(body) });
            if (!res) return;
            const data = await res.json().catch(() => ({}));
            if (!res.ok) {
                const msg = data.error || data.message || 'Failed to play';
                if (res.status === 429 && data.cooldownRemaining) {
                    guestLastPlayTime = Date.now() - (GUEST_COOLDOWN_SEC - data.cooldownRemaining) * 1000;
                    renderSoundsGrid();
                }
                alert(msg);
                return;
            }
            if ((user && user.role) === 'guest') guestLastPlayTime = Date.now();
            playback.duration = (data.duration != null ? data.duration : null);
            playback.startTime = Date.now();
            playback.startTimeOffset = (data.startTimeOffset != null ? data.startTimeOffset : 0);
            playback.serverCurrentTime = undefined;
            playback.status = 'playing';
            playback.displayName = (data.displayName != null ? data.displayName : filename);
            playback.filename = filename;
            playback.startedBy = (data.startedBy != null ? data.startedBy : { username: (user && user.username), role: (user && user.role) });
            pausedAt = 0;
            updateNowPlaying();
            updatePlayPauseButton();
            const timeEl = document.getElementById('progressTime');
            if (timeEl) timeEl.textContent = '0:00 / ' + (playback.duration != null ? formatTime(playback.duration) : '0:00');
            loadWaveform(filename);
        }

        async function loadWaveform(filename) {
            waveformData = null;
            waveformDuration = 0;
            waveformFilename = null;
            document.getElementById('waveformPlaceholder').style.display = 'block';
            document.getElementById('waveformWrap').style.display = 'none';
            if (!filename) return;
            try {
                const res = await fetch('/api/sounds/audio/' + encodeURIComponent(filename), { credentials: CREDENTIALS });
                if (!res.ok) return;
                const buf = await res.arrayBuffer();
                const ctx = new (window.AudioContext || window.webkitAudioContext)();
                const decoded = await ctx.decodeAudioData(buf);
                const ch = decoded.getChannelData(0);
                const duration = decoded.duration;
                const bars = 120;
                const step = Math.floor(ch.length / bars);
                const peaks = [];
                for (let i = 0; i < bars; i++) {
                    let min = 0, max = 0;
                    for (let j = 0; j < step; j++) {
                        const v = ch[i * step + j];
                        if (v < min) min = v;
                        if (v > max) max = v;
                    }
                    peaks.push({ min, max });
                }
                waveformData = peaks;
                waveformDuration = duration;
                waveformFilename = filename;
                document.getElementById('waveformPlaceholder').style.display = 'none';
                document.getElementById('waveformWrap').style.display = 'block';
                drawWaveform(Math.min(getCurrentPlaybackTime(), duration), duration);
            } catch (e) {
                console.warn('Waveform load failed', e);
            }
        }

        function drawWaveform(currentTime, totalDuration) {
            const canvas = document.getElementById('waveformCanvas');
            const wrap = document.getElementById('waveformWrap');
            if (!wrap || wrap.style.display === 'none' || !waveformData || !waveformData.length) return;
            const w = wrap.clientWidth || 600;
            const h = 48;
            canvas.width = w;
            canvas.height = h;
            const ctx = canvas.getContext('2d');
            const barCount = waveformData.length;
            const barW = Math.max(1, (w / barCount) - 1);
            const total = totalDuration != null && totalDuration > 0 ? totalDuration : waveformDuration;
            const progress = total > 0 ? Math.min(1, currentTime / total) : 0;
            const playheadX = progress * w;
            ctx.clearRect(0, 0, w, h);
            waveformData.forEach((peak, i) => {
                const x = (i / barCount) * w;
                const center = h / 2;
                const halfH = Math.max(1, (Math.abs(peak.max - peak.min) / 2) * (h * 0.4));
                const isPast = x + barW < playheadX;
                ctx.fillStyle = isPast ? 'rgba(124, 58, 237, 0.6)' : 'rgba(42, 42, 50, 0.8)';
                ctx.fillRect(x, center - halfH, barW, halfH * 2);
            });
            ctx.fillStyle = 'rgba(255,255,255,0.9)';
            ctx.fillRect(Math.floor(playheadX), 0, 2, h);
        }

        let lastServerCurrentTimeReceivedAt = 0;
        function isLocalPlayer() {
            return playback.startedBy && playback.startedBy.username === (user && user.username);
        }
        function getCurrentPlaybackTime() {
            if (isLocalPlayer()) {
                if (playback.status === 'playing' && playback.startTime != null) {
                    const start = Number(playback.startTime);
                    if (!Number.isFinite(start)) return 0;
                    const offset = playback.startTimeOffset || 0;
                    let current = offset + (Date.now() - start) / 1000;
                    if (playback.duration != null) current = Math.min(current, playback.duration);
                    return Math.max(0, current);
                }
                if (playback.status === 'paused') return pausedAt;
                return 0;
            }
            if (playback.serverCurrentTime != null) {
                if (playback.status === 'playing') {
                    const elapsed = (Date.now() - lastServerCurrentTimeReceivedAt) / 1000;
                    let current = playback.serverCurrentTime + elapsed;
                    if (playback.duration != null) current = Math.min(current, playback.duration);
                    return Math.max(0, current);
                }
                return playback.serverCurrentTime;
            }
            if (playback.status === 'playing' && playback.startTime != null) {
                const start = Number(playback.startTime);
                if (!Number.isFinite(start)) return 0;
                const offset = playback.startTimeOffset || 0;
                let current = offset + (Date.now() - start) / 1000;
                if (playback.duration != null) current = Math.min(current, playback.duration);
                return Math.max(0, current);
            }
            if (playback.status === 'paused') return pausedAt;
            return 0;
        }

        function tickWaveform() {
            const isActive = playback.status === 'playing' || playback.status === 'paused';
            if (isActive) {
                const current = getCurrentPlaybackTime();
                const timeEl = document.getElementById('progressTime');
                const dur = playback.duration;
                if (timeEl) timeEl.textContent = formatTime(current) + ' / ' + (dur != null ? formatTime(dur) : '‚Äî');
            }
            if (waveformData && waveformDuration > 0 && isActive) {
                const current = getCurrentPlaybackTime();
                const total = playback.duration != null ? playback.duration : waveformDuration;
                drawWaveform(Math.min(current, total), total);
            }
            if ((user && user.role) === 'guest') {
                const r = getGuestCooldownRemaining();
                if (r > 0 && r !== lastGuestCooldownShown) { lastGuestCooldownShown = r; renderSoundsGrid(); }
                else if (r === 0 && lastGuestCooldownShown > 0) { lastGuestCooldownShown = 0; renderSoundsGrid(); }
                else if (r === 0) lastGuestCooldownShown = -1;
            }
        }

        async function stopPlayback() {
            const res = await api('/api/stop', { method: 'POST' });
            if (!res) return;
            playback = { status: 'idle', filename: null, displayName: null, startTime: null, duration: null, startTimeOffset: 0, startedBy: null };
            pausedAt = 0;
            waveformData = null;
            waveformDuration = 0;
            waveformFilename = null;
            document.getElementById('waveformPlaceholder').style.display = 'block';
            document.getElementById('waveformPlaceholder').textContent = 'Waveform will appear when a sound is playing';
            document.getElementById('waveformWrap').style.display = 'none';
            updateNowPlaying();
            updatePlayPauseButton();
        }

        async function togglePlayPause() {
            if (playback.status === 'playing') {
                await api('/api/pause', { method: 'POST' });
                const offset = playback.startTimeOffset || 0;
                pausedAt = offset + (Date.now() - (playback.startTime || 0)) / 1000;
                if (playback.duration != null) pausedAt = Math.min(pausedAt, playback.duration);
                playback.status = 'paused';
            } else if (playback.status === 'paused') {
                await api('/api/resume', { method: 'POST' });
                playback.startTime = Date.now();
                playback.startTimeOffset = pausedAt;
                playback.status = 'playing';
            }
            updatePlayPauseButton();
        }

        function updatePlayPauseButton() {
            const btn = document.getElementById('playPauseBtn');
            if (!btn || btn.classList.contains('hidden')) return;
            const isActive = playback.status === 'playing' || playback.status === 'paused';
            btn.disabled = !isActive;
            btn.textContent = playback.status === 'playing' ? '‚è∏' : '‚ñ∂';
            btn.title = playback.status === 'playing' ? 'Pause' : 'Play';
            updateStopButtons();
        }

        function updateStopButtons() {
            const stopAll = document.getElementById('stopAllBtn');
            const stopBtn = document.getElementById('stopBtn');
            const isActive = playback.status === 'playing' || playback.status === 'paused';
            const adminCantStop = (user && user.role) === 'admin' && playback.startedBy && (playback.startedBy.role === 'admin' || playback.startedBy.role === 'superadmin');
            const disabled = !isActive || adminCantStop;
            if (stopAll) { stopAll.disabled = disabled; stopAll.title = adminCantStop ? 'Only superadmin can stop admin playback' : 'Stop playback'; }
            if (stopBtn) { stopBtn.disabled = disabled; stopBtn.title = adminCantStop ? 'Only superadmin can stop admin playback' : 'Stop'; }
        }

        function updateNowPlaying() {
            const card = document.getElementById('playerCard');
            const text = document.getElementById('nowPlayingText');
            if (playback.status === 'idle' || !playback.displayName) {
                text.innerHTML = 'Nothing playing';
                card.classList.add('player-idle');
            } else {
                let html = 'Now playing: <strong>' + (playback.displayName || playback.filename || '') + '</strong>';
                if (playback.startedBy && playback.startedBy.username) {
                    html += ' <span style="color:var(--text-muted);font-weight:400">by ' + (playback.startedBy.username || '').replace(/&/g, '&amp;').replace(/</g, '&lt;') + (playback.startedBy.role ? ' (' + playback.startedBy.role + ')' : '') + '</span>';
                }
                text.innerHTML = html;
                card.classList.remove('player-idle');
            }
        }

        function formatTime(s) {
            if (s == null || !Number.isFinite(s)) return '0:00';
            const m = Math.floor(s / 60);
            const sec = Math.floor(s % 60);
            return m + ':' + (sec < 10 ? '0' : '') + sec;
        }

        let playbackPollingStarted = false;
        let pendingCountPollingStarted = false;
        function startPlaybackPolling() {
            if (playbackPollingStarted) return;
            playbackPollingStarted = true;
            refreshPlaybackState();
            setTimeout(() => setInterval(refreshPlaybackState, 400), 600);
        }
        function startPendingCountPolling() {
            if (pendingCountPollingStarted || (user && user.role) !== 'superadmin') return;
            pendingCountPollingStarted = true;
            fetchPendingCount();
            setInterval(fetchPendingCount, 30000);
        }

        function refreshPlaybackState() {
            if (!user) return;
            api('/api/playback-state').then(async (res) => {
                if (!res || !res.ok) return;
                const state = await res.json();
                if (state.status === 'idle' && playback.status === 'playing' && playback.startTime != null) {
                    const started = Number(playback.startTime);
                    if (Number.isFinite(started) && (Date.now() - started) < 3000) return;
                }
                playback.status = state.status;
                playback.filename = state.filename;
                playback.displayName = (state.displayName != null ? state.displayName : state.filename);
                playback.startedBy = (state.startedBy != null ? state.startedBy : null);
                const amLocal = state.startedBy && state.startedBy.username === (user && user.username);
                if (!amLocal) {
                    if (state.startTime != null) playback.startTime = Number(state.startTime);
                    if (playback.startTimeOffset === undefined) playback.startTimeOffset = 0;
                }
                if (state.duration != null) playback.duration = state.duration;
                if (!amLocal && state.currentTime != null) { playback.serverCurrentTime = Number(state.currentTime); lastServerCurrentTimeReceivedAt = Date.now(); if (state.status === 'paused') pausedAt = playback.serverCurrentTime; }
                if (amLocal && state.status === 'paused' && state.currentTime != null) pausedAt = Number(state.currentTime);
                if (state.status === 'idle') { pausedAt = 0; playback.startTime = null; playback.startedBy = null; playback.serverCurrentTime = undefined; lastServerCurrentTimeReceivedAt = 0; waveformData = null; waveformFilename = null; }
                if ((state.status === 'playing' || state.status === 'paused') && state.filename && waveformFilename !== state.filename) loadWaveform(state.filename);
                updateNowPlaying();
                updatePlayPauseButton();
                updateStopButtons();

                const timeEl = document.getElementById('progressTime');
                let current = getCurrentPlaybackTime();
                const dur = playback.duration;
                timeEl.textContent = formatTime(current) + ' / ' + (dur != null ? formatTime(dur) : '‚Äî');

                const totalDur = dur != null ? dur : waveformDuration;
                if (waveformData && totalDur > 0) {
                    drawWaveform(Math.min(current, totalDur), totalDur);
                }
                if ((user && user.role) === 'user' || (user && user.role) === 'guest') renderSoundsGrid();
            });
        }

        const ww = document.getElementById('waveformWrap'); if (ww) ww.addEventListener('click', (e) => {
            if (!waveformData || waveformDuration <= 0 || !playback.filename) return;
            const canvas = document.getElementById('waveformCanvas');
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) / rect.width;
            const t = Math.max(0, Math.min(waveformDuration, x * waveformDuration));
            if (t < waveformDuration - 0.5) playSound(playback.filename, Number(t));
        });

        function setVolume(volume) {
            const v = parseFloat(volume);
            document.getElementById('volumeLabel').textContent = Math.round(v * 100) + '%';
            fetch('/api/volume', { method: 'POST', headers: { 'Content-Type': 'application/json' }, credentials: CREDENTIALS, body: JSON.stringify({ volume: v }) });
        }

        document.getElementById('volumeSlider').addEventListener('input', (e) => setVolume(e.target.value));

        const cs = document.getElementById('channelSelect'); if (cs) cs.addEventListener('change', (e) => savePrefs({ lastChannelId: e.target.value }));

        (function initTheme() {
            applyTheme(loadPrefs().theme);
            const tt = document.getElementById('themeToggle'); if (tt) tt.addEventListener('click', toggleTheme);
        })();

        const sfi = document.getElementById('soundFilterInput'); if (sfi) sfi.addEventListener('input', (e) => {
            soundFilter = (e.target.value || '').trim();
            savePrefs({ soundFilter });
            renderSoundsGrid();
        });

        async function uploadSound(file) {
            const fileInput = document.getElementById('fileInput');
            const f = file || (fileInput && fileInput.files && fileInput.files[0]);
            if (!f) return;
            const formData = new FormData();
            formData.append('soundFile', f);
            const res = await api('/api/upload', { method: 'POST', body: formData });
            if (!res) return;
            const data = await res.json().catch(() => ({}));
            if (res.ok) {
                fileInput.value = '';
                fetchSounds();
                if (data.pending) alert(data.message || 'Upload sent for moderation.');
            } else {
                alert(data.error || 'Upload failed');
            }
        }

        document.getElementById('fileInput').addEventListener('change', () => uploadSound());

        (function initUploadZone() {
            const zone = document.getElementById('uploadZone');
            if (!zone) return;
            zone.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.stopPropagation();
                e.dataTransfer.dropEffect = 'copy';
                zone.classList.add('drag-over');
            });
            zone.addEventListener('dragleave', (e) => {
                e.preventDefault();
                e.stopPropagation();
                if (!zone.contains(e.relatedTarget)) zone.classList.remove('drag-over');
            });
            zone.addEventListener('drop', (e) => {
                e.preventDefault();
                e.stopPropagation();
                zone.classList.remove('drag-over');
                const f = e.dataTransfer.files && e.dataTransfer.files[0];
                if (f) uploadSound(f);
            });
        })();

        (async function init() {
            setupSoundGridDragDrop(document.getElementById('soundsList'));
            fetchGuestStatus();
            const ok = await checkAuth();
            if (!ok) return;
            applyPrefs();
            startPlaybackPolling();
            setInterval(tickWaveform, 100);
            fetchChannels();
            fetchSounds();
            updateNowPlaying();
            updatePlayPauseButton();
            window.addEventListener('resize', () => { if (mobileView) renderMobileGrid(); });
            document.addEventListener('keydown', (e) => {
                const tag = document.activeElement && document.activeElement.tagName;
                if (tag === 'INPUT' || tag === 'TEXTAREA' || (document.activeElement && document.activeElement.isContentEditable)) return;
                if (e.key >= '1' && e.key <= '9') {
                    const fav = getFavorites()[parseInt(e.key, 10) - 1];
                    if (fav) { e.preventDefault(); playSound(fav); }
                } else if (e.key === ' ') {
                    if (playback.status === 'playing' || playback.status === 'paused') { e.preventDefault(); togglePlayPause(); }
                } else if (e.key === 's' || e.key === 'S') {
                    e.preventDefault();
                    stopPlayback();
                } else if (e.key === 'Escape') {
                    const panel = document.getElementById('soundPanel');
                    if (panel && !panel.classList.contains('hidden')) { e.preventDefault(); closeSoundPanel(); }
                }
            });
        })();
    </script>
</body>
</html>
